<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unix Network Programming | Org Mode</title><meta name=keywords content="Linux,,Network"><meta name=description content="问题  程序异常终止   此时所有打开的文件描述符将被关闭，TCP 连接发送一个 FIN 。然后呢？对端的确认报文是否收到无所谓？ 对端发送 FIN 报文，此时已经终止？无法恢复确认报文？对端会重复发送？ IP 分片(fragment) – TCP 分段  MTU : 最大传输单元   链路层对网络数据帧的一个限制：以太网限制 MTU 为 1500 字节。 尽管 IP 报文头中有 16 位表示数据报的长度（最大长度 2^16-1=65535） IP 报文的长度超过 MTU 就需要分片，IP 数据报的分片与重组都是在网络层完成的。 IP 头有 3 个标志位，一个标志位保留；一个标志位 DF 表示是否允许分片，为 0 表示允许分片，为 1 表示禁止 分片，当报文长度大于 MTU 则丢弃该报文，并向源主机发送 ICMP 报文；一个标志位 MF 表示之后是否还有分片 片偏移用于确定该片偏移原始数据报开始处的位置。 16 位标识用于确定相应的片是否属于同一个 IP 报文。 每个以太帧长度在 64 bytes ~ 1518 bytes，减去以太网帧头（DMAC 48bits=6Bytes + SMAC 48bits=6Bytes + Type 2Bytes + CRC 4Bytes）最大只能有 1500 bytes。链路层数据部分长度的要求是 46bytes ~ 1500bytes MSS : 最大报文段长度   一般 MSS 为 MTU 减去 IP 首部长度 20 字节和 TCP 首部长度 20 字节，1500-40-40=1460 。但是许多 BSD 实现 版本需要 MSS 为 512 的倍数，所以一般 MSS 都是 1024。当建立一个 TCP 连接时，每一方都通告其期望的 MSS 选项（MSS 选项只能出现在 SYN 报文段中），最终选择两者中的较小者作为 MSS，是一个协商选项。 TCP 报文段的分段与重组是在运输层完成的。 不希望 IP 分片的原因   对于 IP 分片的数据报，即使丢失一片数据，也要重传整个数据报。因为 IP 层没有重传机制，没有办法只重传某 一片。所以即使 IP 分片过程看起来是透明的，但人们仍然不想用它。所以 TCP 总是避免分片，通过设置 MSS 使 得以太网帧长度不超过 MTU TCP、UDP 与 IP 分片   UDP 很容易导致分片； TCP 试图避免分片，应用程序几乎不可能强迫 TCP 发送一个需要分片的报文。 CSMA/CD   CSMA/CD是Carrier Sense Multiple Access with Collision Detection 的缩写， 可译为“载波侦听多路访问/冲突检测”，或“带有冲突检测的载波侦听多路访问”。 所谓载波侦听（carrier sense），意思是网络上各个工作站在发送数据前都要侦听总线上有没有数据传输。 若有数据传输 （称总线为忙），则不发送数据；若无数据传输（称总线为空），立即发送准备好的数据。 所谓多路访问（multiple access)意思是网络上所有工作站收发数据共同使用同一条总线，且发送数据是广播式的。 所谓冲突（collision），意思是，若网上有两个或两个以上工作站同时发送数据，在总线上就会产生信号的混合， 两个工作站都同时发送数据，在总线上就会产生信号的混合，两个工作站都辨别不出真正的数据是什么。 这种情况称数据冲突又称碰撞。为了减少冲突发生后的影响。工作站在发送数据过程中还要不停地检测自己发送的 数据，有没有在传输过程中与其它工作站的数据发生冲突，这就是冲突检测（collision detected）。    IPG(Inter-Packet Gap) Preamble Start Frame Delimiter DMAC SMAC Type Data Frame check Sequence   12Bytes 7Bytes 1Bytes 6Bytes 6Bytes 1Byte 48~1500Bytes 4Bytes    AA (01010101) AB (01010011)        帧间隙 前导码 前导码-帧界定符          CSMA/CD媒体访问控制方法的工作原理，可以概括如下： 先听后说，边听边说； 一旦冲突，立即停说； 等待时机，然后再说； 注：“听”，即监听、检测之意；“说”，即发送数据之意。 CSMA/CD网络上进行传输时，必须按下列五个步骤来进行 （1）传输前监听 （2）如果忙则等待 （3）如果空闲则传输并检测冲突 （4）如果冲突发生，重传前等待 （5）重传或夭折 主要参数： 时间片 51 2比特时间 帧间间隔 9．6 微秒 尝试极限 16 退避极限 10 人为干扰长 32 比特 最大帧长 1518 字节 最小帧长 64 字节 地址字段长 48 比特 二进制指数退避算法 1）确定基本退避时间（基数），一般定为2τ，也就是一个争用期时间，对于以太网就是51."><meta name=author content="kyle Three Stone"><link rel=canonical href=https://kylestones.github.io/hugo-blog/blog/apue/unp/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/hugo-blog/assets/css/stylesheet.abc7c82c3d415a6df50430738d1cbcc4c76fea558bc5a0c830d3babf78167a35.css integrity="sha256-q8fILD1BWm31BDBzjRy8xMdv6lWLxaDIMNO6v3gWejU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/hugo-blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="Unix Network Programming"><meta property="og:description" content="问题  程序异常终止   此时所有打开的文件描述符将被关闭，TCP 连接发送一个 FIN 。然后呢？对端的确认报文是否收到无所谓？ 对端发送 FIN 报文，此时已经终止？无法恢复确认报文？对端会重复发送？ IP 分片(fragment) – TCP 分段  MTU : 最大传输单元   链路层对网络数据帧的一个限制：以太网限制 MTU 为 1500 字节。 尽管 IP 报文头中有 16 位表示数据报的长度（最大长度 2^16-1=65535） IP 报文的长度超过 MTU 就需要分片，IP 数据报的分片与重组都是在网络层完成的。 IP 头有 3 个标志位，一个标志位保留；一个标志位 DF 表示是否允许分片，为 0 表示允许分片，为 1 表示禁止 分片，当报文长度大于 MTU 则丢弃该报文，并向源主机发送 ICMP 报文；一个标志位 MF 表示之后是否还有分片 片偏移用于确定该片偏移原始数据报开始处的位置。 16 位标识用于确定相应的片是否属于同一个 IP 报文。 每个以太帧长度在 64 bytes ~ 1518 bytes，减去以太网帧头（DMAC 48bits=6Bytes + SMAC 48bits=6Bytes + Type 2Bytes + CRC 4Bytes）最大只能有 1500 bytes。链路层数据部分长度的要求是 46bytes ~ 1500bytes MSS : 最大报文段长度   一般 MSS 为 MTU 减去 IP 首部长度 20 字节和 TCP 首部长度 20 字节，1500-40-40=1460 。但是许多 BSD 实现 版本需要 MSS 为 512 的倍数，所以一般 MSS 都是 1024。当建立一个 TCP 连接时，每一方都通告其期望的 MSS 选项（MSS 选项只能出现在 SYN 报文段中），最终选择两者中的较小者作为 MSS，是一个协商选项。 TCP 报文段的分段与重组是在运输层完成的。 不希望 IP 分片的原因   对于 IP 分片的数据报，即使丢失一片数据，也要重传整个数据报。因为 IP 层没有重传机制，没有办法只重传某 一片。所以即使 IP 分片过程看起来是透明的，但人们仍然不想用它。所以 TCP 总是避免分片，通过设置 MSS 使 得以太网帧长度不超过 MTU TCP、UDP 与 IP 分片   UDP 很容易导致分片； TCP 试图避免分片，应用程序几乎不可能强迫 TCP 发送一个需要分片的报文。 CSMA/CD   CSMA/CD是Carrier Sense Multiple Access with Collision Detection 的缩写， 可译为“载波侦听多路访问/冲突检测”，或“带有冲突检测的载波侦听多路访问”。 所谓载波侦听（carrier sense），意思是网络上各个工作站在发送数据前都要侦听总线上有没有数据传输。 若有数据传输 （称总线为忙），则不发送数据；若无数据传输（称总线为空），立即发送准备好的数据。 所谓多路访问（multiple access)意思是网络上所有工作站收发数据共同使用同一条总线，且发送数据是广播式的。 所谓冲突（collision），意思是，若网上有两个或两个以上工作站同时发送数据，在总线上就会产生信号的混合， 两个工作站都同时发送数据，在总线上就会产生信号的混合，两个工作站都辨别不出真正的数据是什么。 这种情况称数据冲突又称碰撞。为了减少冲突发生后的影响。工作站在发送数据过程中还要不停地检测自己发送的 数据，有没有在传输过程中与其它工作站的数据发生冲突，这就是冲突检测（collision detected）。    IPG(Inter-Packet Gap) Preamble Start Frame Delimiter DMAC SMAC Type Data Frame check Sequence   12Bytes 7Bytes 1Bytes 6Bytes 6Bytes 1Byte 48~1500Bytes 4Bytes    AA (01010101) AB (01010011)        帧间隙 前导码 前导码-帧界定符          CSMA/CD媒体访问控制方法的工作原理，可以概括如下： 先听后说，边听边说； 一旦冲突，立即停说； 等待时机，然后再说； 注：“听”，即监听、检测之意；“说”，即发送数据之意。 CSMA/CD网络上进行传输时，必须按下列五个步骤来进行 （1）传输前监听 （2）如果忙则等待 （3）如果空闲则传输并检测冲突 （4）如果冲突发生，重传前等待 （5）重传或夭折 主要参数： 时间片 51 2比特时间 帧间间隔 9．6 微秒 尝试极限 16 退避极限 10 人为干扰长 32 比特 最大帧长 1518 字节 最小帧长 64 字节 地址字段长 48 比特 二进制指数退避算法 1）确定基本退避时间（基数），一般定为2τ，也就是一个争用期时间，对于以太网就是51."><meta property="og:type" content="article"><meta property="og:url" content="https://kylestones.github.io/hugo-blog/blog/apue/unp/"><meta property="og:image" content="https://kylestones.github.io/hugo-blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kylestones.github.io/hugo-blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Unix Network Programming"><meta name=twitter:description content="问题  程序异常终止   此时所有打开的文件描述符将被关闭，TCP 连接发送一个 FIN 。然后呢？对端的确认报文是否收到无所谓？ 对端发送 FIN 报文，此时已经终止？无法恢复确认报文？对端会重复发送？ IP 分片(fragment) – TCP 分段  MTU : 最大传输单元   链路层对网络数据帧的一个限制：以太网限制 MTU 为 1500 字节。 尽管 IP 报文头中有 16 位表示数据报的长度（最大长度 2^16-1=65535） IP 报文的长度超过 MTU 就需要分片，IP 数据报的分片与重组都是在网络层完成的。 IP 头有 3 个标志位，一个标志位保留；一个标志位 DF 表示是否允许分片，为 0 表示允许分片，为 1 表示禁止 分片，当报文长度大于 MTU 则丢弃该报文，并向源主机发送 ICMP 报文；一个标志位 MF 表示之后是否还有分片 片偏移用于确定该片偏移原始数据报开始处的位置。 16 位标识用于确定相应的片是否属于同一个 IP 报文。 每个以太帧长度在 64 bytes ~ 1518 bytes，减去以太网帧头（DMAC 48bits=6Bytes + SMAC 48bits=6Bytes + Type 2Bytes + CRC 4Bytes）最大只能有 1500 bytes。链路层数据部分长度的要求是 46bytes ~ 1500bytes MSS : 最大报文段长度   一般 MSS 为 MTU 减去 IP 首部长度 20 字节和 TCP 首部长度 20 字节，1500-40-40=1460 。但是许多 BSD 实现 版本需要 MSS 为 512 的倍数，所以一般 MSS 都是 1024。当建立一个 TCP 连接时，每一方都通告其期望的 MSS 选项（MSS 选项只能出现在 SYN 报文段中），最终选择两者中的较小者作为 MSS，是一个协商选项。 TCP 报文段的分段与重组是在运输层完成的。 不希望 IP 分片的原因   对于 IP 分片的数据报，即使丢失一片数据，也要重传整个数据报。因为 IP 层没有重传机制，没有办法只重传某 一片。所以即使 IP 分片过程看起来是透明的，但人们仍然不想用它。所以 TCP 总是避免分片，通过设置 MSS 使 得以太网帧长度不超过 MTU TCP、UDP 与 IP 分片   UDP 很容易导致分片； TCP 试图避免分片，应用程序几乎不可能强迫 TCP 发送一个需要分片的报文。 CSMA/CD   CSMA/CD是Carrier Sense Multiple Access with Collision Detection 的缩写， 可译为“载波侦听多路访问/冲突检测”，或“带有冲突检测的载波侦听多路访问”。 所谓载波侦听（carrier sense），意思是网络上各个工作站在发送数据前都要侦听总线上有没有数据传输。 若有数据传输 （称总线为忙），则不发送数据；若无数据传输（称总线为空），立即发送准备好的数据。 所谓多路访问（multiple access)意思是网络上所有工作站收发数据共同使用同一条总线，且发送数据是广播式的。 所谓冲突（collision），意思是，若网上有两个或两个以上工作站同时发送数据，在总线上就会产生信号的混合， 两个工作站都同时发送数据，在总线上就会产生信号的混合，两个工作站都辨别不出真正的数据是什么。 这种情况称数据冲突又称碰撞。为了减少冲突发生后的影响。工作站在发送数据过程中还要不停地检测自己发送的 数据，有没有在传输过程中与其它工作站的数据发生冲突，这就是冲突检测（collision detected）。    IPG(Inter-Packet Gap) Preamble Start Frame Delimiter DMAC SMAC Type Data Frame check Sequence   12Bytes 7Bytes 1Bytes 6Bytes 6Bytes 1Byte 48~1500Bytes 4Bytes    AA (01010101) AB (01010011)        帧间隙 前导码 前导码-帧界定符          CSMA/CD媒体访问控制方法的工作原理，可以概括如下： 先听后说，边听边说； 一旦冲突，立即停说； 等待时机，然后再说； 注：“听”，即监听、检测之意；“说”，即发送数据之意。 CSMA/CD网络上进行传输时，必须按下列五个步骤来进行 （1）传输前监听 （2）如果忙则等待 （3）如果空闲则传输并检测冲突 （4）如果冲突发生，重传前等待 （5）重传或夭折 主要参数： 时间片 51 2比特时间 帧间间隔 9．6 微秒 尝试极限 16 退避极限 10 人为干扰长 32 比特 最大帧长 1518 字节 最小帧长 64 字节 地址字段长 48 比特 二进制指数退避算法 1）确定基本退避时间（基数），一般定为2τ，也就是一个争用期时间，对于以太网就是51."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":3,"name":"Unix Network Programming","item":"https://kylestones.github.io/hugo-blog/blog/apue/unp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Unix Network Programming","name":"Unix Network Programming","description":"问题  程序异常终止   此时所有打开的文件描述符将被关闭，TCP 连接发送一个 FIN 。然后呢？对端的确认报文是否收到无所谓？ 对端发送 FIN 报文，此时已经终止？无法恢复确认报文？对端会重复发送？ IP 分片(fragment) – TCP 分段  MTU : 最大传输单元   链路层对网络数据帧的一个限制：以太网限制 MTU 为 1500 字节。 尽管 IP 报文头中有 16 位表示数据报的长度（最大长度 2^16-1=65535） IP 报文的长度超过 MTU 就需要分片，IP 数据报的分片与重组都是在网络层完成的。 IP 头有 3 个标志位，一个标志位保留；一个标志位 DF 表示是否允许分片，为 0 表示允许分片，为 1 表示禁止 分片，当报文长度大于 MTU 则丢弃该报文，并向源主机发送 ICMP 报文；一个标志位 MF 表示之后是否还有分片 片偏移用于确定该片偏移原始数据报开始处的位置。 16 位标识用于确定相应的片是否属于同一个 IP 报文。 每个以太帧长度在 64 bytes ~ 1518 bytes，减去以太网帧头（DMAC 48bits=6Bytes + SMAC 48bits=6Bytes + Type 2Bytes + CRC 4Bytes）最大只能有 1500 bytes。链路层数据部分长度的要求是 46bytes ~ 1500bytes MSS : 最大报文段长度   一般 MSS 为 MTU 减去 IP 首部长度 20 字节和 TCP 首部长度 20 字节，1500-40-40=1460 。但是许多 BSD 实现 版本需要 MSS 为 512 的倍数，所以一般 MSS 都是 1024。当建立一个 TCP 连接时，每一方都通告其期望的 MSS 选项（MSS 选项只能出现在 SYN 报文段中），最终选择两者中的较小者作为 MSS，是一个协商选项。 TCP 报文段的分段与重组是在运输层完成的。 不希望 IP 分片的原因   对于 IP 分片的数据报，即使丢失一片数据，也要重传整个数据报。因为 IP 层没有重传机制，没有办法只重传某 一片。所以即使 IP 分片过程看起来是透明的，但人们仍然不想用它。所以 TCP 总是避免分片，通过设置 MSS 使 得以太网帧长度不超过 MTU TCP、UDP 与 IP 分片   UDP 很容易导致分片； TCP 试图避免分片，应用程序几乎不可能强迫 TCP 发送一个需要分片的报文。 CSMA/CD   CSMA/CD是Carrier Sense Multiple Access with Collision Detection 的缩写， 可译为“载波侦听多路访问/冲突检测”，或“带有冲突检测的载波侦听多路访问”。 所谓载波侦听（carrier sense），意思是网络上各个工作站在发送数据前都要侦听总线上有没有数据传输。 若有数据传输 （称总线为忙），则不发送数据；若无数据传输（称总线为空），立即发送准备好的数据。 所谓多路访问（multiple access)意思是网络上所有工作站收发数据共同使用同一条总线，且发送数据是广播式的。 所谓冲突（collision），意思是，若网上有两个或两个以上工作站同时发送数据，在总线上就会产生信号的混合， 两个工作站都同时发送数据，在总线上就会产生信号的混合，两个工作站都辨别不出真正的数据是什么。 这种情况称数据冲突又称碰撞。为了减少冲突发生后的影响。工作站在发送数据过程中还要不停地检测自己发送的 数据，有没有在传输过程中与其它工作站的数据发生冲突，这就是冲突检测（collision detected）。    IPG(Inter-Packet Gap) Preamble Start Frame Delimiter DMAC SMAC Type Data Frame check Sequence   12Bytes 7Bytes 1Bytes 6Bytes 6Bytes 1Byte 48~1500Bytes 4Bytes    AA (01010101) AB (01010011)        帧间隙 前导码 前导码-帧界定符          CSMA/CD媒体访问控制方法的工作原理，可以概括如下： 先听后说，边听边说； 一旦冲突，立即停说； 等待时机，然后再说； 注：“听”，即监听、检测之意；“说”，即发送数据之意。 CSMA/CD网络上进行传输时，必须按下列五个步骤来进行 （1）传输前监听 （2）如果忙则等待 （3）如果空闲则传输并检测冲突 （4）如果冲突发生，重传前等待 （5）重传或夭折 主要参数： 时间片 51 2比特时间 帧间间隔 9．6 微秒 尝试极限 16 退避极限 10 人为干扰长 32 比特 最大帧长 1518 字节 最小帧长 64 字节 地址字段长 48 比特 二进制指数退避算法 1）确定基本退避时间（基数），一般定为2τ，也就是一个争用期时间，对于以太网就是51.","keywords":["Linux,","Network"],"articleBody":" 问题  程序异常终止   此时所有打开的文件描述符将被关闭，TCP 连接发送一个 FIN 。然后呢？对端的确认报文是否收到无所谓？ 对端发送 FIN 报文，此时已经终止？无法恢复确认报文？对端会重复发送？ IP 分片(fragment) – TCP 分段  MTU : 最大传输单元   链路层对网络数据帧的一个限制：以太网限制 MTU 为 1500 字节。 尽管 IP 报文头中有 16 位表示数据报的长度（最大长度 2^16-1=65535） IP 报文的长度超过 MTU 就需要分片，IP 数据报的分片与重组都是在网络层完成的。 IP 头有 3 个标志位，一个标志位保留；一个标志位 DF 表示是否允许分片，为 0 表示允许分片，为 1 表示禁止 分片，当报文长度大于 MTU 则丢弃该报文，并向源主机发送 ICMP 报文；一个标志位 MF 表示之后是否还有分片 片偏移用于确定该片偏移原始数据报开始处的位置。 16 位标识用于确定相应的片是否属于同一个 IP 报文。 每个以太帧长度在 64 bytes ~ 1518 bytes，减去以太网帧头（DMAC 48bits=6Bytes + SMAC 48bits=6Bytes + Type 2Bytes + CRC 4Bytes）最大只能有 1500 bytes。链路层数据部分长度的要求是 46bytes ~ 1500bytes MSS : 最大报文段长度   一般 MSS 为 MTU 减去 IP 首部长度 20 字节和 TCP 首部长度 20 字节，1500-40-40=1460 。但是许多 BSD 实现 版本需要 MSS 为 512 的倍数，所以一般 MSS 都是 1024。当建立一个 TCP 连接时，每一方都通告其期望的 MSS 选项（MSS 选项只能出现在 SYN 报文段中），最终选择两者中的较小者作为 MSS，是一个协商选项。 TCP 报文段的分段与重组是在运输层完成的。 不希望 IP 分片的原因   对于 IP 分片的数据报，即使丢失一片数据，也要重传整个数据报。因为 IP 层没有重传机制，没有办法只重传某 一片。所以即使 IP 分片过程看起来是透明的，但人们仍然不想用它。所以 TCP 总是避免分片，通过设置 MSS 使 得以太网帧长度不超过 MTU TCP、UDP 与 IP 分片   UDP 很容易导致分片； TCP 试图避免分片，应用程序几乎不可能强迫 TCP 发送一个需要分片的报文。 CSMA/CD   CSMA/CD是Carrier Sense Multiple Access with Collision Detection 的缩写， 可译为“载波侦听多路访问/冲突检测”，或“带有冲突检测的载波侦听多路访问”。 所谓载波侦听（carrier sense），意思是网络上各个工作站在发送数据前都要侦听总线上有没有数据传输。 若有数据传输 （称总线为忙），则不发送数据；若无数据传输（称总线为空），立即发送准备好的数据。 所谓多路访问（multiple access)意思是网络上所有工作站收发数据共同使用同一条总线，且发送数据是广播式的。 所谓冲突（collision），意思是，若网上有两个或两个以上工作站同时发送数据，在总线上就会产生信号的混合， 两个工作站都同时发送数据，在总线上就会产生信号的混合，两个工作站都辨别不出真正的数据是什么。 这种情况称数据冲突又称碰撞。为了减少冲突发生后的影响。工作站在发送数据过程中还要不停地检测自己发送的 数据，有没有在传输过程中与其它工作站的数据发生冲突，这就是冲突检测（collision detected）。    IPG(Inter-Packet Gap) Preamble Start Frame Delimiter DMAC SMAC Type Data Frame check Sequence   12Bytes 7Bytes 1Bytes 6Bytes 6Bytes 1Byte 48~1500Bytes 4Bytes    AA (01010101) AB (01010011)        帧间隙 前导码 前导码-帧界定符          CSMA/CD媒体访问控制方法的工作原理，可以概括如下： 先听后说，边听边说； 一旦冲突，立即停说； 等待时机，然后再说； 注：“听”，即监听、检测之意；“说”，即发送数据之意。 CSMA/CD网络上进行传输时，必须按下列五个步骤来进行 （1）传输前监听 （2）如果忙则等待 （3）如果空闲则传输并检测冲突 （4）如果冲突发生，重传前等待 （5）重传或夭折 主要参数： 时间片 51 2比特时间 帧间间隔 9．6 微秒 尝试极限 16 退避极限 10 人为干扰长 32 比特 最大帧长 1518 字节 最小帧长 64 字节 地址字段长 48 比特 二进制指数退避算法 1）确定基本退避时间（基数），一般定为2τ，也就是一个争用期时间，对于以太网就是51.2μs 2）定义一个参数K，为重传次数，K＝min[重传次数，10]，可见K≤10 3）从离散型整数集合[0，1，2，……，(2^k－1)]中，随机取出一个数记做R 那么重传所需要的退避时间为R倍的基本退避时间：即：T＝R×2τ。 4）同时，重传也不是无休止的进行，当重传16次不成功，就丢弃该帧，传输失败，报告给高层协议 TIME_WAIT 状态  TCP 建立连接   将 TCP 连接比作一个电话系统： socket 函数表示拿到一个电话； bind 函数告诉别人你的电话号码，这样对方才可以呼叫你； listen 函数打开电话的振铃，有来电的时候可以听到； accept 函数应答电话，同时返回呼叫者的电话号码(IP、Port)。且只在建立连接之后才能返回。 getaddrinfo 在电话簿上查询某人的电话号码。（DNS 查询），getnameinfo 电话簿按照电话号码排序 TCP 状态转换图   TCP 建立连接和连接终止的操作可以用状态转换图（state transition diagram）来表示。 TCP 为一个连接定义了 11 中状态，且规定如何基于当前状态以及在该状态下所接收的分节来确定下一个状态。 TIME_WAIT   TIME_WAIT 的时间是 2MSL （maximum segment lifetime） ，也就是肯定会在这个状态等待这么长时间。 TCP 不给处于 TIME_WAIT 状态的连接建立新连接。保证每建立一个新 TCP 连接，来自该连接先前化身的老的重复 分组都已在网络中消逝了。 存在理由     可靠的实现 TCP 全双工连接的终止；    迟到的报文被丢弃。   ","wordCount":"278","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"kyle Three Stone"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kylestones.github.io/hugo-blog/blog/apue/unp/"},"publisher":{"@type":"Organization","name":"Org Mode","logo":{"@type":"ImageObject","url":"https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://kylestones.github.io/hugo-blog accesskey=h title="Home (Alt + H)"><img src=https://kylestones.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kylestones.github.io/hugo-blog/categories/ title=categories><span>categories</span></a></li><li><a href=https://kylestones.github.io/hugo-blog/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kylestones.github.io/hugo-blog>Home</a></div><h1 class=post-title>Unix Network Programming</h1><div class=post-meta>2 min&nbsp;·&nbsp;278 words&nbsp;·&nbsp;kyle Three Stone&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/blog/apue/unp.org rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=headline-1>问题</h3><h4 id=headline-2>程序异常终止</h4><p>此时所有打开的文件描述符将被关闭，TCP 连接发送一个 FIN 。然后呢？对端的确认报文是否收到无所谓？
对端发送 FIN 报文，此时已经终止？无法恢复确认报文？对端会重复发送？</p><h3 id=headline-3>IP 分片(fragment) – TCP 分段</h3><h4 id=headline-4>MTU : 最大传输单元</h4><p>链路层对网络数据帧的一个限制：以太网限制 MTU 为 1500 字节。
尽管 IP 报文头中有 16 位表示数据报的长度（最大长度 2^16-1=65535）
IP 报文的长度超过 MTU 就需要分片，IP 数据报的分片与重组都是在网络层完成的。
IP 头有 3 个标志位，一个标志位保留；一个标志位 DF 表示是否允许分片，为 0 表示允许分片，为 1 表示禁止
分片，当报文长度大于 MTU 则丢弃该报文，并向源主机发送 ICMP 报文；一个标志位 MF 表示之后是否还有分片
片偏移用于确定该片偏移原始数据报开始处的位置。
16 位标识用于确定相应的片是否属于同一个 IP 报文。
每个以太帧长度在 64 bytes ~ 1518 bytes，减去以太网帧头（DMAC 48bits=6Bytes + SMAC 48bits=6Bytes +
Type 2Bytes + CRC 4Bytes）最大只能有 1500 bytes。链路层数据部分长度的要求是 46bytes ~ 1500bytes</p><h4 id=headline-5>MSS : 最大报文段长度</h4><p>一般 MSS 为 MTU 减去 IP 首部长度 20 字节和 TCP 首部长度 20 字节，1500-40-40=1460 。但是许多 BSD 实现
版本需要 MSS 为 512 的倍数，所以一般 MSS 都是 1024。当建立一个 TCP 连接时，每一方都通告其期望的 MSS
选项（MSS 选项只能出现在 SYN 报文段中），最终选择两者中的较小者作为 MSS，是一个协商选项。
TCP 报文段的分段与重组是在运输层完成的。</p><h4 id=headline-6>不希望 IP 分片的原因</h4><p>对于 IP 分片的数据报，即使丢失一片数据，也要重传整个数据报。因为 IP 层没有重传机制，没有办法只重传某
一片。所以即使 IP 分片过程看起来是透明的，但人们仍然不想用它。所以 TCP 总是避免分片，通过设置 MSS 使
得以太网帧长度不超过 MTU</p><h4 id=headline-7>TCP、UDP 与 IP 分片</h4><p>UDP 很容易导致分片；
TCP 试图避免分片，应用程序几乎不可能强迫 TCP 发送一个需要分片的报文。</p><h4 id=headline-8>CSMA/CD</h4><p>CSMA/CD是Carrier Sense Multiple Access with Collision Detection 的缩写，
可译为“载波侦听多路访问/冲突检测”，或“带有冲突检测的载波侦听多路访问”。
所谓载波侦听（carrier sense），意思是网络上各个工作站在发送数据前都要侦听总线上有没有数据传输。
若有数据传输 （称总线为忙），则不发送数据；若无数据传输（称总线为空），立即发送准备好的数据。
所谓多路访问（multiple access)意思是网络上所有工作站收发数据共同使用同一条总线，且发送数据是广播式的。
所谓冲突（collision），意思是，若网上有两个或两个以上工作站同时发送数据，在总线上就会产生信号的混合，
两个工作站都同时发送数据，在总线上就会产生信号的混合，两个工作站都辨别不出真正的数据是什么。
这种情况称数据冲突又称碰撞。为了减少冲突发生后的影响。工作站在发送数据过程中还要不停地检测自己发送的
数据，有没有在传输过程中与其它工作站的数据发生冲突，这就是冲突检测（collision detected）。</p><table><tbody><tr><td>IPG(Inter-Packet Gap)</td><td>Preamble</td><td>Start Frame Delimiter</td><td>DMAC</td><td>SMAC</td><td>Type</td><td>Data</td><td>Frame check Sequence</td></tr><tr><td>12Bytes</td><td>7Bytes</td><td>1Bytes</td><td>6Bytes</td><td>6Bytes</td><td>1Byte</td><td>48~1500Bytes</td><td>4Bytes</td></tr><tr><td></td><td>AA (01010101)</td><td>AB (01010011)</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>帧间隙</td><td>前导码</td><td>前导码-帧界定符</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>CSMA/CD媒体访问控制方法的工作原理，可以概括如下：
先听后说，边听边说；
一旦冲突，立即停说；
等待时机，然后再说；
注：“听”，即监听、检测之意；“说”，即发送数据之意。
CSMA/CD网络上进行传输时，必须按下列五个步骤来进行
（1）传输前监听
（2）如果忙则等待
（3）如果空闲则传输并检测冲突
（4）如果冲突发生，重传前等待
（5）重传或夭折
主要参数：
时间片 51 2比特时间
帧间间隔 9．6 微秒
尝试极限 16
退避极限 10
人为干扰长 32 比特
最大帧长 1518 字节
最小帧长 64 字节
地址字段长 48 比特
二进制指数退避算法
1）确定基本退避时间（基数），一般定为2τ，也就是一个争用期时间，对于以太网就是51.2μs
2）定义一个参数K，为重传次数，K＝min[重传次数，10]，可见K≤10
3）从离散型整数集合[0，1，2，……，(2^k－1)]中，随机取出一个数记做R
那么重传所需要的退避时间为R倍的基本退避时间：即：T＝R×2τ。
4）同时，重传也不是无休止的进行，当重传16次不成功，就丢弃该帧，传输失败，报告给高层协议</p><h3 id=headline-9>TIME_WAIT 状态</h3><h3 id=headline-10>TCP 建立连接</h3><p>将 TCP 连接比作一个电话系统：
socket 函数表示拿到一个电话；
bind 函数告诉别人你的电话号码，这样对方才可以呼叫你；
listen 函数打开电话的振铃，有来电的时候可以听到；
accept 函数应答电话，同时返回呼叫者的电话号码(IP、Port)。且只在建立连接之后才能返回。
getaddrinfo 在电话簿上查询某人的电话号码。（DNS 查询），getnameinfo 电话簿按照电话号码排序</p><h3 id=headline-11>TCP 状态转换图</h3><p>TCP 建立连接和连接终止的操作可以用状态转换图（state transition diagram）来表示。
TCP 为一个连接定义了 11 中状态，且规定如何基于当前状态以及在该状态下所接收的分节来确定下一个状态。</p><h4 id=headline-12>TIME_WAIT</h4><p>TIME_WAIT 的时间是 2MSL （maximum segment lifetime） ，也就是肯定会在这个状态等待这么长时间。
TCP 不给处于 TIME_WAIT 状态的连接建立新连接。保证每建立一个新 TCP 连接，来自该连接先前化身的老的重复
分组都已在网络中消逝了。</p><h5 id=headline-13>存在理由</h5><ol><li><p>可靠的实现 TCP 全双工连接的终止；</p></li><li><p>迟到的报文被丢弃。</p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://kylestones.github.io/hugo-blog/tags/linux/>Linux,</a></li><li><a href=https://kylestones.github.io/hugo-blog/tags/network/>Network</a></li></ul><nav class=paginav><a class=prev href=https://kylestones.github.io/hugo-blog/blog/machinelearning/gpu-mxnet-install/><span class=title>« Prev</span><br><span>ubuntu18.04 install gpu mxnet</span></a>
<a class=next href=https://kylestones.github.io/hugo-blog/blog/machinelearning/vgg-googlenet-resnet/><span class=title>Next »</span><br><span>VGG GoogLeNet ResNet</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Unix Network Programming on twitter" href="https://twitter.com/intent/tweet/?text=Unix%20Network%20Programming&url=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fapue%2funp%2f&hashtags=Linux%2c%2cNetwork"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unix Network Programming on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fapue%2funp%2f&title=Unix%20Network%20Programming&summary=Unix%20Network%20Programming&source=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fapue%2funp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unix Network Programming on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fapue%2funp%2f&title=Unix%20Network%20Programming"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unix Network Programming on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fapue%2funp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unix Network Programming on whatsapp" href="https://api.whatsapp.com/send?text=Unix%20Network%20Programming%20-%20https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fapue%2funp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unix Network Programming on telegram" href="https://telegram.me/share/url?text=Unix%20Network%20Programming&url=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fapue%2funp%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z" /></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://kylestones.github.io/hugo-blog>Org Mode</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z" /></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>