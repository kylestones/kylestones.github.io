<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>YOLO 实现细节 | Org Mode</title><meta name=keywords content="目标检测,,深度学习"><meta name=description content="之前写的乱七八糟，现在开始重构，主要针对 YOLOv3。真的是得亲自动手实现，才能真正了解一个算法。The best way to go about learning object detection is to implement the algorithms by yourself, from scratch. – Ayoosh Kathuria 主网络   主网络采用 Darknet53 ，网络为全卷积网络 FCN(Fully Convolutional Networks)，之前一直以为全卷积网络就是不包含全连接的网络， 现在才知道，全卷积网络连 Pooling 层都没有，Pooling 层使用步长为 2 的卷积代替，防止由于 Pooling 导致 low-level features 的丢失；分类之前使用 Global Average Pooling 。[Darknet53 中有全连接层呀，上面写错了] 卷积层   Darknet 的每个卷积层都是由 Conv-BN-LReLU 组成，是网络的最小重复单元。 def cbl_gen(channels, kernel_size, strides, padding): '''conv-BN-LeakyReLU cell''' cbl_unit = nn.HybridSequential() # 所有卷积后面都有 BN ，所以 bias 始终为 False cbl_unit."><meta name=author content="Kyle Three Stones"><link rel=canonical href=https://kylestones.github.io/hugo-blog/blog/machinelearning/yolo/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/hugo-blog/assets/css/stylesheet.abc7c82c3d415a6df50430738d1cbcc4c76fea558bc5a0c830d3babf78167a35.css integrity="sha256-q8fILD1BWm31BDBzjRy8xMdv6lWLxaDIMNO6v3gWejU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/hugo-blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad();></script><link rel=icon href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme: rgb(29, 30, 32);--entry: rgb(46, 46, 51);--primary: rgb(218, 218, 219);--secondary: rgb(155, 156, 157);--tertiary: rgb(65, 66, 68);--content: rgb(196, 196, 197);--hljs-bg: rgb(46, 46, 51);--code-bg: rgb(55, 56, 62);--border: rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-123-45','auto');ga('send','pageview');}</script><meta property="og:title" content="YOLO 实现细节"><meta property="og:description" content="之前写的乱七八糟，现在开始重构，主要针对 YOLOv3。真的是得亲自动手实现，才能真正了解一个算法。The best way to go about learning object detection is to implement the algorithms by yourself, from scratch. – Ayoosh Kathuria 主网络   主网络采用 Darknet53 ，网络为全卷积网络 FCN(Fully Convolutional Networks)，之前一直以为全卷积网络就是不包含全连接的网络， 现在才知道，全卷积网络连 Pooling 层都没有，Pooling 层使用步长为 2 的卷积代替，防止由于 Pooling 导致 low-level features 的丢失；分类之前使用 Global Average Pooling 。[Darknet53 中有全连接层呀，上面写错了] 卷积层   Darknet 的每个卷积层都是由 Conv-BN-LReLU 组成，是网络的最小重复单元。 def cbl_gen(channels, kernel_size, strides, padding): '''conv-BN-LeakyReLU cell''' cbl_unit = nn.HybridSequential() # 所有卷积后面都有 BN ，所以 bias 始终为 False cbl_unit."><meta property="og:type" content="article"><meta property="og:url" content="https://kylestones.github.io/hugo-blog/blog/machinelearning/yolo/"><meta property="og:image" content="https://kylestones.github.io/hugo-blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kylestones.github.io/hugo-blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="YOLO 实现细节"><meta name=twitter:description content="之前写的乱七八糟，现在开始重构，主要针对 YOLOv3。真的是得亲自动手实现，才能真正了解一个算法。The best way to go about learning object detection is to implement the algorithms by yourself, from scratch. – Ayoosh Kathuria 主网络   主网络采用 Darknet53 ，网络为全卷积网络 FCN(Fully Convolutional Networks)，之前一直以为全卷积网络就是不包含全连接的网络， 现在才知道，全卷积网络连 Pooling 层都没有，Pooling 层使用步长为 2 的卷积代替，防止由于 Pooling 导致 low-level features 的丢失；分类之前使用 Global Average Pooling 。[Darknet53 中有全连接层呀，上面写错了] 卷积层   Darknet 的每个卷积层都是由 Conv-BN-LReLU 组成，是网络的最小重复单元。 def cbl_gen(channels, kernel_size, strides, padding): '''conv-BN-LeakyReLU cell''' cbl_unit = nn.HybridSequential() # 所有卷积后面都有 BN ，所以 bias 始终为 False cbl_unit."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":3,"name":"YOLO 实现细节","item":"https://kylestones.github.io/hugo-blog/blog/machinelearning/yolo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"YOLO 实现细节","name":"YOLO 实现细节","description":"之前写的乱七八糟，现在开始重构，主要针对 YOLOv3。真的是得亲自动手实现，才能真正了解一个算法。The best way to go about learning object detection is to implement the algorithms by yourself, from scratch. – Ayoosh Kathuria 主网络   主网络采用 Darknet53 ，网络为全卷积网络 FCN(Fully Convolutional Networks)，之前一直以为全卷积网络就是不包含全连接的网络， 现在才知道，全卷积网络连 Pooling 层都没有，Pooling 层使用步长为 2 的卷积代替，防止由于 Pooling 导致 low-level features 的丢失；分类之前使用 Global Average Pooling 。[Darknet53 中有全连接层呀，上面写错了] 卷积层   Darknet 的每个卷积层都是由 Conv-BN-LReLU 组成，是网络的最小重复单元。 def cbl_gen(channels, kernel_size, strides, padding): \u0026#39;\u0026#39;\u0026#39;conv-BN-LeakyReLU cell\u0026#39;\u0026#39;\u0026#39; cbl_unit = nn.HybridSequential() # 所有卷积后面都有 BN ，所以 bias 始终为 False cbl_unit.","keywords":["目标检测,","深度学习"],"articleBody":"  之前写的乱七八糟，现在开始重构，主要针对 YOLOv3。真的是得亲自动手实现，才能真正了解一个算法。The best way to go about learning object detection is to implement the algorithms by yourself, from scratch. – Ayoosh Kathuria 主网络   主网络采用 Darknet53 ，网络为全卷积网络 FCN(Fully Convolutional Networks)，之前一直以为全卷积网络就是不包含全连接的网络， 现在才知道，全卷积网络连 Pooling 层都没有，Pooling 层使用步长为 2 的卷积代替，防止由于 Pooling 导致 low-level features 的丢失；分类之前使用 Global Average Pooling 。[Darknet53 中有全连接层呀，上面写错了] 卷积层   Darknet 的每个卷积层都是由 Conv-BN-LReLU 组成，是网络的最小重复单元。 def cbl_gen(channels, kernel_size, strides, padding): '''conv-BN-LeakyReLU cell''' cbl_unit = nn.HybridSequential() # 所有卷积后面都有 BN ，所以 bias 始终为 False cbl_unit.add( nn.Conv2D(channels, kernel_size=kernel_size, strides=strides, padding=padding, groups=1, use_bias=False), nn.BatchNorm(), nn.LeakyReLU(0.1) ) return cbl_unit  残差单元   Darknet53 使用了残差结构，不过作者对残差单元进行了改良，与 resnet 论文中两种残差单元 (3x3 + 3x3 or 1x1 + 3x3 + 1x1) 都不 太一样。每个基本的残差单元都由一个 1x1 + 3x3 卷积实现，且 3x3 卷积 channel 的个数固定是 1x1 卷积 channel 个数的两倍。 # 残差网络需要重新定义前向传播的方式，必须自己定义网络层类 class DarknetBasicBlockV3(gluon.HybridBlock): '''darknetV3 basic block''' def __init__(self, channels, **kwargs): super(DarknetBasicBlockV3, self).__init__(**kwargs) self.body = nn.HybridSequential() self.body.add( # 1x1 conv cbl_gen(channels, (1,1), (1,1), (0,0)), # 3x3 conv cbl_gen(channels*2, (3,3), (1,1), (1,1)) ) # 需要在 hybrid_forward 函数中添加额外的输入F。由于 MXNet 既有基于命令式编程的 NDArray 类， # 又有基于符号式编程的 Symbol 类。由于这两个类的函数基本一致，MXNet会根据输入来决定 F 使用 NDArray 或 Symbol。  def hybrid_forward(self, F, x): return x + self.body(x)  Darknet53   Darknet53 共由 5 个残差块组成，每个残差块重复的次数分别是 1,2,8,8,4 ，相应的通道数分别为 32,64,128,256,512 。且每个残差 块之前都有一个步长为 2 的卷积实现下采样操作。  由于每个残差单元由两层卷积实现，那么所有残差块共包含网络的层数为(1+2+8+8+4)*2=46 层，再加上每个残差块前面的一个下采样层， 也就是残差块的个数 5 ，这样就有了 46+5=51 层。最后加上最开始的一个卷积层，以及全连接层，总共有 53 层，也就是网络称为 Darknet53 的原因。 # 残差块的个数 residual_block_num = [1, 2, 8, 8, 4] # 对应残差块 1x1 卷积输出 channel 个数，3x3 卷积输出 channel 个数翻倍 darknet_channels = [32, [32, 64, 128, 256, 512]] class_num_imagenet = 1000 # for imagenet class Darknet53(gluon.HybridBlock): '''darknet53''' def __init__(self, residual_block_num, channels, class_num=1000, **kwargs): super(Darknet53, self).__init__(**kwargs) self.features = nn.HybridSequential() # 网络最开始有一个卷积操作 self.features.add(cbl_gen(channels[0], (3,3), (1,1), (1,1))) # 重复的残差块 for residual_block, channel in zip(residual_block_num, channels[1]): # 使用步长为 2 的卷积实现下采样，在每一个残差块的开始都有一个下采样层 self.features.add(cbl_gen(channel*2, (3,3), (2,2), (1,1))) # 一个残差块 for _ in range(residual_block): self.features.add(DarknetBasicBlockV3(channel)) # global average pooling self.pooling = nn.GlobalAvgPool2D() # 全连接的输出层 self.output = nn.Dense(class_num) def hybrid_forward(self, F, x): x = self.features(x) x = self.pooling(x) return self.output(x)  检测网络  predictions across scales   Fine-Grained Feature    将靠近输出的检测层的 feature maps upsample 2X ，然后与网络前面层中相同大小的 feature maps 串接（作为不同的 channel 组 合），作为中间检测层的输入；将中间检测层同样操作作为靠近输入层检测层的输入。    本层 feature maps 有较好的语义信息，前面层 feature maps 有较好的位置信息，这里将两者进行了结合。    提升检测小物体效果明显    YOLOv3 在主网络的不同 stage 共使用三个检测网络，除了通道个数不同外，每个检测网络的结构都是相同的。每个检测网络都是由一个 1x1+3x3 卷积重复 3 次构成，且 3x3 卷积的通道数是 1x1 卷积通道数的 2 倍。所以每个检测网络都是 6 层卷积，加上最后一个输出 层卷积构成。  效仿 FPN(Feature Pyramid Net) ，靠近输出层的检测网络输出会同时作为前面监测网络的输入（ 6 个卷积层中倒数第二个卷积层的输 出作为前面一个 stage 的检测网络的输入），所有检测网络不能使用一个 3 次循环实现，必须分开。 # 三个输出分别使用的检测通道数 det_channels = [512, 256, 128] class Detection(gluon.HybridBlock): ''' 检测网络，三个检测网络的结构相同，只是 filter 个数不同，完全可以使用一个 for 循环实现， 但是需要在倒数第二层引出分支，和前面层的特征合并后，用于前面的检测网络，所以只能分开写 越靠近输入层， feature maps 越大，所以检测网络使用的 channel 相应的较少，防止较大运算量 ''' def __init__(self, channels, classes_num=80, anchors_num=3, **kwargs): super(Detection, self).__init__(**kwargs) self.channels=channels self.anchors_num=anchors_num self.pred_num=1+4+classes_num self.body=nn.HybridSequential(prefix='') self.tip=nn.HybridSequential(prefix='') for i in range(2): self.body.add(cbl_gen(channels, (1,1), (1,1), (0,0))) self.body.add(cbl_gen(channels*2, (3,3), (1,1), (1,1))) self.body.add(cbl_gen(channels, (1,1), (1,1), (0,0))) self.tip.add(cbl_gen(channels*2, (3,3), (1,1), (1,1))) def hybrid_forward(self, F, x): x = self.body(x) return self.tip(x)  串接层   将靠近输出的检测网络结果输入到前面的检测网络时，会先经过一个 1x1 卷积，同时由于 feature maps size 不同，所以会进行上采样， 之后才会和主网络的输出作为不同的通道堆叠后作为检测网络的输入。 class Concates(gluon.HybridBlock): \"\"\"不同 stage 的 feature maps 串接的时候，先经过了一个 1x1 卷积和一个上采样 \"\"\" def __init__(self, channels, **kwargs): super(Concates, self).__init__(*kwargs) self.concate = nn.HybridSequential(prefix='') self.concate.add(cbl_gen(channels, (1,1), (1,1), (0,0))) def upsample_rept(self, x, stride): ''' 不同的检测层输入堆叠的时候需要上采样，上采样的方式也很简单， 只是将 feature maps 沿着水平和垂直方向 repeat 指定的倍数。 ''' assert type(x) == mx.ndarray.ndarray.NDArray or type(x) == np.ndarray return x.repeat(axis=-1, repeats=stride).repeat(axis=-2, repeats=stride) def hybrid_forward(self, F, x): x = self.concate(x) x = self.upsample_rept(x, 2) return x  输出层     YOLO 的输出是 feature maps ，使用 1x1 卷积得到最终的输出；每一个节点都输出固定数量的 Bbox    每个检测网络的输出都是用 3 个 anchor ，每个 anchor 包含 1 个 obj 表示是否包含目标，4 个坐标值，以及 class 类别（使用 coco 就是 80 个类别，使用 VOC 就是 20 个类别），这里以 coco 为例。所以输出的通道数为 3*(1+4+80)=255 。通道的排序顺序可以 按照你的喜好随意排序，不过一般都是 3 个 anchor 依序排列，每个 anchor 内分别是 box-center,box-scale,objness,class ，class 采用 one-hot 形式，就是 [{x,y,w,h,obj,class-one-hot},{x,y,w,h,obj,class-one-hot},{x,y,w,h,obj,class-one-hot}] 。  感觉输出层其实很简单，只有一层卷积，但是由于 anchor 以及网络输出与真实值之间需要转换，同时训练和预测时输出的不一致， output 整的很麻烦。 输出坐标   直接训练网络预测物体的宽和高，会使得网络不稳定。因此检测算法会使用对数空间或者预测 Bbox 相对于 anchor 的 offset 。YOLOv3 feature maps 的每个节点都使用 3 个不同大小的 anchor ，每个 anchor 都可能预测不同的物体。  \\begin{align*} b_x \u0026= σ(t_x) + c_x b_y \u0026= σ(t_y) + c_y b_w \u0026= p_w et_w b_h \u0026= p_h et_h \\end{align*}  其中 \\(b_x,b_y,b_w,b_h\\) 分别是预测的物体的实际中心点坐标，以及宽和高。 \\(t_x,t_y,t_w,t_h\\) 是网络的输出值。 \\(c_x,c_y\\) 是该 grid cell 左上角坐标， \\(p_w,p_h\\) 是 anchor 的宽和高。    通过 sigmoid 函数确保中心点的相对坐标值在 0-1 之间，相对于该 grid cell 左上角。使用指数函数确保宽和高非负。    \\(b_w,b_h\\) 用图片的宽和高进行了归一化，且使用对数空间计算。即物体实际的大小应该是 \\(b_w,b_h\\) 分别乘以图像的宽度和高 度   # darknet 源码中对 VOC 标签做转换 def convert(size, box): // 中心点、宽、高等都是将图片转换成 1x1 后的相对坐标  dw = 1./(size[0]) dh = 1./(size[1]) // 开始一直不明白为什么最后要减 1 ；  // 其实就是将从 1 开始计数转换成从 0 开始；笨呐  x = (box[0] + box[1])/2.0 - 1 y = (box[2] + box[3])/2.0 - 1 w = box[1] - box[0] h = box[3] - box[2] x = x*dw w = w*dw y = y*dh h = h*dh return (x,y,w,h)  class prediction     作者使用相互独立的 logistic classifier    训练时使用 binary cross-entropy loss    并不一定要使用 softmax 分类才能达到较好的效果    softmax 假定各个类别相互独立，不利于扩展到有重叠的类别    最终输出的预测概率是 objness*class   输出层代码  class Output(gluon.HybridBlock): \"\"\"YOLOv3 输出 \"\"\" def __init__(self, anchors, stride, classes_num=80, **kwargs): super(Output, self).__init__(**kwargs) self.stride = stride self.anchors_num = len(anchors) // 2 self.classes_num = classes_num self.pred_num = 1+4+classes_num anchors = nd.array(anchors).astype('float32') self.anchors = anchors.reshape(1, 1, -1, 2) self.output = nn.HybridSequential(prefix='') # 这里是线性激活函数，默认 nn.Conv2D 的 activation=None，两者等效 # 输出 channel 的个数 (4+1+classes)*anchors self.output.add(nn.Conv2D(self.pred_num*self.anchors_num, (1,1), (1,1), (0,0), groups=1, use_bias=True)) # offsets will be added to predictions grid_x = np.arange(128) grid_y = np.arange(128) grid_x, grid_y = np.meshgrid(grid_x, grid_y) # stack to (n, n, 2) offsets = np.concatenate((grid_x[:, :, np.newaxis], grid_y[:, :, np.newaxis]), axis=-1) # expand dims to (1, 1, n, n, 2) so it's easier for broadcasting offsets = np.expand_dims(np.expand_dims(offsets, axis=0), axis=0) self.offsets = nd.array(offsets)#self.params.get_constant('offset_%d'%(index), offsets) def hybrid_forward(self, F, x): pred = self.output(x) # prediction flat to (batch, pred per pixel, height * width) pred = pred.reshape((0, self.anchors_num * self.pred_num, -1)) # transpose to (batch, height * width, num_anchor, num_pred) pred = pred.transpose(axes=(0, 2, 1)).reshape((0, -1, self.anchors_num, self.pred_num)) # components raw_box_centers = pred.slice_axis(axis=-1, begin=0, end=2) raw_box_scales = pred.slice_axis(axis=-1, begin=2, end=4) objness = pred.slice_axis(axis=-1, begin=4, end=5) class_pred = pred.slice_axis(axis=-1, begin=5, end=None) # valid offsets, (1, 1, height, width, 2) offsets = nd.slice_like(self.offsets, x * 0, axes=(2, 3)) # reshape to (1, height*width, 1, 2) offsets = offsets.reshape((1, -1, 1, 2)) box_centers = nd.broadcast_add(nd.sigmoid(raw_box_centers), offsets) * self.stride box_scales = nd.broadcast_mul(nd.exp(raw_box_scales), self.anchors) confidence = nd.sigmoid(objness) class_score = nd.broadcast_mul(nd.sigmoid(class_pred), confidence) wh = box_scales / 2.0 # `corner`: [xmin, ymin, xmax, ymax] # `center`: [x, y, width, height] # center to corner bbox = nd.concat(box_centers - wh, box_centers + wh, dim=-1) if autograd.is_training(): # during training, we don't need to convert whole bunch of info to detection results return (bbox.reshape((0, -1, 4)), raw_box_centers, raw_box_scales, objness, class_pred, self.anchors, offsets) # prediction per class bboxes = nd.tile(bbox, reps=(self.classes_num, 1, 1, 1, 1)) scores = nd.transpose(class_score, axes=(3, 0, 1, 2)).expand_dims(axis=-1) ids = nd.broadcast_add(scores * 0, F.arange(0, self.classes_num).reshape((0, 1, 1, 1, 1))) detections = nd.concat(ids, scores, bboxes, dim=-1) # reshape to (B, xx, 6) detections = nd.reshape(detections.transpose(axes=(1, 0, 2, 3, 4)), (0, -1, 6)) return detections  YOLOv3   将主网络与检测网络以及输出拼装起来，就组成了 YOLOv3 。最开始看到 YOLOv3 网络的时候，感觉很网络很复杂，感觉无从下手来写网 络结构。可是将主网络和检测网络拆分开，忽然又变得很容易。 # 这里都进行了反序 strides = [32, 16, 8] anchors = [[116, 90, 156, 198, 373, 326], [30, 61, 62, 45, 59, 119], [10, 13, 16, 30, 33, 23]] class YOLOv3(gluon.HybridBlock): \"\"\"生成 YOLOv3 网络，只适用于 Darknet53 ， \"\"\" def __init__(self, **kwargs): super(YOLOv3, self).__init__(**kwargs) # 基本网络框架 darknet53 = Darknet53(residual_block_num, darknet_channels) # residual_block_num = [1, 2, 8, 8, 4] , 每一个残差块的开始都有一个下采样层 feature1_layer = 1 + (1+1) + (1+2) + (1+8) feature2_layer = feature1_layer + (1+8) feature3_layer = feature2_layer + (1+4) # 可以直接到末尾， self.features = nn.HybridSequential(prefix='') self.features.add(darknet53.features[:feature1_layer]) self.features.add(darknet53.features[feature1_layer:feature2_layer]) self.features.add(darknet53.features[feature2_layer:feature3_layer]) # 从基本网络框架引出的检测网络层，包含输出 self.detection_net = nn.HybridSequential(prefix='') for det_channel in det_channels: self.detection_net.add(Detection(det_channel)) # 串接不同 stage  self.concates = nn.HybridSequential(prefix='') for det_channel in det_channels[1:]: self.concates.add(Concates(det_channel)) # 输出 self.output = nn.HybridSequential(prefix='') for anchor, stride in zip(anchors, strides): self.output.add(Output(anchor, stride)) def hybrid_forward(self, F, x): # 先计算出所有 stage 的 features featuremaps = [] for net in self.features: x = net(x) featuremaps.append(x) # 反序 featuremaps = featuremaps[::-1] output = [] det = nd.array([]) for i in range(len(featuremaps)): if i == 0: det = featuremaps[i] else: det = self.concates[i-1](det) det = nd.concat(det, featuremaps[i], dim=1) det = self.detection_net[i].body(det) out = self.detection_net[i].tip(det) out = self.output[i](out) output.append(out) return output  anchor   目标应该对应哪个 anchor ？首先要将训练和预测区分开来。  一个 anchor 就是规定了一个 Bbox 的宽和高，需要使用两个整数表示，anchor 可以放在图像的任意位置。YOLOv3 共使用了 9 个 anchor (anchors = 116, 90, 156, 198, 373, 326], [30, 61, 62, 45, 59, 119], [10, 13, 16, 30, 33, 23) ，分别用在 3 个 检测网络中，也就是每个检测网络使用 3 个 anchor ，面积小的 anchor 会被分配到靠近输入的检测网络，因为这时候目标的位置信息 会相对准确，面积大的 anchor 被分配到靠近输出的网络（也就是哪个 anchor 在哪个检测网络是确定的）。三个检测网络分别在主网络 中不同大小的 feature maps 上面检测，也就意味着三个检测网络是在进行重复检测。    v3 共使用了 3 个 scale ，每个 scale 使用 3 个 anchor ，不同 scale 的 anchor 大小不同，共使用了 9 个 anchor    YOLOv3 每级使用了 3 个 anchor 输出，输出大小 {N*N*[3*(4+1+80)]}    越靠近输入层使用 anchor 的尺寸越小    训练时与物体 groundtruth Bbox IoU 最大的 anchor 用于预测该物体    如果一个 grid 内有多余 anchor 个数的物体，无法同时检测    如果两个或以上物体在同一个 grid 内且与同一个 anchor 有较大 IoU ，同样无法检测   怎样将输出与样本的标签对应  training   每个目标只需要一个 anchor 来检测，其余 8 个 anchor 都不会计算由于检测这个目标不准确而产生的误差。那么应该将这个目标分配 给哪一个 anchor 呢？计算目标和所有 9 个 anchor 的 IOU ，将目标分配给 IOU 最大的那个 anchor 。只有这个 anchor 的输出用于 计算目标的位置和类别误差。 prediction   预测的时候，所有的 anchor 统一对待，过滤掉预测概率低于一定阈值的输出，然后分类别进行 NMS 即可。 使用 anchor 后效果     YOLOv2 使用 anchor 之后，准确率下降了，因为不使用 anchor 时，仅输出 98 个 Bbox ，但是使用 anchor 之后输出了 1000 多个 Bbox ，分母变得太大了，所以 accuracy 下降了一些，伴随着 mAP 也下降了 69.5-69.2。但是 recall 从 81% 上升到 88% ，因为 输出的个数增多，所以检测出来的目标也增多了；原来一直没有搞懂原因   Loss   损失总共包括四部分，box-center, box-scale, objness, class 。分别将四者的预测值和真实值用于计算即可。好像有不同的权重。  YOLOv3 loss 除了 box 的宽和高使用 L1-loss 以外， objectness 、box 中心点坐标、class 误差均使用 SigmoidBinaryCrossEntropyLoss 求解。只有包含目标的 anchor 才会计算所有误差，不包含目标的 anchor 只计算 objness 误差 （不过 anchor 和 gtbbox 超过一定阈值的会被忽略，也就是这些节点不会有任何误差用于更新权重）。  注意，只有被分配了目标的 anchor 才需要计算位置和类别误差，否则只计算 obj-loss   obj-loss    sum of objectness logistic loss   center-loss    sum of box center logistic regression loss   scale-loss    sum of box scale l1 loss   cls-loss    sum of per class logistic loss   #sigmoid_ce = gluon.loss.SigmoidBinaryCrossEntropyLoss(from_sigmoid=False) #l1_loss = gluon.loss.L1Loss() def sigmoid_ce(pred, label): loss = nd.relu(pred) - pred * label + nd.Activation(-nd.abs(pred), act_type='softrelu') return nd.mean(loss, axis=0, exclude=True) def l1_loss(pred, label): loss = nd.abs(pred - label) return nd.mean(loss, axis=0, exclude=True)  loss 未删   YOLOv1 中由于 sum-squared error (SSE) 容易优化，作者选用其作为损失函数，又由于希望小物体相比大物体有较好的精度，作者将 Bbox 的宽和高进行了开方 （回答者电话咨询过作者） ，paper 上也有一些描述。 YOLOv3 中并没有对宽和高进行开方，YOLOv2 不清楚。 lambda is highest for coordinates in order to focus more on detection    objectness score – 表示 Bbox 中含有目标的概率。YOLOv1 和 YOLOv2 设置一致，但 YOLOv3 中做了修改 ；    每个 anchor 输出一个 objectness/confidence ，用于表明这个 anchor 中有物体的概率及预测的 Bbox 的准确度，使用公式 \\(Pr(Object)*IOU_{pred}^{truth}\\) 。但是在 YOLOv3 中， confidence score 等于 1 ，当 gtbox 和 anchor 有最大的 IOU 的时 候，否则为 0 ，网络的输出是 sigmoid(t_o) 。    同时每个 anchor 输出该 anchor 中有物体的条件下，其类别的条件概率 \\(Pr(Class_i|Object)\\)    测试的时候，将 confidence 和条件类别概率相乘作为每个类别的 confidence score \\(Pr(Class_i|Object) * Pr(Object) * IOU_{pred}^{truth} = Pr(Class_i) * IOU_{pred}^{truth}\\)    由于 grid 中背景数目较多，所以降低不包含物体的误差权重，否则会 overwhelming 权重    YOLOv3 使用 logistic regression 预测每个 Bbox 的 objectness score ；YOLOv3 计算使用了 sigmoid 函数确保输出的概率值在 0-1 之间；每个物体只分配给一个 Bbox prior ；当一个 Bbox prior [anchor] 和物体的 groundtruth有最大的 IOU 的时候值为 1 ；当 Bbox prior 没有对应物体时，只产生 objectness loss 没有 coordinate 和 class prediction loss ；当 Bbox prior 和 groundtruth 的 IOU 大于一定阈值（作者采用 0.5） ，但却并不是最大的 IOU 的时候，忽略其预测，参考 Ci 定义探讨 ，猜测： 这里是为了防止 objectness 难以训练，因为只给 IOU 最大的Bbox prior 设置值为 1， 其他的 Bbox prior 同样和物体的 groundtruth IOU 很大，却被赋值为 0 ，若这些 Bbox prior 的objectness score 作用于 loss ，可能导致 objectness score 难 以收敛；正如在 YOLOv1 和 YOLOv2 中，objectness score 被定义为 \\(Pr(Object)*IOU_{pred}^{truth}\\) ，作者应该就是想通过 IOU 来降低未被赋予物体的 Bbox 的损失比重，同时还乘以了一个小于 1 的系数。    参考：    YOLOv2 loss - stackexchange    YOLOv3 confidence-scores    YOLOv3 not best Iou but over some threshold   输入图片没有 resize 到统一的大小？     v1 中有全连接层，输入可定是固定大小的：使用 imagenet 预训练使用 224*224 ，去掉全连接层然后使用 448*448 训练检测分类网 络；所以最终需要的输入应该也是 448*448    YOLOv3 是一个 FCN ，对输入的大小不敏感    训练好像都只是在 resize short size   Dimension Clusters     YOLOv2 使用 k-means 算法，先找到目标 Bbox 的合理先验，然后用这些更合理的 anchor 作为先验，使得模型更容易学习    但是 Faster R-CNN 文中却指出，只使用 1:1,1:2,2:1 三种比例的 anchor 作为先验，并不去适应某一个具体的数据集，使得算法的 泛化能力更好。    最初感觉 YOLO 为了更好的拟合 VOC 或者 COCO ，可能最终测试泛化效果并不好。但是实际使用中，应该会针对某一类具体的目标， 使用这类目标的更合理的先验，从而可以提高准确率呀！    另外， YOLOv2 中画出了 VOC 和 COCO 聚类 Bbox 的形状，两者都是瘦高的矩形占多数。而这些数据集都是生活中的真实图片，所以 实际使用时，对于一般目标，其泛化能力不一定不好。   # https://github.com/AlexeyAB/darknet/blob/master/scripts/gen_anchors.py ''' Created on Feb 20, 2017 @author: jumabek ''' from os import listdir from os.path import isfile, join import argparse #import cv2 import numpy as np import sys import os import shutil import random import math width_in_cfg_file = 416. height_in_cfg_file = 416. def IOU(x,centroids): similarities = [] k = len(centroids) for centroid in centroids: c_w,c_h = centroid w,h = x if c_w=w and c_h=h: similarity = w*h/(c_w*c_h) elif c_w=w and c_hh: similarity = w*c_h/(w*h + (c_w-w)*c_h) elif c_ww and c_h=h: similarity = c_w*h/(w*h + c_w*(c_h-h)) else: #means both w,h are bigger than c_w and c_h respectively similarity = (c_w*c_h)/(w*h) similarities.append(similarity) # will become (k,) shape return np.array(similarities) def avg_IOU(X,centroids): n,d = X.shape sum = 0. for i in range(X.shape[0]): #note IOU() will return array which contains IoU for each centroid and X[i] // slightly ineffective, but I am too lazy sum+= max(IOU(X[i],centroids)) return sum/n def write_anchors_to_file(centroids,X,anchor_file): f = open(anchor_file,'w') anchors = centroids.copy() print(anchors.shape) for i in range(anchors.shape[0]): anchors[i][0]*=width_in_cfg_file/32. anchors[i][1]*=height_in_cfg_file/32. widths = anchors[:,0] sorted_indices = np.argsort(widths) print('Anchors = ', anchors[sorted_indices]) for i in sorted_indices[:-1]: f.write('%0.2f,%0.2f, '%(anchors[i,0],anchors[i,1])) #there should not be comma after last anchor, that's why f.write('%0.2f,%0.2f\\n'%(anchors[sorted_indices[-1:],0],anchors[sorted_indices[-1:],1])) f.write('%f\\n'%(avg_IOU(X,centroids))) print() def kmeans(X,centroids,eps,anchor_file): N = X.shape[0] iterations = 0 k,dim = centroids.shape prev_assignments = np.ones(N)*(-1) iter = 0 old_D = np.zeros((N,k)) while True: D = [] iter+=1 for i in range(N): d = 1 - IOU(X[i],centroids) D.append(d) D = np.array(D) # D.shape = (N,k) print(\"iter {}: dists = {}\".format(iter,np.sum(np.abs(old_D-D)))) #assign samples to centroids  assignments = np.argmin(D,axis=1) if (assignments == prev_assignments).all() : print(\"Centroids = \",centroids) write_anchors_to_file(centroids,X,anchor_file) return #calculate new centroids centroid_sums=np.zeros((k,dim),np.float) for i in range(N): centroid_sums[assignments[i]]+=X[i] for j in range(k): centroids[j] = centroid_sums[j]/(np.sum(assignments==j)) prev_assignments = assignments.copy() old_D = D.copy() def main(argv): parser = argparse.ArgumentParser() parser.add_argument('-filelist', default = '\\\\path\\\\to\\\\voc\\\\filelist\\\\train.txt', help='path to filelist\\n' ) parser.add_argument('-output_dir', default = 'generated_anchors/anchors', type = str, help='Output anchor directory\\n' ) parser.add_argument('-num_clusters', default = 0, type = int, help='number of clusters\\n' ) args = parser.parse_args() if not os.path.exists(args.output_dir): os.mkdir(args.output_dir) f = open(args.filelist) lines = [line.rstrip('\\n') for line in f.readlines()] annotation_dims = [] size = np.zeros((1,1,3)) for line in lines: #line = line.replace('images','labels') #line = line.replace('img1','labels') line = line.replace('JPEGImages','labels') line = line.replace('.jpg','.txt') line = line.replace('.png','.txt') print(line) f2 = open(line) for line in f2.readlines(): line = line.rstrip('\\n') w,h = line.split(' ')[3:] #print(w,h) annotation_dims.append(tuple(map(float,(w,h)))) annotation_dims = np.array(annotation_dims) eps = 0.005 if args.num_clusters == 0: for num_clusters in range(1,11): #we make 1 through 10 clusters  anchor_file = join( args.output_dir,'anchors%d.txt'%(num_clusters)) indices = [ random.randrange(annotation_dims.shape[0]) for i in range(num_clusters)] centroids = annotation_dims[indices] kmeans(annotation_dims,centroids,eps,anchor_file) print('centroids.shape', centroids.shape) else: anchor_file = join( args.output_dir,'anchors%d.txt'%(args.num_clusters)) indices = [ random.randrange(annotation_dims.shape[0]) for i in range(args.num_clusters)] centroids = annotation_dims[indices] kmeans(annotation_dims,centroids,eps,anchor_file) print('centroids.shape', centroids.shape) if __name__==\"__main__\": main(sys.argv)  YOLO9000   YOLO9000 和 MaskXRcnn 一样，利用类别较多的简单标注数据集，扩展类别较少的复杂标注训练数据集，  使用 focalloss 外加 YOLO9000 感觉都完美了，one-stage 有速度也有精度，还有众众多类别。然而 YOLOv3 上面作者明确表示尝试了 focalloss 但 dono't work 。 高层思考   Yolo 采用一个 CNN 网络来实现检测，是 one-stage 策略，其训练与预测都是 end-to-end，所以 Yolo 算法比较简洁且速度快。第二点 由于Yolo 是对整张图片做卷积，所以其在检测目标有更大的视野，它不容易对背景误判。  缺点：    YOLOv3 在 mAP0.5 及小目标 APS 上具有不错的结果,但随着 IOU 的增大,性能下降,说明 YOLOv3 不能很好地与 ground truth 切合 康行天下    召回率低   参考     mxnet 代码实现    yolo系列之yolo v3 【网络可视化对于网络结构理解的重要性】    How to implement a YOLOv3 【实现算法是理解算法的最好方法】    目标检测网络之 YOLOv3    未参考    YOLO v1,YOLO v2,YOLO9000算法总结与源码解析    YOLO v2的算法细节——以李沐的Gluon代码为例   ","wordCount":"2216","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Kyle Three Stones"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kylestones.github.io/hugo-blog/blog/machinelearning/yolo/"},"publisher":{"@type":"Organization","name":"Org Mode","logo":{"@type":"ImageObject","url":"https://kylestones.github.io/hugo-blog/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><div class=logo><a href=https://kylestones.github.io/hugo-blog accesskey=h title="Home (Alt + H)"><img src=https://kylestones.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kylestones.github.io/hugo-blog/categories/ title=categories><span>categories</span></a></li><li><a href=https://kylestones.github.io/hugo-blog/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kylestones.github.io/hugo-blog>Home</a></div><h1 class=post-title>YOLO 实现细节</h1><div class=post-meta>11 min&nbsp;·&nbsp;2216 words&nbsp;·&nbsp;Kyle Three Stones&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/blog/machinelearning/YOLO.org rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>之前写的乱七八糟，现在开始重构，主要针对 YOLOv3。真的是得亲自动手实现，才能真正了解一个算法。The best way to go about
learning object detection is to implement the algorithms by yourself, from scratch. – <a href=https://www.linkedin.com/in/ayoosh-kathuria-44a319132/>Ayoosh Kathuria</a></p><h3 id=headline-1>主网络</h3><p>主网络采用 Darknet53 ，网络为全卷积网络 FCN(Fully Convolutional Networks)，之前一直以为全卷积网络就是不包含全连接的网络，
现在才知道，全卷积网络连 Pooling 层都没有，Pooling 层使用步长为 2 的卷积代替，防止由于 Pooling 导致 low-level features
的丢失；分类之前使用 Global Average Pooling 。[Darknet53 中有全连接层呀，上面写错了]</p><h4 id=headline-2>卷积层</h4><p>Darknet 的每个卷积层都是由 Conv-BN-LReLU 组成，是网络的最小重复单元。</p><div class="src src-python"><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>cbl_gen</span><span class=p>(</span><span class=n>channels</span><span class=p>,</span> <span class=n>kernel_size</span><span class=p>,</span> <span class=n>strides</span><span class=p>,</span> <span class=n>padding</span><span class=p>):</span>
    <span class=s1>&#39;&#39;&#39;conv-BN-LeakyReLU cell&#39;&#39;&#39;</span>
    <span class=n>cbl_unit</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>()</span>
    <span class=c1># 所有卷积后面都有 BN ，所以 bias 始终为 False</span>
    <span class=n>cbl_unit</span><span class=o>.</span><span class=n>add</span><span class=p>(</span>
        <span class=n>nn</span><span class=o>.</span><span class=n>Conv2D</span><span class=p>(</span><span class=n>channels</span><span class=p>,</span> <span class=n>kernel_size</span><span class=o>=</span><span class=n>kernel_size</span><span class=p>,</span> <span class=n>strides</span><span class=o>=</span><span class=n>strides</span><span class=p>,</span> <span class=n>padding</span><span class=o>=</span><span class=n>padding</span><span class=p>,</span> <span class=n>groups</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>use_bias</span><span class=o>=</span><span class=bp>False</span><span class=p>),</span>
        <span class=n>nn</span><span class=o>.</span><span class=n>BatchNorm</span><span class=p>(),</span>
        <span class=n>nn</span><span class=o>.</span><span class=n>LeakyReLU</span><span class=p>(</span><span class=mf>0.1</span><span class=p>)</span>
    <span class=p>)</span>
    
    <span class=k>return</span> <span class=n>cbl_unit</span></code></pre></div></div><h4 id=headline-3>残差单元</h4><p>Darknet53 使用了残差结构，不过作者对残差单元进行了改良，与 resnet 论文中两种残差单元 (3x3 + 3x3 or 1x1 + 3x3 + 1x1) 都不
太一样。每个基本的残差单元都由一个 1x1 + 3x3 卷积实现，且 3x3 卷积 channel 的个数固定是 1x1 卷积 channel 个数的两倍。</p><div class="src src-python"><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># 残差网络需要重新定义前向传播的方式，必须自己定义网络层类</span>
<span class=k>class</span> <span class=nc>DarknetBasicBlockV3</span><span class=p>(</span><span class=n>gluon</span><span class=o>.</span><span class=n>HybridBlock</span><span class=p>):</span>
    <span class=s1>&#39;&#39;&#39;darknetV3 basic block&#39;&#39;&#39;</span>
    
    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>channels</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>        
        <span class=nb>super</span><span class=p>(</span><span class=n>DarknetBasicBlockV3</span><span class=p>,</span> <span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>        
        <span class=bp>self</span><span class=o>.</span><span class=n>body</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>()</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>body</span><span class=o>.</span><span class=n>add</span><span class=p>(</span>
            <span class=c1># 1x1 conv</span>
            <span class=n>cbl_gen</span><span class=p>(</span><span class=n>channels</span><span class=p>,</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>)),</span>
            <span class=c1># 3x3 conv</span>
            <span class=n>cbl_gen</span><span class=p>(</span><span class=n>channels</span><span class=o>*</span><span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>))</span>
        <span class=p>)</span>
    <span class=c1># 需要在 hybrid_forward 函数中添加额外的输入F。由于 MXNet 既有基于命令式编程的 NDArray 类，</span>
    <span class=c1># 又有基于符号式编程的 Symbol 类。由于这两个类的函数基本一致，MXNet会根据输入来决定 F 使用 NDArray 或 Symbol。    </span>
    <span class=k>def</span> <span class=nf>hybrid_forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>F</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
        <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=bp>self</span><span class=o>.</span><span class=n>body</span><span class=p>(</span><span class=n>x</span><span class=p>)</span></code></pre></div></div><h4 id=headline-4>Darknet53</h4><p>Darknet53 共由 5 个残差块组成，每个残差块重复的次数分别是 1,2,8,8,4 ，相应的通道数分别为 32,64,128,256,512 。且每个残差
块之前都有一个步长为 2 的卷积实现下采样操作。</p><p>由于每个残差单元由两层卷积实现，那么所有残差块共包含网络的层数为(1+2+8+8+4)*2=46 层，再加上每个残差块前面的一个下采样层，
也就是残差块的个数 5 ，这样就有了 46+5=51 层。最后加上最开始的一个卷积层，以及全连接层，总共有 53 层，也就是网络称为
Darknet53 的原因。</p><div class="src src-python"><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># 残差块的个数</span>
<span class=n>residual_block_num</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span> 
<span class=c1># 对应残差块 1x1 卷积输出 channel 个数，3x3 卷积输出 channel 个数翻倍</span>
<span class=n>darknet_channels</span> <span class=o>=</span> <span class=p>[</span><span class=mi>32</span><span class=p>,</span> <span class=p>[</span><span class=mi>32</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>128</span><span class=p>,</span> <span class=mi>256</span><span class=p>,</span> <span class=mi>512</span><span class=p>]]</span> 
<span class=n>class_num_imagenet</span> <span class=o>=</span> <span class=mi>1000</span> <span class=c1># for imagenet</span>

<span class=k>class</span> <span class=nc>Darknet53</span><span class=p>(</span><span class=n>gluon</span><span class=o>.</span><span class=n>HybridBlock</span><span class=p>):</span>
    <span class=s1>&#39;&#39;&#39;darknet53&#39;&#39;&#39;</span>
    
    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>residual_block_num</span><span class=p>,</span> <span class=n>channels</span><span class=p>,</span> <span class=n>class_num</span><span class=o>=</span><span class=mi>1000</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=nb>super</span><span class=p>(</span><span class=n>Darknet53</span><span class=p>,</span> <span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>features</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>()</span>
        
        <span class=c1># 网络最开始有一个卷积操作</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>features</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>cbl_gen</span><span class=p>(</span><span class=n>channels</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>)))</span>
        
        <span class=c1># 重复的残差块</span>
        <span class=k>for</span> <span class=n>residual_block</span><span class=p>,</span> <span class=n>channel</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>residual_block_num</span><span class=p>,</span> <span class=n>channels</span><span class=p>[</span><span class=mi>1</span><span class=p>]):</span>
            <span class=c1># 使用步长为 2 的卷积实现下采样，在每一个残差块的开始都有一个下采样层</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>features</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>cbl_gen</span><span class=p>(</span><span class=n>channel</span><span class=o>*</span><span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>2</span><span class=p>,</span><span class=mi>2</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>)))</span>
            <span class=c1># 一个残差块</span>
            <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>residual_block</span><span class=p>):</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>features</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>DarknetBasicBlockV3</span><span class=p>(</span><span class=n>channel</span><span class=p>))</span>
        
        <span class=c1># global average pooling</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>pooling</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>GlobalAvgPool2D</span><span class=p>()</span>
        
        <span class=c1># 全连接的输出层</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>output</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Dense</span><span class=p>(</span><span class=n>class_num</span><span class=p>)</span>
        
    <span class=k>def</span> <span class=nf>hybrid_forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>F</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>features</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>pooling</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>output</span><span class=p>(</span><span class=n>x</span><span class=p>)</span></code></pre></div></div><h3 id=headline-5>检测网络</h3><h4 id=headline-6>predictions across scales</h4><p>Fine-Grained Feature</p><ol><li><p>将靠近输出的检测层的 feature maps upsample 2X ，然后与网络前面层中相同大小的 feature maps 串接（作为不同的 channel 组
合），作为中间检测层的输入；将中间检测层同样操作作为靠近输入层检测层的输入。</p></li><li><p>本层 feature maps 有较好的语义信息，前面层 feature maps 有较好的位置信息，这里将两者进行了结合。</p></li><li><p>提升检测小物体效果明显</p></li></ol><p>YOLOv3 在主网络的不同 stage 共使用三个检测网络，除了通道个数不同外，每个检测网络的结构都是相同的。每个检测网络都是由一个
1x1+3x3 卷积重复 3 次构成，且 3x3 卷积的通道数是 1x1 卷积通道数的 2 倍。所以每个检测网络都是 6 层卷积，加上最后一个输出
层卷积构成。</p><p>效仿 FPN(Feature Pyramid Net) ，靠近输出层的检测网络输出会同时作为前面监测网络的输入（ 6 个卷积层中倒数第二个卷积层的输
出作为前面一个 stage 的检测网络的输入），所有检测网络不能使用一个 3 次循环实现，必须分开。</p><div class="src src-python"><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># 三个输出分别使用的检测通道数</span>
<span class=n>det_channels</span> <span class=o>=</span> <span class=p>[</span><span class=mi>512</span><span class=p>,</span> <span class=mi>256</span><span class=p>,</span> <span class=mi>128</span><span class=p>]</span>

<span class=k>class</span> <span class=nc>Detection</span><span class=p>(</span><span class=n>gluon</span><span class=o>.</span><span class=n>HybridBlock</span><span class=p>):</span>
    <span class=s1>&#39;&#39;&#39;
</span><span class=s1>    检测网络，三个检测网络的结构相同，只是 filter 个数不同，完全可以使用一个 for 循环实现，
</span><span class=s1>    但是需要在倒数第二层引出分支，和前面层的特征合并后，用于前面的检测网络，所以只能分开写
</span><span class=s1>
</span><span class=s1>    越靠近输入层， feature maps 越大，所以检测网络使用的 channel 相应的较少，防止较大运算量
</span><span class=s1>    &#39;&#39;&#39;</span>
    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>channels</span><span class=p>,</span> <span class=n>classes_num</span><span class=o>=</span><span class=mi>80</span><span class=p>,</span> <span class=n>anchors_num</span><span class=o>=</span><span class=mi>3</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=nb>super</span><span class=p>(</span><span class=n>Detection</span><span class=p>,</span> <span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>channels</span><span class=o>=</span><span class=n>channels</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>anchors_num</span><span class=o>=</span><span class=n>anchors_num</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>pred_num</span><span class=o>=</span><span class=mi>1</span><span class=o>+</span><span class=mi>4</span><span class=o>+</span><span class=n>classes_num</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>body</span><span class=o>=</span><span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>(</span><span class=n>prefix</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>tip</span><span class=o>=</span><span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>(</span><span class=n>prefix</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>

        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>):</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>body</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>cbl_gen</span><span class=p>(</span><span class=n>channels</span><span class=p>,</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>)))</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>body</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>cbl_gen</span><span class=p>(</span><span class=n>channels</span><span class=o>*</span><span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>)))</span>
            
        <span class=bp>self</span><span class=o>.</span><span class=n>body</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>cbl_gen</span><span class=p>(</span><span class=n>channels</span><span class=p>,</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>)))</span>        
        <span class=bp>self</span><span class=o>.</span><span class=n>tip</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>cbl_gen</span><span class=p>(</span><span class=n>channels</span><span class=o>*</span><span class=mi>2</span><span class=p>,</span> <span class=p>(</span><span class=mi>3</span><span class=p>,</span><span class=mi>3</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>)))</span>        

        
    <span class=k>def</span> <span class=nf>hybrid_forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>F</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>body</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>tip</span><span class=p>(</span><span class=n>x</span><span class=p>)</span></code></pre></div></div><h4 id=headline-7>串接层</h4><p>将靠近输出的检测网络结果输入到前面的检测网络时，会先经过一个 1x1 卷积，同时由于 feature maps size 不同，所以会进行上采样，
之后才会和主网络的输出作为不同的通道堆叠后作为检测网络的输入。</p><div class="src src-python"><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>Concates</span><span class=p>(</span><span class=n>gluon</span><span class=o>.</span><span class=n>HybridBlock</span><span class=p>):</span>
    <span class=s2>&#34;&#34;&#34;不同 stage 的 feature maps 串接的时候，先经过了一个 1x1 卷积和一个上采样
</span><span class=s2>    &#34;&#34;&#34;</span>
    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>channels</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=nb>super</span><span class=p>(</span><span class=n>Concates</span><span class=p>,</span> <span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>*</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>concate</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>(</span><span class=n>prefix</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>concate</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>cbl_gen</span><span class=p>(</span><span class=n>channels</span><span class=p>,</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>)))</span>
        
    <span class=k>def</span> <span class=nf>upsample_rept</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>stride</span><span class=p>):</span>
        <span class=s1>&#39;&#39;&#39;
</span><span class=s1>        不同的检测层输入堆叠的时候需要上采样，上采样的方式也很简单，
</span><span class=s1>        只是将 feature maps 沿着水平和垂直方向 repeat 指定的倍数。
</span><span class=s1>        &#39;&#39;&#39;</span>
        <span class=k>assert</span> <span class=nb>type</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=n>mx</span><span class=o>.</span><span class=n>ndarray</span><span class=o>.</span><span class=n>ndarray</span><span class=o>.</span><span class=n>NDArray</span> <span class=ow>or</span> <span class=nb>type</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>==</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span>
        <span class=k>return</span> <span class=n>x</span><span class=o>.</span><span class=n>repeat</span><span class=p>(</span><span class=n>axis</span><span class=o>=-</span><span class=mi>1</span><span class=p>,</span> <span class=n>repeats</span><span class=o>=</span><span class=n>stride</span><span class=p>)</span><span class=o>.</span><span class=n>repeat</span><span class=p>(</span><span class=n>axis</span><span class=o>=-</span><span class=mi>2</span><span class=p>,</span> <span class=n>repeats</span><span class=o>=</span><span class=n>stride</span><span class=p>)</span>    
    
    <span class=k>def</span> <span class=nf>hybrid_forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>F</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>concate</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
        <span class=n>x</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>upsample_rept</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>x</span></code></pre></div></div><h3 id=headline-8>输出层</h3><ol><li><p>YOLO 的输出是 feature maps ，使用 1x1 卷积得到最终的输出；每一个节点都输出固定数量的 Bbox</p></li></ol><p>每个检测网络的输出都是用 3 个 anchor ，每个 anchor 包含 1 个 obj 表示是否包含目标，4 个坐标值，以及 class 类别（使用
coco 就是 80 个类别，使用 VOC 就是 20 个类别），这里以 coco 为例。所以输出的通道数为 3*(1+4+80)=255 。通道的排序顺序可以
按照你的喜好随意排序，不过一般都是 3 个 anchor 依序排列，每个 anchor 内分别是 box-center,box-scale,objness,class ，class
采用 one-hot 形式，就是 [{x,y,w,h,obj,class-one-hot},{x,y,w,h,obj,class-one-hot},{x,y,w,h,obj,class-one-hot}] 。</p><p>感觉输出层其实很简单，只有一层卷积，但是由于 anchor 以及网络输出与真实值之间需要转换，同时训练和预测时输出的不一致，
output 整的很麻烦。</p><h4 id=headline-9>输出坐标</h4><p>直接训练网络预测物体的宽和高，会使得网络不稳定。因此检测算法会使用对数空间或者预测 Bbox 相对于 anchor 的 offset 。YOLOv3
feature maps 的每个节点都使用 3 个不同大小的 anchor ，每个 anchor 都可能预测不同的物体。</p><p>\begin{align*}
b_x &= σ(t_x) + c_x<br>b_y &= σ(t_y) + c_y<br>b_w &= p_w e<sup>t_w</sup><br>b_h &= p_h e<sup>t_h</sup>
\end{align*}</p><p>其中 \(b_x,b_y,b_w,b_h\) 分别是预测的物体的实际中心点坐标，以及宽和高。 \(t_x,t_y,t_w,t_h\) 是网络的输出值。 \(c_x,c_y\)
是该 grid cell 左上角坐标， \(p_w,p_h\) 是 anchor 的宽和高。</p><ol><li><p>通过 sigmoid 函数确保中心点的相对坐标值在 0-1 之间，相对于该 grid cell 左上角。使用指数函数确保宽和高非负。</p></li><li><p>\(b_w,b_h\) 用图片的宽和高进行了归一化，且使用对数空间计算。即物体实际的大小应该是 \(b_w,b_h\) 分别乘以图像的宽度和高
度</p></li></ol><div class="src src-c"><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp># darknet 源码中对 VOC 标签做转换
</span><span class=cp></span><span class=n>def</span> <span class=n>convert</span><span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=n>box</span><span class=p>)</span><span class=o>:</span>
    <span class=c1>// 中心点、宽、高等都是将图片转换成 1x1 后的相对坐标
</span><span class=c1></span>    <span class=n>dw</span> <span class=o>=</span> <span class=mf>1.</span><span class=o>/</span><span class=p>(</span><span class=n>size</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=n>dh</span> <span class=o>=</span> <span class=mf>1.</span><span class=o>/</span><span class=p>(</span><span class=n>size</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
    <span class=c1>// 开始一直不明白为什么最后要减 1 ；
</span><span class=c1></span>    <span class=c1>// 其实就是将从 1 开始计数转换成从 0 开始；笨呐
</span><span class=c1></span>    <span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>box</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=n>box</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span><span class=o>/</span><span class=mf>2.0</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=n>y</span> <span class=o>=</span> <span class=p>(</span><span class=n>box</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>box</span><span class=p>[</span><span class=mi>3</span><span class=p>])</span><span class=o>/</span><span class=mf>2.0</span> <span class=o>-</span> <span class=mi>1</span>
    <span class=n>w</span> <span class=o>=</span> <span class=n>box</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>-</span> <span class=n>box</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=n>h</span> <span class=o>=</span> <span class=n>box</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>-</span> <span class=n>box</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>
    <span class=n>x</span> <span class=o>=</span> <span class=n>x</span><span class=o>*</span><span class=n>dw</span>
    <span class=n>w</span> <span class=o>=</span> <span class=n>w</span><span class=o>*</span><span class=n>dw</span>
    <span class=n>y</span> <span class=o>=</span> <span class=n>y</span><span class=o>*</span><span class=n>dh</span>
    <span class=n>h</span> <span class=o>=</span> <span class=n>h</span><span class=o>*</span><span class=n>dh</span>
    <span class=k>return</span> <span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>,</span><span class=n>w</span><span class=p>,</span><span class=n>h</span><span class=p>)</span></code></pre></div></div><h4 id=headline-10>class prediction</h4><ol><li><p>作者使用相互独立的 logistic classifier</p></li><li><p>训练时使用 binary cross-entropy loss</p></li><li><p>并不一定要使用 softmax 分类才能达到较好的效果</p></li><li><p>softmax 假定各个类别相互独立，不利于扩展到有重叠的类别</p></li><li><p>最终输出的预测概率是 objness*class</p></li></ol><h4 id=headline-11>输出层代码</h4><div class="src src-python"><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>Output</span><span class=p>(</span><span class=n>gluon</span><span class=o>.</span><span class=n>HybridBlock</span><span class=p>):</span>
    <span class=s2>&#34;&#34;&#34;YOLOv3 输出
</span><span class=s2>    &#34;&#34;&#34;</span>
    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>anchors</span><span class=p>,</span> <span class=n>stride</span><span class=p>,</span> <span class=n>classes_num</span><span class=o>=</span><span class=mi>80</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=nb>super</span><span class=p>(</span><span class=n>Output</span><span class=p>,</span> <span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>stride</span> <span class=o>=</span> <span class=n>stride</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>anchors_num</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>anchors</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>classes_num</span> <span class=o>=</span> <span class=n>classes_num</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>pred_num</span> <span class=o>=</span> <span class=mi>1</span><span class=o>+</span><span class=mi>4</span><span class=o>+</span><span class=n>classes_num</span>
        <span class=n>anchors</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>anchors</span><span class=p>)</span><span class=o>.</span><span class=n>astype</span><span class=p>(</span><span class=s1>&#39;float32&#39;</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>anchors</span> <span class=o>=</span> <span class=n>anchors</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>output</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>(</span><span class=n>prefix</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>
        <span class=c1># 这里是线性激活函数，默认 nn.Conv2D 的 activation=None，两者等效</span>
        <span class=c1># 输出 channel 的个数 (4+1+classes)*anchors</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>output</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>nn</span><span class=o>.</span><span class=n>Conv2D</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>pred_num</span><span class=o>*</span><span class=bp>self</span><span class=o>.</span><span class=n>anchors_num</span><span class=p>,</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>),</span> <span class=n>groups</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>use_bias</span><span class=o>=</span><span class=bp>True</span><span class=p>))</span>        

        <span class=c1># offsets will be added to predictions</span>
        <span class=n>grid_x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>128</span><span class=p>)</span>
        <span class=n>grid_y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>128</span><span class=p>)</span>
        <span class=n>grid_x</span><span class=p>,</span> <span class=n>grid_y</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>meshgrid</span><span class=p>(</span><span class=n>grid_x</span><span class=p>,</span> <span class=n>grid_y</span><span class=p>)</span>
        <span class=c1># stack to (n, n, 2)</span>
        <span class=n>offsets</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>concatenate</span><span class=p>((</span><span class=n>grid_x</span><span class=p>[:,</span> <span class=p>:,</span> <span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>],</span> <span class=n>grid_y</span><span class=p>[:,</span> <span class=p>:,</span> <span class=n>np</span><span class=o>.</span><span class=n>newaxis</span><span class=p>]),</span> <span class=n>axis</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span>
        <span class=c1># expand dims to (1, 1, n, n, 2) so it&#39;s easier for broadcasting</span>
        <span class=n>offsets</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>expand_dims</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>expand_dims</span><span class=p>(</span><span class=n>offsets</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>),</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>offsets</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>offsets</span><span class=p>)</span><span class=c1>#self.params.get_constant(&#39;offset_%d&#39;%(index), offsets)</span>
        
        
    <span class=k>def</span> <span class=nf>hybrid_forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>F</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
        <span class=n>pred</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>output</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>

        <span class=c1># prediction flat to (batch, pred per pixel, height * width)</span>
        <span class=n>pred</span> <span class=o>=</span> <span class=n>pred</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>anchors_num</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>pred_num</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>))</span>
        <span class=c1># transpose to (batch, height * width, num_anchor, num_pred)</span>
        <span class=n>pred</span> <span class=o>=</span> <span class=n>pred</span><span class=o>.</span><span class=n>transpose</span><span class=p>(</span><span class=n>axes</span><span class=o>=</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>anchors_num</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>pred_num</span><span class=p>))</span>
        <span class=c1># components</span>
        <span class=n>raw_box_centers</span> <span class=o>=</span> <span class=n>pred</span><span class=o>.</span><span class=n>slice_axis</span><span class=p>(</span><span class=n>axis</span><span class=o>=-</span><span class=mi>1</span><span class=p>,</span> <span class=n>begin</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
        <span class=n>raw_box_scales</span> <span class=o>=</span> <span class=n>pred</span><span class=o>.</span><span class=n>slice_axis</span><span class=p>(</span><span class=n>axis</span><span class=o>=-</span><span class=mi>1</span><span class=p>,</span> <span class=n>begin</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=mi>4</span><span class=p>)</span>
        <span class=n>objness</span> <span class=o>=</span> <span class=n>pred</span><span class=o>.</span><span class=n>slice_axis</span><span class=p>(</span><span class=n>axis</span><span class=o>=-</span><span class=mi>1</span><span class=p>,</span> <span class=n>begin</span><span class=o>=</span><span class=mi>4</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
        <span class=n>class_pred</span> <span class=o>=</span> <span class=n>pred</span><span class=o>.</span><span class=n>slice_axis</span><span class=p>(</span><span class=n>axis</span><span class=o>=-</span><span class=mi>1</span><span class=p>,</span> <span class=n>begin</span><span class=o>=</span><span class=mi>5</span><span class=p>,</span> <span class=n>end</span><span class=o>=</span><span class=bp>None</span><span class=p>)</span>

        <span class=c1># valid offsets, (1, 1, height, width, 2)</span>
        <span class=n>offsets</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>slice_like</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>offsets</span><span class=p>,</span> <span class=n>x</span> <span class=o>*</span> <span class=mi>0</span><span class=p>,</span> <span class=n>axes</span><span class=o>=</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>
        <span class=c1># reshape to (1, height*width, 1, 2)</span>
        <span class=n>offsets</span> <span class=o>=</span> <span class=n>offsets</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>

        <span class=n>box_centers</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>broadcast_add</span><span class=p>(</span><span class=n>nd</span><span class=o>.</span><span class=n>sigmoid</span><span class=p>(</span><span class=n>raw_box_centers</span><span class=p>),</span> <span class=n>offsets</span><span class=p>)</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>stride</span>
        <span class=n>box_scales</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>broadcast_mul</span><span class=p>(</span><span class=n>nd</span><span class=o>.</span><span class=n>exp</span><span class=p>(</span><span class=n>raw_box_scales</span><span class=p>),</span> <span class=bp>self</span><span class=o>.</span><span class=n>anchors</span><span class=p>)</span>
        <span class=n>confidence</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>sigmoid</span><span class=p>(</span><span class=n>objness</span><span class=p>)</span>
        <span class=n>class_score</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>broadcast_mul</span><span class=p>(</span><span class=n>nd</span><span class=o>.</span><span class=n>sigmoid</span><span class=p>(</span><span class=n>class_pred</span><span class=p>),</span> <span class=n>confidence</span><span class=p>)</span>
        <span class=n>wh</span> <span class=o>=</span> <span class=n>box_scales</span> <span class=o>/</span> <span class=mf>2.0</span>
        <span class=c1># `corner`: [xmin, ymin, xmax, ymax]</span>
        <span class=c1># `center`: [x, y, width, height]</span>
        <span class=c1># center to corner</span>
        <span class=n>bbox</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=n>box_centers</span> <span class=o>-</span> <span class=n>wh</span><span class=p>,</span> <span class=n>box_centers</span> <span class=o>+</span> <span class=n>wh</span><span class=p>,</span> <span class=n>dim</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span>

        <span class=k>if</span> <span class=n>autograd</span><span class=o>.</span><span class=n>is_training</span><span class=p>():</span>
            <span class=c1># during training, we don&#39;t need to convert whole bunch of info to detection results</span>
            <span class=k>return</span> <span class=p>(</span><span class=n>bbox</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>)),</span> <span class=n>raw_box_centers</span><span class=p>,</span> <span class=n>raw_box_scales</span><span class=p>,</span>
                    <span class=n>objness</span><span class=p>,</span> <span class=n>class_pred</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>anchors</span><span class=p>,</span> <span class=n>offsets</span><span class=p>)</span>

        <span class=c1># prediction per class</span>
        <span class=n>bboxes</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>tile</span><span class=p>(</span><span class=n>bbox</span><span class=p>,</span> <span class=n>reps</span><span class=o>=</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>classes_num</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
        <span class=n>scores</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>transpose</span><span class=p>(</span><span class=n>class_score</span><span class=p>,</span> <span class=n>axes</span><span class=o>=</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span><span class=o>.</span><span class=n>expand_dims</span><span class=p>(</span><span class=n>axis</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span>
        <span class=n>ids</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>broadcast_add</span><span class=p>(</span><span class=n>scores</span> <span class=o>*</span> <span class=mi>0</span><span class=p>,</span> <span class=n>F</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>classes_num</span><span class=p>)</span><span class=o>.</span><span class=n>reshape</span><span class=p>((</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)))</span>
        <span class=n>detections</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=n>ids</span><span class=p>,</span> <span class=n>scores</span><span class=p>,</span> <span class=n>bboxes</span><span class=p>,</span> <span class=n>dim</span><span class=o>=-</span><span class=mi>1</span><span class=p>)</span>
        <span class=c1># reshape to (B, xx, 6)</span>
        <span class=n>detections</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=n>detections</span><span class=o>.</span><span class=n>transpose</span><span class=p>(</span><span class=n>axes</span><span class=o>=</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)),</span> <span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>6</span><span class=p>))</span>
        <span class=k>return</span> <span class=n>detections</span></code></pre></div></div><h3 id=headline-12>YOLOv3</h3><p>将主网络与检测网络以及输出拼装起来，就组成了 YOLOv3 。最开始看到 YOLOv3 网络的时候，感觉很网络很复杂，感觉无从下手来写网
络结构。可是将主网络和检测网络拆分开，忽然又变得很容易。</p><div class="src src-python"><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># 这里都进行了反序</span>
<span class=n>strides</span> <span class=o>=</span> <span class=p>[</span><span class=mi>32</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>8</span><span class=p>]</span>
<span class=n>anchors</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>116</span><span class=p>,</span> <span class=mi>90</span><span class=p>,</span> <span class=mi>156</span><span class=p>,</span> <span class=mi>198</span><span class=p>,</span> <span class=mi>373</span><span class=p>,</span> <span class=mi>326</span><span class=p>],</span> <span class=p>[</span><span class=mi>30</span><span class=p>,</span> <span class=mi>61</span><span class=p>,</span> <span class=mi>62</span><span class=p>,</span> <span class=mi>45</span><span class=p>,</span> <span class=mi>59</span><span class=p>,</span> <span class=mi>119</span><span class=p>],</span> <span class=p>[</span><span class=mi>10</span><span class=p>,</span> <span class=mi>13</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>30</span><span class=p>,</span> <span class=mi>33</span><span class=p>,</span> <span class=mi>23</span><span class=p>]]</span>

<span class=k>class</span> <span class=nc>YOLOv3</span><span class=p>(</span><span class=n>gluon</span><span class=o>.</span><span class=n>HybridBlock</span><span class=p>):</span>
    <span class=s2>&#34;&#34;&#34;生成 YOLOv3 网络，只适用于 Darknet53 ，
</span><span class=s2>    &#34;&#34;&#34;</span>
    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=nb>super</span><span class=p>(</span><span class=n>YOLOv3</span><span class=p>,</span> <span class=bp>self</span><span class=p>)</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>

        <span class=c1># 基本网络框架</span>
        <span class=n>darknet53</span> <span class=o>=</span> <span class=n>Darknet53</span><span class=p>(</span><span class=n>residual_block_num</span><span class=p>,</span> <span class=n>darknet_channels</span><span class=p>)</span>
        <span class=c1># residual_block_num = [1, 2, 8, 8, 4] , 每一个残差块的开始都有一个下采样层</span>
        <span class=n>feature1_layer</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=mi>2</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=mi>8</span><span class=p>)</span>
        <span class=n>feature2_layer</span> <span class=o>=</span> <span class=n>feature1_layer</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=mi>8</span><span class=p>)</span>
        <span class=n>feature3_layer</span> <span class=o>=</span> <span class=n>feature2_layer</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=mi>4</span><span class=p>)</span> <span class=c1># 可以直接到末尾，</span>

        <span class=bp>self</span><span class=o>.</span><span class=n>features</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>(</span><span class=n>prefix</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>features</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>darknet53</span><span class=o>.</span><span class=n>features</span><span class=p>[:</span><span class=n>feature1_layer</span><span class=p>])</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>features</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>darknet53</span><span class=o>.</span><span class=n>features</span><span class=p>[</span><span class=n>feature1_layer</span><span class=p>:</span><span class=n>feature2_layer</span><span class=p>])</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>features</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>darknet53</span><span class=o>.</span><span class=n>features</span><span class=p>[</span><span class=n>feature2_layer</span><span class=p>:</span><span class=n>feature3_layer</span><span class=p>])</span>

        <span class=c1># 从基本网络框架引出的检测网络层，包含输出</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>detection_net</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>(</span><span class=n>prefix</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>
        <span class=k>for</span> <span class=n>det_channel</span> <span class=ow>in</span> <span class=n>det_channels</span><span class=p>:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>detection_net</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>Detection</span><span class=p>(</span><span class=n>det_channel</span><span class=p>))</span>

        <span class=c1># 串接不同 stage </span>
        <span class=bp>self</span><span class=o>.</span><span class=n>concates</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>(</span><span class=n>prefix</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>
        <span class=k>for</span> <span class=n>det_channel</span> <span class=ow>in</span> <span class=n>det_channels</span><span class=p>[</span><span class=mi>1</span><span class=p>:]:</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>concates</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>Concates</span><span class=p>(</span><span class=n>det_channel</span><span class=p>))</span>
 
        <span class=c1># 输出</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>output</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>HybridSequential</span><span class=p>(</span><span class=n>prefix</span><span class=o>=</span><span class=s1>&#39;&#39;</span><span class=p>)</span>
        <span class=k>for</span> <span class=n>anchor</span><span class=p>,</span> <span class=n>stride</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=n>anchors</span><span class=p>,</span> <span class=n>strides</span><span class=p>):</span>
            <span class=bp>self</span><span class=o>.</span><span class=n>output</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>Output</span><span class=p>(</span><span class=n>anchor</span><span class=p>,</span> <span class=n>stride</span><span class=p>))</span>


    <span class=k>def</span> <span class=nf>hybrid_forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>F</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>

        <span class=c1># 先计算出所有 stage 的 features</span>
        <span class=n>featuremaps</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=k>for</span> <span class=n>net</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>features</span><span class=p>:</span>
            <span class=n>x</span> <span class=o>=</span> <span class=n>net</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
            <span class=n>featuremaps</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>

        <span class=c1># 反序</span>
        <span class=n>featuremaps</span> <span class=o>=</span> <span class=n>featuremaps</span><span class=p>[::</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>

        <span class=n>output</span> <span class=o>=</span> <span class=p>[]</span>
        <span class=n>det</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>array</span><span class=p>([])</span>
        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>featuremaps</span><span class=p>)):</span>
            <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
                <span class=n>det</span> <span class=o>=</span> <span class=n>featuremaps</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
            <span class=k>else</span><span class=p>:</span>
                <span class=n>det</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>concates</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>](</span><span class=n>det</span><span class=p>)</span>
                <span class=n>det</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=n>det</span><span class=p>,</span> <span class=n>featuremaps</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dim</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>

            <span class=n>det</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>detection_net</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>body</span><span class=p>(</span><span class=n>det</span><span class=p>)</span>   
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>detection_net</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=n>tip</span><span class=p>(</span><span class=n>det</span><span class=p>)</span>
            <span class=n>out</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>output</span><span class=p>[</span><span class=n>i</span><span class=p>](</span><span class=n>out</span><span class=p>)</span>
            <span class=n>output</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>out</span><span class=p>)</span>

        <span class=k>return</span> <span class=n>output</span></code></pre></div></div><h3 id=headline-13>anchor</h3><p>目标应该对应哪个 anchor ？首先要将训练和预测区分开来。</p><p>一个 anchor 就是规定了一个 Bbox 的宽和高，需要使用两个整数表示，anchor 可以放在图像的任意位置。YOLOv3 共使用了 9 个
anchor (anchors = <a href="116, 90, 156, 198, 373, 326], [30, 61, 62, 45, 59, 119], [10, 13, 16, 30, 33, 23">116, 90, 156, 198, 373, 326], [30, 61, 62, 45, 59, 119], [10, 13, 16, 30, 33, 23</a>) ，分别用在 3 个
检测网络中，也就是每个检测网络使用 3 个 anchor ，面积小的 anchor 会被分配到靠近输入的检测网络，因为这时候目标的位置信息
会相对准确，面积大的 anchor 被分配到靠近输出的网络（也就是哪个 anchor 在哪个检测网络是确定的）。三个检测网络分别在主网络
中不同大小的 feature maps 上面检测，也就意味着三个检测网络是在进行重复检测。</p><ol><li><p>v3 共使用了 3 个 scale ，每个 scale 使用 3 个 anchor ，不同 scale 的 anchor 大小不同，共使用了 9 个 anchor</p></li><li><p>YOLOv3 每级使用了 3 个 anchor 输出，输出大小 {N*N*[3*(4+1+80)]}</p></li><li><p>越靠近输入层使用 anchor 的尺寸越小</p></li><li><p><strong>训练时与物体 groundtruth Bbox IoU 最大的 anchor 用于预测该物体</strong></p></li><li><p>如果一个 grid 内有多余 anchor 个数的物体，无法同时检测</p></li><li><p>如果两个或以上物体在同一个 grid 内且与同一个 anchor 有较大 IoU ，同样无法检测</p></li></ol><h4 id=headline-14>怎样将输出与样本的标签对应</h4><h5 id=headline-15>training</h5><p>每个目标只需要一个 anchor 来检测，其余 8 个 anchor 都不会计算由于检测这个目标不准确而产生的误差。那么应该将这个目标分配
给哪一个 anchor 呢？计算目标和所有 9 个 anchor 的 IOU ，将目标分配给 IOU 最大的那个 anchor 。只有这个 anchor 的输出用于
计算目标的位置和类别误差。</p><h5 id=headline-16>prediction</h5><p>预测的时候，所有的 anchor 统一对待，过滤掉预测概率低于一定阈值的输出，然后分类别进行 NMS 即可。</p><h4 id=headline-17>使用 anchor 后效果</h4><ol><li><p>YOLOv2 使用 anchor 之后，准确率下降了，因为不使用 anchor 时，仅输出 98 个 Bbox ，但是使用 anchor 之后输出了 1000 多个
Bbox ，分母变得太大了，所以 accuracy 下降了一些，伴随着 mAP 也下降了 69.5->69.2。但是 recall 从 81% 上升到 88% ，因为
输出的个数增多，所以检测出来的目标也增多了；原来一直没有搞懂原因</p></li></ol><h3 id=headline-18>Loss</h3><p>损失总共包括四部分，box-center, box-scale, objness, class 。分别将四者的预测值和真实值用于计算即可。好像有不同的权重。</p><p>YOLOv3 loss 除了 box 的宽和高使用 L1-loss 以外， objectness 、box 中心点坐标、class 误差均使用
SigmoidBinaryCrossEntropyLoss 求解。只有包含目标的 anchor 才会计算所有误差，不包含目标的 anchor 只计算 objness 误差
（不过 anchor 和 gtbbox 超过一定阈值的会被忽略，也就是这些节点不会有任何误差用于更新权重）。</p><p>注意，只有被分配了目标的 anchor 才需要计算位置和类别误差，否则只计算 obj-loss</p><dl><dt>obj-loss</dt><dd><p>sum of objectness logistic loss</p></dd><dt>center-loss</dt><dd><p>sum of box center logistic regression loss</p></dd><dt>scale-loss</dt><dd><p>sum of box scale l1 loss</p></dd><dt>cls-loss</dt><dd><p>sum of per class logistic loss</p></dd></dl><div class="src src-python"><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1>#sigmoid_ce = gluon.loss.SigmoidBinaryCrossEntropyLoss(from_sigmoid=False)</span>
<span class=c1>#l1_loss = gluon.loss.L1Loss()</span>
<span class=k>def</span> <span class=nf>sigmoid_ce</span><span class=p>(</span><span class=n>pred</span><span class=p>,</span> <span class=n>label</span><span class=p>):</span>
    <span class=n>loss</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>relu</span><span class=p>(</span><span class=n>pred</span><span class=p>)</span> <span class=o>-</span> <span class=n>pred</span> <span class=o>*</span> <span class=n>label</span> <span class=o>+</span> <span class=n>nd</span><span class=o>.</span><span class=n>Activation</span><span class=p>(</span><span class=o>-</span><span class=n>nd</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>pred</span><span class=p>),</span> <span class=n>act_type</span><span class=o>=</span><span class=s1>&#39;softrelu&#39;</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>nd</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>loss</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>exclude</span><span class=o>=</span><span class=bp>True</span><span class=p>)</span>

<span class=k>def</span> <span class=nf>l1_loss</span><span class=p>(</span><span class=n>pred</span><span class=p>,</span> <span class=n>label</span><span class=p>):</span>
    <span class=n>loss</span> <span class=o>=</span> <span class=n>nd</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>pred</span> <span class=o>-</span> <span class=n>label</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>nd</span><span class=o>.</span><span class=n>mean</span><span class=p>(</span><span class=n>loss</span><span class=p>,</span> <span class=n>axis</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span> <span class=n>exclude</span><span class=o>=</span><span class=bp>True</span><span class=p>)</span></code></pre></div></div><h4 id=headline-19>loss 未删</h4><p>YOLOv1 中由于 sum-squared error (SSE) 容易优化，作者选用其作为损失函数，又由于希望小物体相比大物体有较好的精度，作者将
Bbox 的宽和高进行了开方 <a href=https://stats.stackexchange.com/questions/287486/yolo-loss-function-explanation>（回答者电话咨询过作者）</a> ，paper 上也有一些描述。 YOLOv3 中并没有对宽和高进行开方，YOLOv2 不清楚。
lambda is highest for coordinates in order to focus more on detection</p><ol><li><p>objectness score – 表示 Bbox 中含有目标的概率。YOLOv1 和 YOLOv2 设置一致，但 YOLOv3 中做了修改 ；</p></li><li><p>每个 anchor 输出一个 objectness/confidence ，用于表明这个 anchor 中有物体的概率及预测的 Bbox 的准确度，使用公式
\(Pr(Object)*IOU_{pred}^{truth}\) 。但是在 YOLOv3 中， confidence score 等于 1 ，当 gtbox 和 anchor 有最大的 IOU 的时
候，否则为 0 ，网络的输出是 sigmoid(t_o) 。</p></li><li><p>同时每个 anchor 输出该 anchor 中有物体的条件下，其类别的条件概率 \(Pr(Class_i|Object)\)</p></li><li><p>测试的时候，将 confidence 和条件类别概率相乘作为每个类别的 confidence score \(Pr(Class_i|Object) * Pr(Object) *
IOU_{pred}^{truth} = Pr(Class_i) * IOU_{pred}^{truth}\)</p></li><li><p>由于 grid 中背景数目较多，所以降低不包含物体的误差权重，否则会 overwhelming 权重</p></li><li><p>YOLOv3 使用 logistic regression 预测每个 Bbox 的 objectness score ；YOLOv3 计算使用了 sigmoid 函数确保输出的概率值在
0-1 之间；每个物体只分配给一个 Bbox prior ；当一个 Bbox prior [anchor] 和物体的 groundtruth有最大的 IOU 的时候值为 1
；当 Bbox prior 没有对应物体时，只产生 objectness loss 没有 coordinate 和 class prediction loss ；当 Bbox prior 和
groundtruth 的 IOU 大于一定阈值（作者采用 0.5） ，但却并不是最大的 IOU 的时候，忽略其预测，参考 <a href=https://stats.stackexchange.com/questions/373266/yolo-v3-loss-function>Ci 定义探讨</a> ，猜测：
这里是为了防止 objectness 难以训练，因为只给 IOU 最大的Bbox prior 设置值为 1， 其他的 Bbox prior 同样和物体的
groundtruth IOU 很大，却被赋值为 0 ，若这些 Bbox prior 的objectness score 作用于 loss ，可能导致 objectness score 难
以收敛；正如在 YOLOv1 和 YOLOv2 中，objectness score 被定义为 \(Pr(Object)*IOU_{pred}^{truth}\) ，作者应该就是想通过
IOU 来降低未被赋予物体的 Bbox 的损失比重，同时还乘以了一个小于 1 的系数。</p></li></ol><p>参考：</p><ol><li><p><a href=https://stats.stackexchange.com/questions/287486/yolo-loss-function-explanation>YOLOv2 loss - stackexchange</a></p></li><li><p><a href=https://stats.stackexchange.com/questions/373266/yolo-v3-loss-function>YOLOv3 confidence-scores</a></p></li><li><p><a href=https://stats.stackexchange.com/questions/380012/yolov3-loss-function>YOLOv3 not best Iou but over some threshold</a></p></li></ol><h3 id=headline-20>输入图片没有 resize 到统一的大小？</h3><ol><li><p>v1 中有全连接层，输入可定是固定大小的：使用 imagenet 预训练使用 224*224 ，去掉全连接层然后使用 448*448 训练检测分类网
络；所以最终需要的输入应该也是 448*448</p></li><li><p>YOLOv3 是一个 FCN ，对输入的大小不敏感</p></li><li><p>训练好像都只是在 resize short size</p></li></ol><h3 id=headline-21>Dimension Clusters</h3><ol><li><p>YOLOv2 使用 k-means 算法，先找到目标 Bbox 的合理先验，然后用这些更合理的 anchor 作为先验，使得模型更容易学习</p></li><li><p>但是 Faster R-CNN 文中却指出，只使用 1:1,1:2,2:1 三种比例的 anchor 作为先验，并不去适应某一个具体的数据集，使得算法的
泛化能力更好。</p></li><li><p>最初感觉 YOLO 为了更好的拟合 VOC 或者 COCO ，可能最终测试泛化效果并不好。但是实际使用中，应该会针对某一类具体的目标，
使用这类目标的更合理的先验，从而可以提高准确率呀！</p></li><li><p>另外， YOLOv2 中画出了 VOC 和 COCO 聚类 Bbox 的形状，两者都是瘦高的矩形占多数。而这些数据集都是生活中的真实图片，所以
实际使用时，对于一般目标，其泛化能力不一定不好。</p></li></ol><div class="src src-python"><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=c1># https://github.com/AlexeyAB/darknet/blob/master/scripts/gen_anchors.py</span>
<span class=s1>&#39;&#39;&#39;
</span><span class=s1>Created on Feb 20, 2017
</span><span class=s1>
</span><span class=s1>@author: jumabek
</span><span class=s1>&#39;&#39;&#39;</span>
<span class=kn>from</span> <span class=nn>os</span> <span class=kn>import</span> <span class=n>listdir</span>
<span class=kn>from</span> <span class=nn>os.path</span> <span class=kn>import</span> <span class=n>isfile</span><span class=p>,</span> <span class=n>join</span>
<span class=kn>import</span> <span class=nn>argparse</span>
<span class=c1>#import cv2</span>
<span class=kn>import</span> <span class=nn>numpy</span> <span class=kn>as</span> <span class=nn>np</span>
<span class=kn>import</span> <span class=nn>sys</span>
<span class=kn>import</span> <span class=nn>os</span>
<span class=kn>import</span> <span class=nn>shutil</span>
<span class=kn>import</span> <span class=nn>random</span> 
<span class=kn>import</span> <span class=nn>math</span>

<span class=n>width_in_cfg_file</span> <span class=o>=</span> <span class=mf>416.</span>
<span class=n>height_in_cfg_file</span> <span class=o>=</span> <span class=mf>416.</span>

<span class=k>def</span> <span class=nf>IOU</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>centroids</span><span class=p>):</span>
    <span class=n>similarities</span> <span class=o>=</span> <span class=p>[]</span>
    <span class=n>k</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>centroids</span><span class=p>)</span>
    <span class=k>for</span> <span class=n>centroid</span> <span class=ow>in</span> <span class=n>centroids</span><span class=p>:</span>
        <span class=n>c_w</span><span class=p>,</span><span class=n>c_h</span> <span class=o>=</span> <span class=n>centroid</span>
        <span class=n>w</span><span class=p>,</span><span class=n>h</span> <span class=o>=</span> <span class=n>x</span>
        <span class=k>if</span> <span class=n>c_w</span><span class=o>&gt;=</span><span class=n>w</span> <span class=ow>and</span> <span class=n>c_h</span><span class=o>&gt;=</span><span class=n>h</span><span class=p>:</span>
            <span class=n>similarity</span> <span class=o>=</span> <span class=n>w</span><span class=o>*</span><span class=n>h</span><span class=o>/</span><span class=p>(</span><span class=n>c_w</span><span class=o>*</span><span class=n>c_h</span><span class=p>)</span>
        <span class=k>elif</span> <span class=n>c_w</span><span class=o>&gt;=</span><span class=n>w</span> <span class=ow>and</span> <span class=n>c_h</span><span class=o>&lt;=</span><span class=n>h</span><span class=p>:</span>
            <span class=n>similarity</span> <span class=o>=</span> <span class=n>w</span><span class=o>*</span><span class=n>c_h</span><span class=o>/</span><span class=p>(</span><span class=n>w</span><span class=o>*</span><span class=n>h</span> <span class=o>+</span> <span class=p>(</span><span class=n>c_w</span><span class=o>-</span><span class=n>w</span><span class=p>)</span><span class=o>*</span><span class=n>c_h</span><span class=p>)</span>
        <span class=k>elif</span> <span class=n>c_w</span><span class=o>&lt;=</span><span class=n>w</span> <span class=ow>and</span> <span class=n>c_h</span><span class=o>&gt;=</span><span class=n>h</span><span class=p>:</span>
            <span class=n>similarity</span> <span class=o>=</span> <span class=n>c_w</span><span class=o>*</span><span class=n>h</span><span class=o>/</span><span class=p>(</span><span class=n>w</span><span class=o>*</span><span class=n>h</span> <span class=o>+</span> <span class=n>c_w</span><span class=o>*</span><span class=p>(</span><span class=n>c_h</span><span class=o>-</span><span class=n>h</span><span class=p>))</span>
        <span class=k>else</span><span class=p>:</span> <span class=c1>#means both w,h are bigger than c_w and c_h respectively</span>
            <span class=n>similarity</span> <span class=o>=</span> <span class=p>(</span><span class=n>c_w</span><span class=o>*</span><span class=n>c_h</span><span class=p>)</span><span class=o>/</span><span class=p>(</span><span class=n>w</span><span class=o>*</span><span class=n>h</span><span class=p>)</span>
        <span class=n>similarities</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>similarity</span><span class=p>)</span> <span class=c1># will become (k,) shape</span>
    <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>similarities</span><span class=p>)</span> 

<span class=k>def</span> <span class=nf>avg_IOU</span><span class=p>(</span><span class=n>X</span><span class=p>,</span><span class=n>centroids</span><span class=p>):</span>
    <span class=n>n</span><span class=p>,</span><span class=n>d</span> <span class=o>=</span> <span class=n>X</span><span class=o>.</span><span class=n>shape</span>
    <span class=nb>sum</span> <span class=o>=</span> <span class=mf>0.</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>X</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]):</span>
        <span class=c1>#note IOU() will return array which contains IoU for each centroid and X[i] // slightly ineffective, but I am too lazy</span>
        <span class=nb>sum</span><span class=o>+=</span> <span class=nb>max</span><span class=p>(</span><span class=n>IOU</span><span class=p>(</span><span class=n>X</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>centroids</span><span class=p>))</span> 
    <span class=k>return</span> <span class=nb>sum</span><span class=o>/</span><span class=n>n</span>

<span class=k>def</span> <span class=nf>write_anchors_to_file</span><span class=p>(</span><span class=n>centroids</span><span class=p>,</span><span class=n>X</span><span class=p>,</span><span class=n>anchor_file</span><span class=p>):</span>
    <span class=n>f</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=n>anchor_file</span><span class=p>,</span><span class=s1>&#39;w&#39;</span><span class=p>)</span>
    
    <span class=n>anchors</span> <span class=o>=</span> <span class=n>centroids</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
    <span class=k>print</span><span class=p>(</span><span class=n>anchors</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>

    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>anchors</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]):</span>
        <span class=n>anchors</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span><span class=o>*=</span><span class=n>width_in_cfg_file</span><span class=o>/</span><span class=mf>32.</span>
        <span class=n>anchors</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span><span class=o>*=</span><span class=n>height_in_cfg_file</span><span class=o>/</span><span class=mf>32.</span>
         

    <span class=n>widths</span> <span class=o>=</span> <span class=n>anchors</span><span class=p>[:,</span><span class=mi>0</span><span class=p>]</span>
    <span class=n>sorted_indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argsort</span><span class=p>(</span><span class=n>widths</span><span class=p>)</span>

    <span class=k>print</span><span class=p>(</span><span class=s1>&#39;Anchors = &#39;</span><span class=p>,</span> <span class=n>anchors</span><span class=p>[</span><span class=n>sorted_indices</span><span class=p>])</span>
        
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>sorted_indices</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>]:</span>
        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%0.2f</span><span class=s1>,</span><span class=si>%0.2f</span><span class=s1>, &#39;</span><span class=o>%</span><span class=p>(</span><span class=n>anchors</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span><span class=n>anchors</span><span class=p>[</span><span class=n>i</span><span class=p>,</span><span class=mi>1</span><span class=p>]))</span>

    <span class=c1>#there should not be comma after last anchor, that&#39;s why</span>
    <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%0.2f</span><span class=s1>,</span><span class=si>%0.2f</span><span class=se>\n</span><span class=s1>&#39;</span><span class=o>%</span><span class=p>(</span><span class=n>anchors</span><span class=p>[</span><span class=n>sorted_indices</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>:],</span><span class=mi>0</span><span class=p>],</span><span class=n>anchors</span><span class=p>[</span><span class=n>sorted_indices</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>:],</span><span class=mi>1</span><span class=p>]))</span>
    
    <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%f</span><span class=se>\n</span><span class=s1>&#39;</span><span class=o>%</span><span class=p>(</span><span class=n>avg_IOU</span><span class=p>(</span><span class=n>X</span><span class=p>,</span><span class=n>centroids</span><span class=p>)))</span>
    <span class=k>print</span><span class=p>()</span>

<span class=k>def</span> <span class=nf>kmeans</span><span class=p>(</span><span class=n>X</span><span class=p>,</span><span class=n>centroids</span><span class=p>,</span><span class=n>eps</span><span class=p>,</span><span class=n>anchor_file</span><span class=p>):</span>
    
    <span class=n>N</span> <span class=o>=</span> <span class=n>X</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
    <span class=n>iterations</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>k</span><span class=p>,</span><span class=n>dim</span> <span class=o>=</span> <span class=n>centroids</span><span class=o>.</span><span class=n>shape</span>
    <span class=n>prev_assignments</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>ones</span><span class=p>(</span><span class=n>N</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>    
    <span class=nb>iter</span> <span class=o>=</span> <span class=mi>0</span>
    <span class=n>old_D</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>N</span><span class=p>,</span><span class=n>k</span><span class=p>))</span>

    <span class=k>while</span> <span class=bp>True</span><span class=p>:</span>
        <span class=n>D</span> <span class=o>=</span> <span class=p>[]</span> 
        <span class=nb>iter</span><span class=o>+=</span><span class=mi>1</span>           
        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>
            <span class=n>d</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>IOU</span><span class=p>(</span><span class=n>X</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>centroids</span><span class=p>)</span>
            <span class=n>D</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>d</span><span class=p>)</span>
        <span class=n>D</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>D</span><span class=p>)</span> <span class=c1># D.shape = (N,k)</span>
        
        <span class=k>print</span><span class=p>(</span><span class=s2>&#34;iter {}: dists = {}&#34;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=nb>iter</span><span class=p>,</span><span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>abs</span><span class=p>(</span><span class=n>old_D</span><span class=o>-</span><span class=n>D</span><span class=p>))))</span>
            
        <span class=c1>#assign samples to centroids </span>
        <span class=n>assignments</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>argmin</span><span class=p>(</span><span class=n>D</span><span class=p>,</span><span class=n>axis</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
        
        <span class=k>if</span> <span class=p>(</span><span class=n>assignments</span> <span class=o>==</span> <span class=n>prev_assignments</span><span class=p>)</span><span class=o>.</span><span class=n>all</span><span class=p>()</span> <span class=p>:</span>
            <span class=k>print</span><span class=p>(</span><span class=s2>&#34;Centroids = &#34;</span><span class=p>,</span><span class=n>centroids</span><span class=p>)</span>
            <span class=n>write_anchors_to_file</span><span class=p>(</span><span class=n>centroids</span><span class=p>,</span><span class=n>X</span><span class=p>,</span><span class=n>anchor_file</span><span class=p>)</span>
            <span class=k>return</span>

        <span class=c1>#calculate new centroids</span>
        <span class=n>centroid_sums</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=n>k</span><span class=p>,</span><span class=n>dim</span><span class=p>),</span><span class=n>np</span><span class=o>.</span><span class=n>float</span><span class=p>)</span>
        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>N</span><span class=p>):</span>
            <span class=n>centroid_sums</span><span class=p>[</span><span class=n>assignments</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span><span class=o>+=</span><span class=n>X</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>        
        <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>k</span><span class=p>):</span>            
            <span class=n>centroids</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>centroid_sums</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>/</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>sum</span><span class=p>(</span><span class=n>assignments</span><span class=o>==</span><span class=n>j</span><span class=p>))</span>
        
        <span class=n>prev_assignments</span> <span class=o>=</span> <span class=n>assignments</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>     
        <span class=n>old_D</span> <span class=o>=</span> <span class=n>D</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>  

<span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=n>argv</span><span class=p>):</span>
    <span class=n>parser</span> <span class=o>=</span> <span class=n>argparse</span><span class=o>.</span><span class=n>ArgumentParser</span><span class=p>()</span>
    <span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;-filelist&#39;</span><span class=p>,</span> <span class=n>default</span> <span class=o>=</span> <span class=s1>&#39;</span><span class=se>\\</span><span class=s1>path</span><span class=se>\\</span><span class=s1>to</span><span class=se>\\</span><span class=s1>voc</span><span class=se>\\</span><span class=s1>filelist</span><span class=se>\\</span><span class=s1>train.txt&#39;</span><span class=p>,</span> 
                        <span class=n>help</span><span class=o>=</span><span class=s1>&#39;path to filelist</span><span class=se>\n</span><span class=s1>&#39;</span> <span class=p>)</span>
    <span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;-output_dir&#39;</span><span class=p>,</span> <span class=n>default</span> <span class=o>=</span> <span class=s1>&#39;generated_anchors/anchors&#39;</span><span class=p>,</span> <span class=nb>type</span> <span class=o>=</span> <span class=nb>str</span><span class=p>,</span> 
                        <span class=n>help</span><span class=o>=</span><span class=s1>&#39;Output anchor directory</span><span class=se>\n</span><span class=s1>&#39;</span> <span class=p>)</span>  
    <span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;-num_clusters&#39;</span><span class=p>,</span> <span class=n>default</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>type</span> <span class=o>=</span> <span class=nb>int</span><span class=p>,</span> 
                        <span class=n>help</span><span class=o>=</span><span class=s1>&#39;number of clusters</span><span class=se>\n</span><span class=s1>&#39;</span> <span class=p>)</span>  

   
    <span class=n>args</span> <span class=o>=</span> <span class=n>parser</span><span class=o>.</span><span class=n>parse_args</span><span class=p>()</span>
    
    <span class=k>if</span> <span class=ow>not</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>exists</span><span class=p>(</span><span class=n>args</span><span class=o>.</span><span class=n>output_dir</span><span class=p>):</span>
        <span class=n>os</span><span class=o>.</span><span class=n>mkdir</span><span class=p>(</span><span class=n>args</span><span class=o>.</span><span class=n>output_dir</span><span class=p>)</span>

    <span class=n>f</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=n>args</span><span class=o>.</span><span class=n>filelist</span><span class=p>)</span>
  
    <span class=n>lines</span> <span class=o>=</span> <span class=p>[</span><span class=n>line</span><span class=o>.</span><span class=n>rstrip</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span> <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>f</span><span class=o>.</span><span class=n>readlines</span><span class=p>()]</span>
    
    <span class=n>annotation_dims</span> <span class=o>=</span> <span class=p>[]</span>

    <span class=n>size</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>zeros</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>3</span><span class=p>))</span>
    <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>lines</span><span class=p>:</span>
                    
        <span class=c1>#line = line.replace(&#39;images&#39;,&#39;labels&#39;)</span>
        <span class=c1>#line = line.replace(&#39;img1&#39;,&#39;labels&#39;)</span>
        <span class=n>line</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s1>&#39;JPEGImages&#39;</span><span class=p>,</span><span class=s1>&#39;labels&#39;</span><span class=p>)</span>        
        

        <span class=n>line</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s1>&#39;.jpg&#39;</span><span class=p>,</span><span class=s1>&#39;.txt&#39;</span><span class=p>)</span>
        <span class=n>line</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s1>&#39;.png&#39;</span><span class=p>,</span><span class=s1>&#39;.txt&#39;</span><span class=p>)</span>
        <span class=k>print</span><span class=p>(</span><span class=n>line</span><span class=p>)</span>
        <span class=n>f2</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=n>line</span><span class=p>)</span>
        <span class=k>for</span> <span class=n>line</span> <span class=ow>in</span> <span class=n>f2</span><span class=o>.</span><span class=n>readlines</span><span class=p>():</span>
            <span class=n>line</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>rstrip</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>)</span>
            <span class=n>w</span><span class=p>,</span><span class=n>h</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39; &#39;</span><span class=p>)[</span><span class=mi>3</span><span class=p>:]</span>            
            <span class=c1>#print(w,h)</span>
            <span class=n>annotation_dims</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=nb>tuple</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>float</span><span class=p>,(</span><span class=n>w</span><span class=p>,</span><span class=n>h</span><span class=p>))))</span>
    <span class=n>annotation_dims</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>annotation_dims</span><span class=p>)</span>
  
    <span class=n>eps</span> <span class=o>=</span> <span class=mf>0.005</span>
    
    <span class=k>if</span> <span class=n>args</span><span class=o>.</span><span class=n>num_clusters</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>for</span> <span class=n>num_clusters</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>11</span><span class=p>):</span> <span class=c1>#we make 1 through 10 clusters </span>
            <span class=n>anchor_file</span> <span class=o>=</span> <span class=n>join</span><span class=p>(</span> <span class=n>args</span><span class=o>.</span><span class=n>output_dir</span><span class=p>,</span><span class=s1>&#39;anchors</span><span class=si>%d</span><span class=s1>.txt&#39;</span><span class=o>%</span><span class=p>(</span><span class=n>num_clusters</span><span class=p>))</span>

            <span class=n>indices</span> <span class=o>=</span> <span class=p>[</span> <span class=n>random</span><span class=o>.</span><span class=n>randrange</span><span class=p>(</span><span class=n>annotation_dims</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_clusters</span><span class=p>)]</span>
            <span class=n>centroids</span> <span class=o>=</span> <span class=n>annotation_dims</span><span class=p>[</span><span class=n>indices</span><span class=p>]</span>
            <span class=n>kmeans</span><span class=p>(</span><span class=n>annotation_dims</span><span class=p>,</span><span class=n>centroids</span><span class=p>,</span><span class=n>eps</span><span class=p>,</span><span class=n>anchor_file</span><span class=p>)</span>
            <span class=k>print</span><span class=p>(</span><span class=s1>&#39;centroids.shape&#39;</span><span class=p>,</span> <span class=n>centroids</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>
    <span class=k>else</span><span class=p>:</span>
        <span class=n>anchor_file</span> <span class=o>=</span> <span class=n>join</span><span class=p>(</span> <span class=n>args</span><span class=o>.</span><span class=n>output_dir</span><span class=p>,</span><span class=s1>&#39;anchors</span><span class=si>%d</span><span class=s1>.txt&#39;</span><span class=o>%</span><span class=p>(</span><span class=n>args</span><span class=o>.</span><span class=n>num_clusters</span><span class=p>))</span>
        <span class=n>indices</span> <span class=o>=</span> <span class=p>[</span> <span class=n>random</span><span class=o>.</span><span class=n>randrange</span><span class=p>(</span><span class=n>annotation_dims</span><span class=o>.</span><span class=n>shape</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>args</span><span class=o>.</span><span class=n>num_clusters</span><span class=p>)]</span>
        <span class=n>centroids</span> <span class=o>=</span> <span class=n>annotation_dims</span><span class=p>[</span><span class=n>indices</span><span class=p>]</span>
        <span class=n>kmeans</span><span class=p>(</span><span class=n>annotation_dims</span><span class=p>,</span><span class=n>centroids</span><span class=p>,</span><span class=n>eps</span><span class=p>,</span><span class=n>anchor_file</span><span class=p>)</span>
        <span class=k>print</span><span class=p>(</span><span class=s1>&#39;centroids.shape&#39;</span><span class=p>,</span> <span class=n>centroids</span><span class=o>.</span><span class=n>shape</span><span class=p>)</span>

<span class=k>if</span> <span class=vm>__name__</span><span class=o>==</span><span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
    <span class=n>main</span><span class=p>(</span><span class=n>sys</span><span class=o>.</span><span class=n>argv</span><span class=p>)</span></code></pre></div></div><h3 id=headline-22>YOLO9000</h3><p>YOLO9000 和 MaskXRcnn 一样，利用类别较多的简单标注数据集，扩展类别较少的复杂标注训练数据集，</p><p>使用 focalloss 外加 YOLO9000 感觉都完美了，one-stage 有速度也有精度，还有众众多类别。然而 YOLOv3 上面作者明确表示尝试了
focalloss 但 dono't work 。</p><h3 id=headline-23>高层思考</h3><p>Yolo 采用一个 CNN 网络来实现检测，是 one-stage 策略，其训练与预测都是 end-to-end，所以 Yolo 算法比较简洁且速度快。第二点
由于Yolo 是对整张图片做卷积，所以其在检测目标有更大的视野，它不容易对背景误判。</p><p>缺点：</p><ol><li><p>YOLOv3 在 mAP0.5 及小目标 APS 上具有不错的结果,但随着 IOU 的增大,性能下降,说明 YOLOv3 不能很好地与 ground truth 切合 <a href=https://www.cnblogs.com/makefile/p/YOLOv3.html>康行天下</a></p></li><li><p>召回率低</p></li></ol><h3 id=headline-24>参考</h3><ol><li><p><a href=https://github.com/kylestones/yolo-mxnet>mxnet 代码实现</a></p></li><li><p><a href=https://blog.csdn.net/leviopku/article/details/82660381>yolo系列之yolo v3</a> 【网络可视化对于网络结构理解的重要性】</p></li><li><p><a href=https://blog.paperspace.com/how-to-implement-a-yolo-object-detector-in-pytorch/>How to implement a YOLOv3</a> 【实现算法是理解算法的最好方法】</p></li><li><p><a href=https://www.cnblogs.com/makefile/p/YOLOv3.html>目标检测网络之 YOLOv3</a></p></li></ol><p>未参考</p><ol><li><p><a href=https://blog.csdn.net/yudiemiaomiao/article/details/72636776>YOLO v1,YOLO v2,YOLO9000算法总结与源码解析</a></p></li><li><p><a href=https://blog.csdn.net/u014380165/article/details/79367541>YOLO v2的算法细节——以李沐的Gluon代码为例</a></p></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://kylestones.github.io/hugo-blog/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/>深度学习</a></li><li><a href=https://kylestones.github.io/hugo-blog/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/>目标检测,</a></li></ul><nav class=paginav><a class=prev href=https://kylestones.github.io/hugo-blog/blog/machinelearning/vgg-googlenet-resnet/><span class=title>« Prev</span><br><span>VGG GoogLeNet ResNet</span></a>
<a class=next href=https://kylestones.github.io/hugo-blog/blog/machinelearning/guess/><span class=title>Next »</span><br><span>乱想</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share YOLO 实现细节 on twitter" href="https://twitter.com/intent/tweet/?text=YOLO%20%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82&url=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fmachinelearning%2fyolo%2f&hashtags=%e7%9b%ae%e6%a0%87%e6%a3%80%e6%b5%8b%2c%2c%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share YOLO 实现细节 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fmachinelearning%2fyolo%2f&title=YOLO%20%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82&summary=YOLO%20%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82&source=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fmachinelearning%2fyolo%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share YOLO 实现细节 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fmachinelearning%2fyolo%2f&title=YOLO%20%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share YOLO 实现细节 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fmachinelearning%2fyolo%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share YOLO 实现细节 on whatsapp" href="https://api.whatsapp.com/send?text=YOLO%20%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82%20-%20https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fmachinelearning%2fyolo%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z" /></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share YOLO 实现细节 on telegram" href="https://telegram.me/share/url?text=YOLO%20%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82&url=https%3a%2f%2fkylestones.github.io%2fhugo-blog%2fblog%2fmachinelearning%2fyolo%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z" /></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://kylestones.github.io/hugo-blog>Org Mode</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z" /></svg></a><script>let menu=document.getElementById('menu')
if(menu){menu.scrollLeft=localStorage.getItem("menu-scroll-position");menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft);}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>