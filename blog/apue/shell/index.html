<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>shell | Org Mode</title><meta name=keywords content="shell"><meta name=description content="ssh 隧道 top vmstat iostat ps tar grep sort # -u 重复关键字只保留第一个 # -k 知道排序字段（开始,结束）和类型，可通过 info sort 具体查看 # 2n,2 表示安装第二个字段，以数字顺序排序。默认安装字段顺序 # 1rn,1 表示按照数字逆序排序 sort -u -k 2n,2 file | sort -k 1rn,1 -k 3,3 sed sed 全名叫 stream editor，流编辑器（非交互）。sed 基本上就是玩正则模式 匹配。sed 比 awk 大 2-3 岁。
基本语法 $ sed options file # 并不修改文件，只将处理的结果打印出来 $ sed -e 's/hello/Hello/g' filename # 使用 -i 将直接修改文件 $ sed -i 's/^/# /g' filename # 同时处理多条语句 $ sed -e '2,5s/hello/Hello/; s/world/(&)/g' filename $ sed -e '1,3s/hello/Hello/3' -e '3,$s/world/World/3g' filename # 读取 sed 脚本处理文件 $ more rep."><meta name=author content="Kyle Three Stones"><link rel=canonical href=https://kylestones.github.io/blog/apue/shell/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="shell"><meta property="og:description" content="ssh 隧道 top vmstat iostat ps tar grep sort # -u 重复关键字只保留第一个 # -k 知道排序字段（开始,结束）和类型，可通过 info sort 具体查看 # 2n,2 表示安装第二个字段，以数字顺序排序。默认安装字段顺序 # 1rn,1 表示按照数字逆序排序 sort -u -k 2n,2 file | sort -k 1rn,1 -k 3,3 sed sed 全名叫 stream editor，流编辑器（非交互）。sed 基本上就是玩正则模式 匹配。sed 比 awk 大 2-3 岁。
基本语法 $ sed options file # 并不修改文件，只将处理的结果打印出来 $ sed -e 's/hello/Hello/g' filename # 使用 -i 将直接修改文件 $ sed -i 's/^/# /g' filename # 同时处理多条语句 $ sed -e '2,5s/hello/Hello/; s/world/(&)/g' filename $ sed -e '1,3s/hello/Hello/3' -e '3,$s/world/World/3g' filename # 读取 sed 脚本处理文件 $ more rep."><meta property="og:type" content="article"><meta property="og:url" content="https://kylestones.github.io/blog/apue/shell/"><meta property="og:image" content="https://kylestones.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-01-31T00:00:00+00:00"><meta property="article:modified_time" content="2019-01-31T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kylestones.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="shell"><meta name=twitter:description content="ssh 隧道 top vmstat iostat ps tar grep sort # -u 重复关键字只保留第一个 # -k 知道排序字段（开始,结束）和类型，可通过 info sort 具体查看 # 2n,2 表示安装第二个字段，以数字顺序排序。默认安装字段顺序 # 1rn,1 表示按照数字逆序排序 sort -u -k 2n,2 file | sort -k 1rn,1 -k 3,3 sed sed 全名叫 stream editor，流编辑器（非交互）。sed 基本上就是玩正则模式 匹配。sed 比 awk 大 2-3 岁。
基本语法 $ sed options file # 并不修改文件，只将处理的结果打印出来 $ sed -e 's/hello/Hello/g' filename # 使用 -i 将直接修改文件 $ sed -i 's/^/# /g' filename # 同时处理多条语句 $ sed -e '2,5s/hello/Hello/; s/world/(&)/g' filename $ sed -e '1,3s/hello/Hello/3' -e '3,$s/world/World/3g' filename # 读取 sed 脚本处理文件 $ more rep."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://kylestones.github.io/blog/"},{"@type":"ListItem","position":3,"name":"shell","item":"https://kylestones.github.io/blog/apue/shell/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"shell","name":"shell","description":"ssh 隧道 top vmstat iostat ps tar grep sort # -u 重复关键字只保留第一个 # -k 知道排序字段（开始,结束）和类型，可通过 info sort 具体查看 # 2n,2 表示安装第二个字段，以数字顺序排序。默认安装字段顺序 # 1rn,1 表示按照数字逆序排序 sort -u -k 2n,2 file | sort -k 1rn,1 -k 3,3 sed sed 全名叫 stream editor，流编辑器（非交互）。sed 基本上就是玩正则模式 匹配。sed 比 awk 大 2-3 岁。\n基本语法 $ sed options file # 并不修改文件，只将处理的结果打印出来 $ sed -e \u0026#39;s/hello/Hello/g\u0026#39; filename # 使用 -i 将直接修改文件 $ sed -i \u0026#39;s/^/# /g\u0026#39; filename # 同时处理多条语句 $ sed -e \u0026#39;2,5s/hello/Hello/; s/world/(\u0026amp;)/g\u0026#39; filename $ sed -e \u0026#39;1,3s/hello/Hello/3\u0026#39; -e \u0026#39;3,$s/world/World/3g\u0026#39; filename # 读取 sed 脚本处理文件 $ more rep.","keywords":["shell"],"articleBody":" ssh 隧道 top vmstat iostat ps tar grep sort # -u 重复关键字只保留第一个 # -k 知道排序字段（开始,结束）和类型，可通过 info sort 具体查看 # 2n,2 表示安装第二个字段，以数字顺序排序。默认安装字段顺序 # 1rn,1 表示按照数字逆序排序 sort -u -k 2n,2 file | sort -k 1rn,1 -k 3,3 sed sed 全名叫 stream editor，流编辑器（非交互）。sed 基本上就是玩正则模式 匹配。sed 比 awk 大 2-3 岁。\n基本语法 $ sed options file # 并不修改文件，只将处理的结果打印出来 $ sed -e 's/hello/Hello/g' filename # 使用 -i 将直接修改文件 $ sed -i 's/^/# /g' filename # 同时处理多条语句 $ sed -e '2,5s/hello/Hello/; s/world/(\u0026)/g' filename $ sed -e '1,3s/hello/Hello/3' -e '3,$s/world/World/3g' filename # 读取 sed 脚本处理文件 $ more rep.sed s/hello/Hello/ s/world/World/ $ sed -f rep.sed filename # 打印行号 $ sed '=' filename 匹配 可以将被匹配的值，作为变量使用\n# \u0026 表示被匹配的值。实现在被匹配的值两侧加上 [ ] $ sed 's/hello/[\u0026]/g' filename # 使用圆括号(需要转义)括起来的正则表达式所匹配的字符串可以当成变量来使用 # \\1, \\2, ... 分别表示第一个、第二个变量 $ sed 's/hello \\([a-z]*\\\u003e\\) .* \\([^,\u0026\u003e]*\\)/\\1,\\2/g' filename 多行处理 # N 把下一行内容放入缓冲区 # 相当于把连续两行拼接成一行，来执行命令 $ sed 'N;s/hello/Hello/' filename # [起始地址[,结束地址]]{命令} # 地址可以使用行号，字符串匹配，相对地址 $ sed '1,3s/^/# /' filename $ sed '/function/s/$/:/' filename $ sed '/define/,+3s/^/# /' filename $ sed '/boo/,/foo/s/^/# /' filename $ sed '3,/foo/s/^/# /' filename 字符替换 y # 替换 1 -\u003e 4, 2 -\u003e 5, 3 -\u003e 6 $ sed 'y/123/456/' filename 字符串替换 s # 将每一行的第 1 个 hello 替换成 Hello $ sed -e 's/hello/Hello/' filename # 将每一行的第 2 个 hello 替换成 Hello $ sed -e 's/hello/Hello/2' filename # ERROR ：将每一行的第 2-5 个 hello 替换成 Hello # 可以使用两次到最后的替换来代替，先 2g 替换，然后 5g 替换回来 # sed -e 's/hello/Hello/2,5' filename # 将一行中所有的 hello 都替换成 Hello $ sed -e 's/hello/Hello/g' filename # 将每一行的第 2 个之后的 hello 替换成 Hello $ sed -e 's/hello/Hello/2g' filename # 只处理第 2 行 $ sed -e '2s/hello/Hello/' filename # 只处理第 2 行到第 5 行 $ sed -e '2,5s/hello/Hello/' filename # 只处理第 2 行之后的 $ sed -e '2,$s/hello/Hello/; s/world/World/g' filename # 使用 -i 将直接修改文件 # 每一行前面加上 # $ sed -i 's/^/#/g' filename # 每一行行尾加上 ; $ sed -i 's/$/;/g' filename 插入行 i 在匹配的行前面插入一行 insert\n$ sed '3 i insert new line' filename $ sed '/funtion/i a new function' filename 追加行 a 在匹配行后面添加一行 append\n$ sed '3 a append a new line' filename $ sed '/function/a the content of the function' filename 替换行 c 替换匹配行的内容 change $ sed '3 c the content been changed' filename $ sed '/foo/c new life' filename 删除行 d 删除匹配行 delete\n$ sed '/foo/d' filename $ sed '3,5d' filename $ sed '1d' filename $ sed -i '1,$d' filename 打印 p 打印匹配的行 print\n# sed 会把所有处理的内容输出，使用 n 将只打印匹配的行 $ sed -n '/foo/p' filename # 和 grep 功能一致 命令规范 绝大多数命令都符合\n# 规范 [address[,address]][!]{cmd} # address 可以是行号，也可以是一个模式 # 使用逗号分隔两个 address ，表示一个区间 # 加上 ! 表示匹配后不执行命令 $ sed '1!d' filename $ sed '1,3d' filename $ sed '1,/foo/d' filename $ sed '/foo/,5d' filename $ sed '/foo/,/boo/d' filename $ sed '3,+5d' filename $ sed '/foo/,+3!d' filename # cmd 可以是多个，使用分号分开 # 可以使用大括号扩起来作为嵌套命令 # 3-5 行执行 /foo/d 命令 $ sed '3,5 {/foo/d}' filename # 删除匹配 foo 的行，去掉行尾空格 $ sed '1,$ {/foo/d; s/$ *//g}' filename # 3-5 行，匹配 foo ，然后匹配 bar ，完全匹配再执行 delete 命令 $ sed '3,5 {/foo/{/bar/d}}' filename patten space - hold space pattern space 就是模式空间，处理每一行开始之前， sed 都会把该行的内容 放入 pattern space 。同时处理完成后，把结果放入 pattern space 。也就是 说所有命令 s,i,a,d, 都是在操作 pattern space 。\nhold space 就是可以保留一些内容的空间，可以通过一些操作将 pattern space 和 hold space 的内容相互追加、替换、交换。\nsed 处理过程的伪代码\nforeach line in file { //放入把行Pattern_Space Pattern_Space \u003c= line; // 对每个pattern space执行sed命令 Pattern_Space \u003c= EXEC(sed_cmd, Pattern_Space); // 如果没有指定 -n 则输出处理后的Pattern_Space if (sed option hasn't \"-n\") { print Pattern_Space } } g 将 hold space 中的内容拷贝到 pattern space 中，原来 pattern space 里的内容清除 G 将 hold space 中的内容 append 到 pattern space\\n 后 h 将 pattern space 中的内容拷贝到 hold space 中，原来的 hold space 里的内容被清除 H 将 pattern space 中的内容 append 到 hold space\\n 后 x 交换 pattern space 和 hold space 的内容 $ more num 1 2 3 $ sed \"H;g\" num 1 1 2 1 2 3 $ sed -n \"H;g\" num # 上面命令没有任何输出 # 把文件逆序输出 $ sed '1!G;h;$!d' num # 1!G 除第一行外执行 G 命令 # h 所有行执行 h 命令 # $!d 除最后一行外执行 d 命令 参考 sed 简明教程 31+ Examples for sed Linux Command in Text Manipulation awk AWK 是贝尔实验室 1977 年搞出来的文本处理神器，其名字取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字 符。《The AWK Programming Language》 是介绍 AWK 的一本相当经典的书。\n感觉： 始终记住 AWK 的语法和 C 语言很像很像。\n基本语法 $ awk options file # option 表示操作字段，file 表示待处理的文件，可以同时接多个文件，缺省使用标准输入 # 类似 sed ， awk 一次处理一行数据 options 选项\n-F fs 指定文件分隔符 -f file 指定包含 awk 脚本的文件 -v var=value 声明一个变量 打印输出 # 处理标准输入，无论输入什么，都会打印 Welcome to awk world! # 使用 C-d 结束 $ awk '{print \"Welcome to awk world!\"}' # 打印双引号需要使用斜杠转义， # 打印单引号除了要转义，还需要在外面额外增加一对单引号 $ awk '{print \"Hello World! \\\" '\\''\"}' $ awk '{print $1}' file # 默认使用空白字符作为分隔符 $ awk -F: '{print $1}' /etc/passwd # 指定 : 作为分隔符 # 将打印 Hello kyle ；多条语句的使用使用分号分割 $ echo \"Hello Adam\" | awk '{$2=\"kyle\"; print $0}' # 格式化输出 $ awk '{printf \"%c %d %8e %-8f %-22o %-15s\\n\",$1,$2,$3,$4,$5,$6}' filename # e 将数字以科学计数法输出 内建变量 $0 当前记录 record （整行） $n 当前记录的第 n 个字段 (n != 0) FS 记录中不同字段的分隔符；默认空格或 Tab OFS 输出字段分隔符，默认空格 NF 当前记录中字段的总个数，列数 RS record 的分割符，默认换行符 ORS 输出记录的分隔符，默认换行符 NR 已经读出的 record 的个数，即行数；多个文件的时候，这个值不断累加 FNR 当前文件已经读出的 record 个数，多个文件时，相互独立计数 FILENAME 当前输入文件的名字 ARGC 接收到参数的个数 ARGV 参数 ENVIRON 环境变量数组 IGNORECASE 忽略大小写 FIELDWIDTHS 指定 filed 的宽度，代替分隔符；BEGIN{FIELDWIDTHS=\"4 4 10\"} length 记录的长度，可以找到文件长度大于某一值得记录 # 可以直接重定向到变量名，将生成变量名对应的文件 $ awk 'NR!=1{print $4,$5 \u003e $6}' filename # 分隔符默认为空白字符，可以使用 FS 修改 $ awk -F: '{print $1,$3,$NF}' /etc/passwd $ awk 'BEGIN{FS=\":\"} {print $1,$3,$NR,$FNR}' /etc/passwd # 同时指定多个分隔符 $ awk -F '[:;,]' '{print $1,$3,$6}' /etc/passwd $ awk 'BEGIN{FS=\"[:;,]\"} {print $1,$3,$6}' /etc/passwd $ awk 'BEGIN{FS=\":\"; OFS=\"-\"} {print $1,$6,$7}' /etc/passwd # filed 分隔符设置成换行符；RS=\"\" 将 record 分隔符设置成空行 $ awk 'BEGIN{FS=\"\\n\"; RS=\"\"} {print $1,$3}' addresses # 指定 filed 的宽度来分割，不需要分隔符 $ awk 'BEGIN{FIELDWIDTHS=\"3 4 3\"}{print $1,$2,$3}' filename # 可以看到 FNR 一个文件内处理的行数； NR 表示处理所有文件的总行数 $ awk '{print $1,\"FNR=\"FNR,\"NR=\"NR} END{print \"Total\",NR,\"processed lines\"}' filename filename $ awk 'BEGIN{print ARGC,ARGV[1],ENVIRON[\"PATH\"]}' myfile # 输出长度大于 80 的行 $ awk 'length\u003e80' file 自定义变量 # home 变量取值的时候不能写成 $home TODO $ awk -v home=$HOME '{print \"home is\" home}' file $ awk 'BEGIN{test=\"Hello World\"} {print test}' file $ awk '{sum+=$5} END {print sum}' filename # 除了第一行，以 $6 作为字典的索引，值为自加的次数 $ awk 'NR!=1{a[$6]++;} END {for (i in a) print i \", \" a[i];}' file # 查看每个用户的主流内存 ps aux | awk 'NR!=1{a[$1]+=$6;} END { for(i in a) print i \", \" a[i]/1024\"M\";}' 正则表达式匹配 awk 可以依据指定的字符串，只处理需要的行\n# 其中 ~ 表示模式开始， / /中间是模式。 $ awk '$6 ~ /hello/ || NR==1 {print NR,$4,$6}' OFS=\"\\t\" filename # 使用 “/cat|dog/” 来匹配 FIN 或者 TIME $ awk '$6 ~ /cat|dog/ || NR==1 {print NR,$4,$6}' OFS=\"\\t\" filename # awk 可以像 grep 一样的去匹配某一行 $ awk '/LISTEN/' filename # 模式取反 $ awk '$6 !~ /cat/ || NR==1 {print NR,$4,$6}' OFS=\"\\t\" filename $ awk '!/cat/' filename 运算符 # 比较运算符支持 \u003e, \u003c, ==, \u003e=, \u003c=, != # 这些比较运算可以直接与字符串进行比较 $ awk '$1==\"book\" \u0026\u0026 $3\u003e100' filename # 逻辑运算符 \u0026\u0026, ||, ! # 保留表头，这里的比较逻辑顺序？TODO $ awk '$1==\"cat\" \u0026\u0026 $3\u003c1000 || NR==1 {printf \"%-10s %5d\", $1,$3' filename awk 脚本 可以将 awk 脚本写入一个文件，然后执行这个文件\n$ cat awkfile.awk #!/bin/awk -f { text = $1 \"home at \" $6 print text } $ awk -F: -f awkfile.awk /etc/passwd # 添加可执行权限，可以如下允许，当然这里没有处理分隔符 ./awkfile.awk /etc/passwd BEGIN-END 希望在执行脚本处理之前或者之后进行一些特殊处理，BEGIN 和 END 可以满足 需求\nBEGIN{处理文本前执行的语句} {处理每一行的语句} END{处理完成后执行的语句} # 可以在 BEGIN 中修改分隔符、增加表头 $ awk 'BEGIN {FS=\":\"; print \"It is passwd file\"} {print $0} END {print \"The End\"}' /etc/passwd # 还可以在处理完脚本之后，进行一些统计处理 $ awk '{sum+=$1} END {printf \"sum=%d, avg=%f\", sum, sum/NR}' filename 控制-循环语句 格式和 C 语言完全一样\n# if $ awk '{if ($1 \u003e 10) print $1}' filename # if - else if - else # 一行中有多个语句的时候，使用分号分开 $ awk '{ if ($1 \u003e 10) { x = $1 * 9 print x } else if ($1 \u003e 5) { x = $1 *3 print x } else { x = $1 / 2 print x } }' filename # for loop $ awk '{ total=0 for (i=0; i\u003c3; i++) { total += i } avg=total/3 printf \"Avg: %f\", avg }' filename # while loop $ awk '{ total=0 i=0 while (i \u003c 5) { total += i if (i == 3) break i++ } printf \"total=%d\\n\", total }' filename 内建函数 可以通过 man 查看\n数学函数 sin(x), cos(x), exp(x), log(x), sqrt(x), rand() 字符串函数 toupper(), asort, gensub, index, length, match, split 自定义函数 使用关键字 function 自定义函数\n$ awk ' function myfun() { printf \"user %s in home %s\\n\", $1,$6 } BEGIN{FS=\":\"} { myfun() }' /etc/passwd 参考 AWK 简明教程 30 Examples for Awk Command in Text Processing strace pstack perf ","wordCount":"1342","inLanguage":"en","datePublished":"2019-01-31T00:00:00Z","dateModified":"2019-01-31T00:00:00Z","author":{"@type":"Person","name":"Kyle Three Stones"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kylestones.github.io/blog/apue/shell/"},"publisher":{"@type":"Organization","name":"Org Mode","logo":{"@type":"ImageObject","url":"https://kylestones.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kylestones.github.io accesskey=h title="Home (Alt + H)"><img src=https://kylestones.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kylestones.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://kylestones.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kylestones.github.io>Home</a>&nbsp;»&nbsp;<a href=https://kylestones.github.io/blog/>Blogs</a></div><h1 class=post-title>shell</h1><div class=post-meta><span title='2019-01-31 00:00:00 +0000 UTC'>January 31, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1342 words&nbsp;·&nbsp;Kyle Three Stones&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/blog/apue/shell.org rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><div id=outline-container-headline-1 class=outline-3><h3 id=headline-1>ssh</h3><div id=outline-text-headline-1 class=outline-text-3><div id=outline-container-headline-2 class=outline-4><h4 id=headline-2>隧道</h4></div></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>top</h3></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>vmstat</h3></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>iostat</h3></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>ps</h3></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>tar</h3></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>grep</h3></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>sort</h3><div id=outline-text-headline-9 class=outline-text-3><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># -u 重复关键字只保留第一个</span>
</span></span><span class=line><span class=cl><span class=c1># -k 知道排序字段（开始,结束）和类型，可通过 info sort 具体查看</span>
</span></span><span class=line><span class=cl><span class=c1># 2n,2 表示安装第二个字段，以数字顺序排序。默认安装字段顺序</span>
</span></span><span class=line><span class=cl><span class=c1># 1rn,1 表示按照数字逆序排序</span>
</span></span><span class=line><span class=cl>sort -u -k 2n,2 file <span class=p>|</span> sort  -k 1rn,1 -k 3,3</span></span></code></pre></div></div></div></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>sed</h3><div id=outline-text-headline-10 class=outline-text-3><p>sed 全名叫 stream editor，流编辑器（非交互）。sed 基本上就是玩正则模式
匹配。sed 比 awk 大 2-3 岁。</p><div id=outline-container-headline-11 class=outline-4><h4 id=headline-11>基本语法</h4><div id=outline-text-headline-11 class=outline-text-4><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sed options file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 并不修改文件，只将处理的结果打印出来</span>
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;s/hello/Hello/g&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 -i 将直接修改文件</span>
</span></span><span class=line><span class=cl>$ sed -i <span class=s1>&#39;s/^/# /g&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 同时处理多条语句</span>
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;2,5s/hello/Hello/; s/world/(&amp;)/g&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;1,3s/hello/Hello/3&#39;</span> -e <span class=s1>&#39;3,$s/world/World/3g&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 读取 sed 脚本处理文件</span>
</span></span><span class=line><span class=cl>$ more rep.sed
</span></span><span class=line><span class=cl>s/hello/Hello/
</span></span><span class=line><span class=cl>s/world/World/
</span></span><span class=line><span class=cl>$ sed -f rep.sed filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 打印行号</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;=&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-12 class=outline-4><h4 id=headline-12>匹配</h4><div id=outline-text-headline-12 class=outline-text-4><p>可以将被匹配的值，作为变量使用</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># &amp; 表示被匹配的值。实现在被匹配的值两侧加上 [ ]</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;s/hello/[&amp;]/g&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用圆括号(需要转义)括起来的正则表达式所匹配的字符串可以当成变量来使用</span>
</span></span><span class=line><span class=cl><span class=c1># \1, \2, ... 分别表示第一个、第二个变量</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;s/hello \([a-z]*\&gt;\) .* \([^,&amp;&gt;]*\)/\1,\2/g&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-13 class=outline-4><h4 id=headline-13>多行处理</h4><div id=outline-text-headline-13 class=outline-text-4><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># N 把下一行内容放入缓冲区</span>
</span></span><span class=line><span class=cl><span class=c1># 相当于把连续两行拼接成一行，来执行命令</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;N;s/hello/Hello/&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># [起始地址[,结束地址]]{命令}</span>
</span></span><span class=line><span class=cl><span class=c1># 地址可以使用行号，字符串匹配，相对地址</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;1,3s/^/# /&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;/function/s/$/:/&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;/define/,+3s/^/# /&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;/boo/,/foo/s/^/# /&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;3,/foo/s/^/# /&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-14 class=outline-4><h4 id=headline-14>字符替换 y</h4><div id=outline-text-headline-14 class=outline-text-4><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 替换 1 -&gt; 4, 2 -&gt; 5, 3 -&gt; 6</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;y/123/456/&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-15 class=outline-4><h4 id=headline-15>字符串替换 s</h4><div id=outline-text-headline-15 class=outline-text-4><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 将每一行的第 1 个 hello 替换成 Hello</span>
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;s/hello/Hello/&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 将每一行的第 2 个 hello 替换成 Hello</span>
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;s/hello/Hello/2&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># ERROR ：将每一行的第 2-5 个 hello 替换成 Hello</span>
</span></span><span class=line><span class=cl><span class=c1># 可以使用两次到最后的替换来代替，先 2g 替换，然后 5g 替换回来</span>
</span></span><span class=line><span class=cl><span class=c1># sed -e &#39;s/hello/Hello/2,5&#39; filename</span>
</span></span><span class=line><span class=cl><span class=c1># 将一行中所有的 hello 都替换成 Hello</span>
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;s/hello/Hello/g&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 将每一行的第 2 个之后的 hello 替换成 Hello</span>
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;s/hello/Hello/2g&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 只处理第 2 行</span>
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;2s/hello/Hello/&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 只处理第 2 行到第 5 行</span>
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;2,5s/hello/Hello/&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 只处理第 2 行之后的</span>
</span></span><span class=line><span class=cl>$ sed -e <span class=s1>&#39;2,$s/hello/Hello/; s/world/World/g&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用 -i 将直接修改文件</span>
</span></span><span class=line><span class=cl><span class=c1># 每一行前面加上 # </span>
</span></span><span class=line><span class=cl>$ sed -i <span class=s1>&#39;s/^/#/g&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 每一行行尾加上 ;</span>
</span></span><span class=line><span class=cl>$ sed -i <span class=s1>&#39;s/$/;/g&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-16 class=outline-4><h4 id=headline-16>插入行 i</h4><div id=outline-text-headline-16 class=outline-text-4><p>在匹配的行前面插入一行 insert</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sed <span class=s1>&#39;3 i insert new line&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;/funtion/i a new function&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-17 class=outline-4><h4 id=headline-17>追加行 a</h4><div id=outline-text-headline-17 class=outline-text-4><p>在匹配行后面添加一行 append</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sed <span class=s1>&#39;3 a append a new line&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;/function/a the content of the function&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-18 class=outline-4><h4 id=headline-18>替换行 c</h4><div id=outline-text-headline-18 class=outline-text-4><p>替换匹配行的内容 change</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sed <span class=s1>&#39;3 c the content been changed&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;/foo/c new life&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-19 class=outline-4><h4 id=headline-19>删除行 d</h4><div id=outline-text-headline-19 class=outline-text-4><p>删除匹配行 delete</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ sed <span class=s1>&#39;/foo/d&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;3,5d&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;1d&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed -i <span class=s1>&#39;1,$d&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-20 class=outline-4><h4 id=headline-20>打印 p</h4><div id=outline-text-headline-20 class=outline-text-4><p>打印匹配的行 print</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># sed 会把所有处理的内容输出，使用 n 将只打印匹配的行</span>
</span></span><span class=line><span class=cl>$ sed -n <span class=s1>&#39;/foo/p&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 和 grep 功能一致</span></span></span></code></pre></div></div></div></div><div id=outline-container-headline-21 class=outline-4><h4 id=headline-21>命令规范</h4><div id=outline-text-headline-21 class=outline-text-4><p>绝大多数命令都符合</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 规范 [address[,address]][!]{cmd}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># address 可以是行号，也可以是一个模式</span>
</span></span><span class=line><span class=cl><span class=c1># 使用逗号分隔两个 address ，表示一个区间</span>
</span></span><span class=line><span class=cl><span class=c1># 加上 ! 表示匹配后不执行命令</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;1!d&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;1,3d&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;1,/foo/d&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;/foo/,5d&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;/foo/,/boo/d&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;3,+5d&#39;</span> filename
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;/foo/,+3!d&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># cmd 可以是多个，使用分号分开</span>
</span></span><span class=line><span class=cl><span class=c1># 可以使用大括号扩起来作为嵌套命令</span>
</span></span><span class=line><span class=cl><span class=c1># 3-5 行执行 /foo/d 命令</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;3,5 {/foo/d}&#39;</span> filename 
</span></span><span class=line><span class=cl><span class=c1># 删除匹配 foo 的行，去掉行尾空格</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;1,$ {/foo/d; s/$ *//g}&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 3-5 行，匹配 foo ，然后匹配 bar ，完全匹配再执行 delete 命令</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;3,5 {/foo/{/bar/d}}&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-22 class=outline-4><h4 id=headline-22>patten space - hold space</h4><div id=outline-text-headline-22 class=outline-text-4><p>pattern space 就是模式空间，处理每一行开始之前， sed 都会把该行的内容
放入 pattern space 。同时处理完成后，把结果放入 pattern space 。也就是
说所有命令 s,i,a,d, 都是在操作 pattern space 。</p><p>hold space 就是可以保留一些内容的空间，可以通过一些操作将 pattern
space 和 hold space 的内容相互追加、替换、交换。</p><p>sed 处理过程的伪代码</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>foreach line in file <span class=o>{</span>
</span></span><span class=line><span class=cl>    //放入把行Pattern_Space
</span></span><span class=line><span class=cl>    Pattern_Space &lt;<span class=o>=</span> line<span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    // 对每个pattern space执行sed命令
</span></span><span class=line><span class=cl>    Pattern_Space &lt;<span class=o>=</span> EXEC<span class=o>(</span>sed_cmd, Pattern_Space<span class=o>)</span><span class=p>;</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>    // 如果没有指定 -n 则输出处理后的Pattern_Space
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span>sed option hasn<span class=err>&#39;</span>t <span class=s2>&#34;-n&#34;</span><span class=o>)</span>  <span class=o>{</span>
</span></span><span class=line><span class=cl>       print Pattern_Space
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>   <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span></span></span></code></pre></div></div><dl><dt>g</dt><dd>将 hold space 中的内容拷贝到 pattern space 中，原来 pattern
space 里的内容清除</dd><dt>G</dt><dd>将 hold space 中的内容 append 到 pattern space\n 后</dd><dt>h</dt><dd>将 pattern space 中的内容拷贝到 hold space 中，原来的 hold
space 里的内容被清除</dd><dt>H</dt><dd>将 pattern space 中的内容 append 到 hold space\n 后</dd><dt>x</dt><dd>交换 pattern space 和 hold space 的内容</dd></dl><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ more num
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=m>2</span>
</span></span><span class=line><span class=cl><span class=m>3</span>
</span></span><span class=line><span class=cl>$ sed <span class=s2>&#34;H;g&#34;</span> num
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=m>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=m>2</span>
</span></span><span class=line><span class=cl><span class=m>3</span>
</span></span><span class=line><span class=cl>$ sed -n <span class=s2>&#34;H;g&#34;</span> num
</span></span><span class=line><span class=cl><span class=c1># 上面命令没有任何输出</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 把文件逆序输出</span>
</span></span><span class=line><span class=cl>$ sed <span class=s1>&#39;1!G;h;$!d&#39;</span> num
</span></span><span class=line><span class=cl><span class=c1># 1!G 除第一行外执行 G 命令</span>
</span></span><span class=line><span class=cl><span class=c1># h 所有行执行 h 命令</span>
</span></span><span class=line><span class=cl><span class=c1># $!d 除最后一行外执行 d 命令</span></span></span></code></pre></div></div></div></div><div id=outline-container-headline-23 class=outline-4><h4 id=headline-23>参考</h4><div id=outline-text-headline-23 class=outline-text-4><ol><li><a href=https://coolshell.cn/articles/9104.html>sed 简明教程</a></li><li><a href=https://likegeeks.com/sed-linux/>31+ Examples for sed Linux Command in Text Manipulation</a></li></ol></div></div></div></div><div id=outline-container-headline-24 class=outline-3><h3 id=headline-24>awk</h3><div id=outline-text-headline-24 class=outline-text-3><p>AWK 是贝尔实验室 1977 年搞出来的文本处理神器，其名字取了三位创始人
Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字
符。《The AWK Programming Language》 是介绍 AWK 的一本相当经典的书。</p><p>感觉： <strong>始终记住 AWK 的语法和 C 语言很像很像。</strong></p><div id=outline-container-headline-25 class=outline-4><h4 id=headline-25>基本语法</h4><div id=outline-text-headline-25 class=outline-text-4><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ awk options file
</span></span><span class=line><span class=cl><span class=c1># option 表示操作字段，file 表示待处理的文件，可以同时接多个文件，缺省使用标准输入</span>
</span></span><span class=line><span class=cl><span class=c1># 类似 sed ， awk 一次处理一行数据</span></span></span></code></pre></div></div><p>options 选项</p><ol><li>-F fs 指定文件分隔符</li><li>-f file 指定包含 awk 脚本的文件</li><li>-v var=value 声明一个变量</li></ol></div></div><div id=outline-container-headline-26 class=outline-4><h4 id=headline-26>打印输出</h4><div id=outline-text-headline-26 class=outline-text-4><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 处理标准输入，无论输入什么，都会打印 Welcome to awk world!</span>
</span></span><span class=line><span class=cl><span class=c1># 使用 C-d 结束</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{print &#34;Welcome to awk world!&#34;}&#39;</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 打印双引号需要使用斜杠转义，</span>
</span></span><span class=line><span class=cl><span class=c1># 打印单引号除了要转义，还需要在外面额外增加一对单引号</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{print &#34;Hello World! \&#34; &#39;</span><span class=se>\&#39;</span><span class=s1>&#39;&#34;}&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{print $1}&#39;</span> file <span class=c1># 默认使用空白字符作为分隔符</span>
</span></span><span class=line><span class=cl>$ awk -F: <span class=s1>&#39;{print $1}&#39;</span> /etc/passwd <span class=c1># 指定 : 作为分隔符</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 将打印 Hello kyle ；多条语句的使用使用分号分割</span>
</span></span><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=s2>&#34;Hello Adam&#34;</span> <span class=p>|</span> awk <span class=s1>&#39;{$2=&#34;kyle&#34;; print $0}&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 格式化输出</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{printf &#34;%c %d %8e %-8f %-22o %-15s\n&#34;,$1,$2,$3,$4,$5,$6}&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># e 将数字以科学计数法输出</span></span></span></code></pre></div></div></div></div><div id=outline-container-headline-27 class=outline-4><h4 id=headline-27>内建变量</h4><div id=outline-text-headline-27 class=outline-text-4><table><tbody><tr><td>$0</td><td>当前记录 record （整行）</td></tr><tr><td>$n</td><td>当前记录的第 n 个字段 (n != 0)</td></tr><tr><td>FS</td><td>记录中不同字段的分隔符；默认空格或 Tab</td></tr><tr><td>OFS</td><td>输出字段分隔符，默认空格</td></tr><tr><td>NF</td><td>当前记录中字段的总个数，列数</td></tr><tr><td>RS</td><td>record 的分割符，默认换行符</td></tr><tr><td>ORS</td><td>输出记录的分隔符，默认换行符</td></tr><tr><td>NR</td><td>已经读出的 record 的个数，即行数；多个文件的时候，这个值不断累加</td></tr><tr><td>FNR</td><td>当前文件已经读出的 record 个数，多个文件时，相互独立计数</td></tr><tr><td>FILENAME</td><td>当前输入文件的名字</td></tr><tr><td>ARGC</td><td>接收到参数的个数</td></tr><tr><td>ARGV</td><td>参数</td></tr><tr><td>ENVIRON</td><td>环境变量数组</td></tr><tr><td>IGNORECASE</td><td>忽略大小写</td></tr><tr><td>FIELDWIDTHS</td><td>指定 filed 的宽度，代替分隔符；BEGIN{FIELDWIDTHS="4 4 10"}</td></tr><tr><td>length</td><td>记录的长度，可以找到文件长度大于某一值得记录</td></tr></tbody></table><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 可以直接重定向到变量名，将生成变量名对应的文件</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;NR!=1{print $4,$5 &gt; $6}&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 分隔符默认为空白字符，可以使用 FS 修改</span>
</span></span><span class=line><span class=cl>$ awk  -F: <span class=s1>&#39;{print $1,$3,$NF}&#39;</span> /etc/passwd
</span></span><span class=line><span class=cl>$ awk  <span class=s1>&#39;BEGIN{FS=&#34;:&#34;} {print $1,$3,$NR,$FNR}&#39;</span> /etc/passwd
</span></span><span class=line><span class=cl><span class=c1># 同时指定多个分隔符</span>
</span></span><span class=line><span class=cl>$ awk  -F <span class=s1>&#39;[:;,]&#39;</span> <span class=s1>&#39;{print $1,$3,$6}&#39;</span> /etc/passwd
</span></span><span class=line><span class=cl>$ awk  <span class=s1>&#39;BEGIN{FS=&#34;[:;,]&#34;} {print $1,$3,$6}&#39;</span> /etc/passwd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;BEGIN{FS=&#34;:&#34;; OFS=&#34;-&#34;} {print $1,$6,$7}&#39;</span> /etc/passwd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># filed 分隔符设置成换行符；RS=&#34;&#34; 将 record 分隔符设置成空行</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;BEGIN{FS=&#34;\n&#34;; RS=&#34;&#34;} {print $1,$3}&#39;</span> addresses
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定 filed 的宽度来分割，不需要分隔符</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;BEGIN{FIELDWIDTHS=&#34;3 4 3&#34;}{print $1,$2,$3}&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 可以看到 FNR 一个文件内处理的行数； NR 表示处理所有文件的总行数</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{print $1,&#34;FNR=&#34;FNR,&#34;NR=&#34;NR} END{print &#34;Total&#34;,NR,&#34;processed lines&#34;}&#39;</span> filename filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;BEGIN{print ARGC,ARGV[1],ENVIRON[&#34;PATH&#34;]}&#39;</span> myfile
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 输出长度大于 80 的行</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;length&gt;80&#39;</span> file</span></span></code></pre></div></div></div></div><div id=outline-container-headline-28 class=outline-4><h4 id=headline-28>自定义变量</h4><div id=outline-text-headline-28 class=outline-text-4><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># home 变量取值的时候不能写成 $home TODO</span>
</span></span><span class=line><span class=cl>$ awk -v <span class=nv>home</span><span class=o>=</span><span class=nv>$HOME</span> <span class=s1>&#39;{print &#34;home is&#34; home}&#39;</span> file
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;BEGIN{test=&#34;Hello World&#34;} {print test}&#39;</span> file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{sum+=$5} END {print sum}&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 除了第一行，以 $6 作为字典的索引，值为自加的次数</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;NR!=1{a[$6]++;} END {for (i in a) print i &#34;, &#34; a[i];}&#39;</span> file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 查看每个用户的主流内存</span>
</span></span><span class=line><span class=cl>ps aux <span class=p>|</span> awk <span class=s1>&#39;NR!=1{a[$1]+=$6;} END { for(i in a) print i &#34;, &#34; a[i]/1024&#34;M&#34;;}&#39;</span></span></span></code></pre></div></div></div></div><div id=outline-container-headline-29 class=outline-4><h4 id=headline-29>正则表达式匹配</h4><div id=outline-text-headline-29 class=outline-text-4><p>awk 可以依据指定的字符串，只处理需要的行</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 其中 ~ 表示模式开始， / /中间是模式。</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;$6 ~ /hello/ || NR==1 {print NR,$4,$6}&#39;</span> <span class=nv>OFS</span><span class=o>=</span><span class=s2>&#34;\t&#34;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 使用 “/cat|dog/” 来匹配 FIN 或者 TIME </span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;$6 ~ /cat|dog/ || NR==1 {print NR,$4,$6}&#39;</span> <span class=nv>OFS</span><span class=o>=</span><span class=s2>&#34;\t&#34;</span> filename
</span></span><span class=line><span class=cl><span class=c1># awk 可以像 grep 一样的去匹配某一行</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;/LISTEN/&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 模式取反</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;$6 !~ /cat/ || NR==1 {print NR,$4,$6}&#39;</span> <span class=nv>OFS</span><span class=o>=</span><span class=s2>&#34;\t&#34;</span> filename
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;!/cat/&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-30 class=outline-4><h4 id=headline-30>运算符</h4><div id=outline-text-headline-30 class=outline-text-4><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 比较运算符支持 &gt;, &lt;, ==, &gt;=, &lt;=, !=</span>
</span></span><span class=line><span class=cl><span class=c1># 这些比较运算可以直接与字符串进行比较</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;$1==&#34;book&#34; &amp;&amp; $3&gt;100&#39;</span> filename
</span></span><span class=line><span class=cl><span class=c1># 逻辑运算符 &amp;&amp;, ||, !</span>
</span></span><span class=line><span class=cl><span class=c1># 保留表头，这里的比较逻辑顺序？TODO</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;$1==&#34;cat&#34; &amp;&amp; $3&lt;1000 || NR==1 {printf &#34;%-10s %5d&#34;, $1,$3&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-31 class=outline-4><h4 id=headline-31>awk 脚本</h4><div id=outline-text-headline-31 class=outline-text-4><p>可以将 awk 脚本写入一个文件，然后执行这个文件</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ cat awkfile.awk
</span></span><span class=line><span class=cl><span class=c1>#!/bin/awk -f</span>
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl><span class=nv>text</span> <span class=o>=</span> <span class=nv>$1</span> <span class=s2>&#34;home at &#34;</span> <span class=nv>$6</span>
</span></span><span class=line><span class=cl>print text
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ awk -F: -f awkfile.awk /etc/passwd
</span></span><span class=line><span class=cl><span class=c1># 添加可执行权限，可以如下允许，当然这里没有处理分隔符</span>
</span></span><span class=line><span class=cl>./awkfile.awk /etc/passwd</span></span></code></pre></div></div></div></div><div id=outline-container-headline-32 class=outline-4><h4 id=headline-32>BEGIN-END</h4><div id=outline-text-headline-32 class=outline-text-4><p>希望在执行脚本处理之前或者之后进行一些特殊处理，BEGIN 和 END 可以满足
需求</p><ol><li>BEGIN{处理文本前执行的语句}</li><li>{处理每一行的语句}</li><li>END{处理完成后执行的语句}</li></ol><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 可以在 BEGIN 中修改分隔符、增加表头</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;BEGIN {FS=&#34;:&#34;; print &#34;It is passwd file&#34;} 
</span></span></span><span class=line><span class=cl><span class=s1>{print $0} 
</span></span></span><span class=line><span class=cl><span class=s1>END {print &#34;The End&#34;}&#39;</span> /etc/passwd
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 还可以在处理完脚本之后，进行一些统计处理</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{sum+=$1} END {printf &#34;sum=%d, avg=%f&#34;, sum, sum/NR}&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-33 class=outline-4><h4 id=headline-33>控制-循环语句</h4><div id=outline-text-headline-33 class=outline-text-4><p>格式和 C 语言完全一样</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># if</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{if ($1 &gt; 10) print $1}&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># if - else if - else</span>
</span></span><span class=line><span class=cl><span class=c1># 一行中有多个语句的时候，使用分号分开</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{
</span></span></span><span class=line><span class=cl><span class=s1>if ($1 &gt; 10)
</span></span></span><span class=line><span class=cl><span class=s1>{
</span></span></span><span class=line><span class=cl><span class=s1>x = $1 * 9
</span></span></span><span class=line><span class=cl><span class=s1>print x
</span></span></span><span class=line><span class=cl><span class=s1>}
</span></span></span><span class=line><span class=cl><span class=s1>else if ($1 &gt; 5)
</span></span></span><span class=line><span class=cl><span class=s1>{
</span></span></span><span class=line><span class=cl><span class=s1>x = $1 *3
</span></span></span><span class=line><span class=cl><span class=s1>print x
</span></span></span><span class=line><span class=cl><span class=s1>}
</span></span></span><span class=line><span class=cl><span class=s1>else
</span></span></span><span class=line><span class=cl><span class=s1>{
</span></span></span><span class=line><span class=cl><span class=s1>x = $1 / 2
</span></span></span><span class=line><span class=cl><span class=s1>print x
</span></span></span><span class=line><span class=cl><span class=s1>}
</span></span></span><span class=line><span class=cl><span class=s1>}&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># for loop</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{
</span></span></span><span class=line><span class=cl><span class=s1>total=0
</span></span></span><span class=line><span class=cl><span class=s1>for (i=0; i&lt;3; i++)
</span></span></span><span class=line><span class=cl><span class=s1>{
</span></span></span><span class=line><span class=cl><span class=s1>total += i
</span></span></span><span class=line><span class=cl><span class=s1>}
</span></span></span><span class=line><span class=cl><span class=s1>
</span></span></span><span class=line><span class=cl><span class=s1>avg=total/3
</span></span></span><span class=line><span class=cl><span class=s1>printf &#34;Avg: %f&#34;, avg
</span></span></span><span class=line><span class=cl><span class=s1>}&#39;</span> filename
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># while loop</span>
</span></span><span class=line><span class=cl>$ awk <span class=s1>&#39;{
</span></span></span><span class=line><span class=cl><span class=s1>total=0
</span></span></span><span class=line><span class=cl><span class=s1>i=0
</span></span></span><span class=line><span class=cl><span class=s1>while (i &lt; 5)
</span></span></span><span class=line><span class=cl><span class=s1>{
</span></span></span><span class=line><span class=cl><span class=s1>total += i
</span></span></span><span class=line><span class=cl><span class=s1>if (i == 3)
</span></span></span><span class=line><span class=cl><span class=s1>break
</span></span></span><span class=line><span class=cl><span class=s1>i++
</span></span></span><span class=line><span class=cl><span class=s1>}
</span></span></span><span class=line><span class=cl><span class=s1>printf &#34;total=%d\n&#34;, total
</span></span></span><span class=line><span class=cl><span class=s1>}&#39;</span> filename</span></span></code></pre></div></div></div></div><div id=outline-container-headline-34 class=outline-4><h4 id=headline-34>内建函数</h4><div id=outline-text-headline-34 class=outline-text-4><p>可以通过 man 查看</p><table><tbody><tr><td>数学函数</td><td>sin(x), cos(x), exp(x), log(x), sqrt(x), rand()</td></tr><tr><td>字符串函数</td><td>toupper(), asort, gensub, index, length, match, split</td></tr></tbody></table></div></div><div id=outline-container-headline-35 class=outline-4><h4 id=headline-35>自定义函数</h4><div id=outline-text-headline-35 class=outline-text-4><p>使用关键字 function 自定义函数</p><div class="src src-bash"><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ awk <span class=s1>&#39;
</span></span></span><span class=line><span class=cl><span class=s1>function myfun()
</span></span></span><span class=line><span class=cl><span class=s1>{
</span></span></span><span class=line><span class=cl><span class=s1>printf &#34;user %s in home %s\n&#34;, $1,$6
</span></span></span><span class=line><span class=cl><span class=s1>}
</span></span></span><span class=line><span class=cl><span class=s1>BEGIN{FS=&#34;:&#34;}
</span></span></span><span class=line><span class=cl><span class=s1>{
</span></span></span><span class=line><span class=cl><span class=s1>myfun()
</span></span></span><span class=line><span class=cl><span class=s1>}&#39;</span> /etc/passwd</span></span></code></pre></div></div></div></div><div id=outline-container-headline-36 class=outline-4><h4 id=headline-36>参考</h4><div id=outline-text-headline-36 class=outline-text-4><ol><li><a href=https://coolshell.cn/articles/9070.html>AWK 简明教程</a></li><li><a href=https://likegeeks.com/awk-command/>30 Examples for Awk Command in Text Processing</a></li></ol></div></div></div></div><div id=outline-container-headline-37 class=outline-3><h3 id=headline-37>strace</h3></div><div id=outline-container-headline-38 class=outline-3><h3 id=headline-38>pstack</h3></div><div id=outline-container-headline-39 class=outline-3><h3 id=headline-39>perf</h3></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://kylestones.github.io/tags/shell/>shell</a></li></ul><nav class=paginav><a class=prev href=https://kylestones.github.io/blog/emotion/cancer/><span class=title>« Prev</span><br><span>Fuck you cancer</span></a>
<a class=next href=https://kylestones.github.io/blog/machinelearning/yolo/><span class=title>Next »</span><br><span>YOLO 实现细节</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share shell on twitter" href="https://twitter.com/intent/tweet/?text=shell&url=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fshell%2f&hashtags=shell"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share shell on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fshell%2f&title=shell&summary=shell&source=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fshell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share shell on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fshell%2f&title=shell"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share shell on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fshell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share shell on whatsapp" href="https://api.whatsapp.com/send?text=shell%20-%20https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fshell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share shell on telegram" href="https://telegram.me/share/url?text=shell&url=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fshell%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://kylestones.github.io>Org Mode</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>