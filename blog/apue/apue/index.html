<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advanced Programming in the UNIX Environment | Org Mode</title><meta name=keywords content="Linux,,C"><meta name=description content="I/O 文件 I/O 通过文件描述符标识。对于内核而言，所有打开文件都通过文件描述符引用。 其也是有缓冲的，只是其缓冲区在内核空间，不再用户空间。体现在延迟写，只在适当的时候才调用写文件操作， 减少不必要的写操作，增加性能。 函数 open() 打开文件时，指定模式必须有且仅有 O _RDONLY / O _WRONLY / O _RDWR 三者中的一个。 选项 O _APPEND 指定为追加。原来的 UNIX 系统不支持追加，只能先使用 lseek() 先设置文件的偏移量到文件的 结尾，然后再写。但是这在多个进程同时写的时候会出问题，因为调用了两个函数来追加，所以不是一个原子操作。 而追加选项确保设置偏移和写操作为原子操作。
管道读写 写管道的时候不用使用追加选项，内核会自动按写的顺序写入管道。读取后自动将相应的内容从管道清除。 读取一个写端关闭的管道，在读取完全部数据后，read 函数返回 0 ； 写一个读端关闭的管道，产生 SIGPIPE 信号，设置该信号处理函数或者忽略该信号，write 返回 -1，且 errno 设置为 EPIPE。 读管道，如果管道为空，调用线程阻塞，同进程内的其他线程不受影响。
套接字描述符 虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。 套接字不支持文件偏移量概念，不能使用 lseek 函数，也不可以使用 mmap 函数，不可调用 fchdir 函数。
shutdown 函数可以直接关闭一个套接字的读端或者写端，不管该套接字描述符复制了多少分； close 函数只有在关闭最后一个套接字的时候才会释放该套接字。
改变文件偏移量 lseek
标准库 I/O 标准 I/O 库的操作围绕流(stream)进行。利用指向 FILE 对象维护，该结构体包含了标准 I/O 库为了维护该流所 需要的信息：文件描述符，指向缓冲区的指针，缓冲区的长度，缓冲区中当前的字符数，出错标志等。不需要关心 FILE 结构的具体形式。 相对于文件 I/O，标准库的 I/O 都是带缓冲的，标准库维护了一个缓冲区，在适当的时候才调用 read、write 函 数，从而减少系统调用的开销。"><meta name=author content="Kyle Three Stones"><link rel=canonical href=https://kylestones.github.io/blog/apue/apue/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kylestones.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Advanced Programming in the UNIX Environment"><meta property="og:description" content="I/O 文件 I/O 通过文件描述符标识。对于内核而言，所有打开文件都通过文件描述符引用。 其也是有缓冲的，只是其缓冲区在内核空间，不再用户空间。体现在延迟写，只在适当的时候才调用写文件操作， 减少不必要的写操作，增加性能。 函数 open() 打开文件时，指定模式必须有且仅有 O _RDONLY / O _WRONLY / O _RDWR 三者中的一个。 选项 O _APPEND 指定为追加。原来的 UNIX 系统不支持追加，只能先使用 lseek() 先设置文件的偏移量到文件的 结尾，然后再写。但是这在多个进程同时写的时候会出问题，因为调用了两个函数来追加，所以不是一个原子操作。 而追加选项确保设置偏移和写操作为原子操作。
管道读写 写管道的时候不用使用追加选项，内核会自动按写的顺序写入管道。读取后自动将相应的内容从管道清除。 读取一个写端关闭的管道，在读取完全部数据后，read 函数返回 0 ； 写一个读端关闭的管道，产生 SIGPIPE 信号，设置该信号处理函数或者忽略该信号，write 返回 -1，且 errno 设置为 EPIPE。 读管道，如果管道为空，调用线程阻塞，同进程内的其他线程不受影响。
套接字描述符 虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。 套接字不支持文件偏移量概念，不能使用 lseek 函数，也不可以使用 mmap 函数，不可调用 fchdir 函数。
shutdown 函数可以直接关闭一个套接字的读端或者写端，不管该套接字描述符复制了多少分； close 函数只有在关闭最后一个套接字的时候才会释放该套接字。
改变文件偏移量 lseek
标准库 I/O 标准 I/O 库的操作围绕流(stream)进行。利用指向 FILE 对象维护，该结构体包含了标准 I/O 库为了维护该流所 需要的信息：文件描述符，指向缓冲区的指针，缓冲区的长度，缓冲区中当前的字符数，出错标志等。不需要关心 FILE 结构的具体形式。 相对于文件 I/O，标准库的 I/O 都是带缓冲的，标准库维护了一个缓冲区，在适当的时候才调用 read、write 函 数，从而减少系统调用的开销。"><meta property="og:type" content="article"><meta property="og:url" content="https://kylestones.github.io/blog/apue/apue/"><meta property="og:image" content="https://kylestones.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-12-07T00:00:00+00:00"><meta property="article:modified_time" content="2017-12-07T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kylestones.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Advanced Programming in the UNIX Environment"><meta name=twitter:description content="I/O 文件 I/O 通过文件描述符标识。对于内核而言，所有打开文件都通过文件描述符引用。 其也是有缓冲的，只是其缓冲区在内核空间，不再用户空间。体现在延迟写，只在适当的时候才调用写文件操作， 减少不必要的写操作，增加性能。 函数 open() 打开文件时，指定模式必须有且仅有 O _RDONLY / O _WRONLY / O _RDWR 三者中的一个。 选项 O _APPEND 指定为追加。原来的 UNIX 系统不支持追加，只能先使用 lseek() 先设置文件的偏移量到文件的 结尾，然后再写。但是这在多个进程同时写的时候会出问题，因为调用了两个函数来追加，所以不是一个原子操作。 而追加选项确保设置偏移和写操作为原子操作。
管道读写 写管道的时候不用使用追加选项，内核会自动按写的顺序写入管道。读取后自动将相应的内容从管道清除。 读取一个写端关闭的管道，在读取完全部数据后，read 函数返回 0 ； 写一个读端关闭的管道，产生 SIGPIPE 信号，设置该信号处理函数或者忽略该信号，write 返回 -1，且 errno 设置为 EPIPE。 读管道，如果管道为空，调用线程阻塞，同进程内的其他线程不受影响。
套接字描述符 虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。 套接字不支持文件偏移量概念，不能使用 lseek 函数，也不可以使用 mmap 函数，不可调用 fchdir 函数。
shutdown 函数可以直接关闭一个套接字的读端或者写端，不管该套接字描述符复制了多少分； close 函数只有在关闭最后一个套接字的时候才会释放该套接字。
改变文件偏移量 lseek
标准库 I/O 标准 I/O 库的操作围绕流(stream)进行。利用指向 FILE 对象维护，该结构体包含了标准 I/O 库为了维护该流所 需要的信息：文件描述符，指向缓冲区的指针，缓冲区的长度，缓冲区中当前的字符数，出错标志等。不需要关心 FILE 结构的具体形式。 相对于文件 I/O，标准库的 I/O 都是带缓冲的，标准库维护了一个缓冲区，在适当的时候才调用 read、write 函 数，从而减少系统调用的开销。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://kylestones.github.io/blog/"},{"@type":"ListItem","position":3,"name":"Advanced Programming in the UNIX Environment","item":"https://kylestones.github.io/blog/apue/apue/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advanced Programming in the UNIX Environment","name":"Advanced Programming in the UNIX Environment","description":"I/O 文件 I/O 通过文件描述符标识。对于内核而言，所有打开文件都通过文件描述符引用。 其也是有缓冲的，只是其缓冲区在内核空间，不再用户空间。体现在延迟写，只在适当的时候才调用写文件操作， 减少不必要的写操作，增加性能。 函数 open() 打开文件时，指定模式必须有且仅有 O _RDONLY / O _WRONLY / O _RDWR 三者中的一个。 选项 O _APPEND 指定为追加。原来的 UNIX 系统不支持追加，只能先使用 lseek() 先设置文件的偏移量到文件的 结尾，然后再写。但是这在多个进程同时写的时候会出问题，因为调用了两个函数来追加，所以不是一个原子操作。 而追加选项确保设置偏移和写操作为原子操作。\n管道读写 写管道的时候不用使用追加选项，内核会自动按写的顺序写入管道。读取后自动将相应的内容从管道清除。 读取一个写端关闭的管道，在读取完全部数据后，read 函数返回 0 ； 写一个读端关闭的管道，产生 SIGPIPE 信号，设置该信号处理函数或者忽略该信号，write 返回 -1，且 errno 设置为 EPIPE。 读管道，如果管道为空，调用线程阻塞，同进程内的其他线程不受影响。\n套接字描述符 虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。 套接字不支持文件偏移量概念，不能使用 lseek 函数，也不可以使用 mmap 函数，不可调用 fchdir 函数。\nshutdown 函数可以直接关闭一个套接字的读端或者写端，不管该套接字描述符复制了多少分； close 函数只有在关闭最后一个套接字的时候才会释放该套接字。\n改变文件偏移量 lseek\n标准库 I/O 标准 I/O 库的操作围绕流(stream)进行。利用指向 FILE 对象维护，该结构体包含了标准 I/O 库为了维护该流所 需要的信息：文件描述符，指向缓冲区的指针，缓冲区的长度，缓冲区中当前的字符数，出错标志等。不需要关心 FILE 结构的具体形式。 相对于文件 I/O，标准库的 I/O 都是带缓冲的，标准库维护了一个缓冲区，在适当的时候才调用 read、write 函 数，从而减少系统调用的开销。","keywords":["Linux,","C"],"articleBody":" I/O 文件 I/O 通过文件描述符标识。对于内核而言，所有打开文件都通过文件描述符引用。 其也是有缓冲的，只是其缓冲区在内核空间，不再用户空间。体现在延迟写，只在适当的时候才调用写文件操作， 减少不必要的写操作，增加性能。 函数 open() 打开文件时，指定模式必须有且仅有 O _RDONLY / O _WRONLY / O _RDWR 三者中的一个。 选项 O _APPEND 指定为追加。原来的 UNIX 系统不支持追加，只能先使用 lseek() 先设置文件的偏移量到文件的 结尾，然后再写。但是这在多个进程同时写的时候会出问题，因为调用了两个函数来追加，所以不是一个原子操作。 而追加选项确保设置偏移和写操作为原子操作。\n管道读写 写管道的时候不用使用追加选项，内核会自动按写的顺序写入管道。读取后自动将相应的内容从管道清除。 读取一个写端关闭的管道，在读取完全部数据后，read 函数返回 0 ； 写一个读端关闭的管道，产生 SIGPIPE 信号，设置该信号处理函数或者忽略该信号，write 返回 -1，且 errno 设置为 EPIPE。 读管道，如果管道为空，调用线程阻塞，同进程内的其他线程不受影响。\n套接字描述符 虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。 套接字不支持文件偏移量概念，不能使用 lseek 函数，也不可以使用 mmap 函数，不可调用 fchdir 函数。\nshutdown 函数可以直接关闭一个套接字的读端或者写端，不管该套接字描述符复制了多少分； close 函数只有在关闭最后一个套接字的时候才会释放该套接字。\n改变文件偏移量 lseek\n标准库 I/O 标准 I/O 库的操作围绕流(stream)进行。利用指向 FILE 对象维护，该结构体包含了标准 I/O 库为了维护该流所 需要的信息：文件描述符，指向缓冲区的指针，缓冲区的长度，缓冲区中当前的字符数，出错标志等。不需要关心 FILE 结构的具体形式。 相对于文件 I/O，标准库的 I/O 都是带缓冲的，标准库维护了一个缓冲区，在适当的时候才调用 read、write 函 数，从而减少系统调用的开销。\n定位流 ftell、fseek、ftello、fseek、fgetpos、fsetpos\nIPC IPC 传统上是 UNIX 中一个杂乱不堪的领域，虽然有了各种各样的解决办法，但没有一个是完美的。可分为四个主 要领域：\n消息传递 : 管道、FIFO、消息队列 同步 : 互斥锁、条件变量、读写锁、信号量 共享内存区 : 匿名共享内存区、命令共享内存区 过程调用 : Solaris 门、Sun RPC 包括单个进程内多个线程的 IPC 和多个进程间的 IPC 。\n消息边界 无边界 管道和 FIFO 是字节流，没有消息边界； TCP 没有记录边界的字节流；\n有边界 POSIX 消息和 System V 消息有从发送者向接收者维护的边界； UDP 提供具有边界记录的消息；\n窥探能力 可以窥探 socket recv、recvfrom 函数可以使用标志 MSG _PEEK 从接收队列读取数据，且系统不在读取之后丢弃这些数据；\n不可窥探 管道、FIFO、POSIX 消息、System V 消息 只有一个副本递交到一个线程，且消息不能广播或多播到多个接收者（UDP 广播、多播）\n读取顺序 先进先出 管道、FIFO\n优先级最高的最早消息 POSIX 消息\n指定优先级的消息 System V 消息\n对象持续性 随进程持续 process-persistent IPC 对象一直存在到打开着该对象的最后一个进程关闭该对象为止。没有 unlink 函数。 管道、FIFO、POSIX 互斥锁、POSIX 条件变量、POSIX 读写锁、POSIX 基于内存的信号量、fcntl 记录锁、TCP 套 接字、UDP 套接字、Unix 域套接字\n随内核持续 kernel-persistent 一直存在到内核重新自举或显示删除该 IPC 对象。存在对应的 unlink 函数。 POSIX 消息队列、POSIX 有名信号量、POSIX 共享内存区、System V 消息队列、System V 信号量、System V 共 享内存\n随文件系统持续 filesystem-persistent 一直存在到显示删除该 IPC 对象为止。 IPC 的一个基本设计目标是高性能，而具备随文件系统的持续性可能会使其性能降级，而且进程不可能跨越自举继 续存活。\n名字空间 – name space 一种给定的 IPC 类型，其可能名字的集合称为名字空间。名字空间非常重要，因为名字是客户与服务器彼此连接 以交换消息的手段。\nIPC 类型 打开或创建 IPC 的名字空间 IPC 打开后的标识 管道 NA 描述符 FIFO 路径名 描述符 POSIX 互斥锁 NA pthread _mutex _t 指针 POSIX 条件变量 NA pthread _cond _t 指针 POSIX 读写锁 NA pthread _rwlock _t 指针 fcntl 记录上锁 路径名 描述符 POSIX 消息队列 POSIX IPC 名字 mqd _t 值 POSIX 命名信号量 POSIX IPC 名字 sem _t 指针 POSIX 共享内存 POSIX IPC 名字 描述符 POSIX 基于内存的信号量 NA sem _t 指针 TCP 套接字 IP 地址与 TCP 端口 描述符 UDP 套接字 IP 地址与 UDP 端口 描述符 Unix 域套接字 路径名 描述符 Sun RPC 程序/版本 RPC 句柄 门 路径名 描述符 System V 消息队列 key _t 键 System V IPC 标识符 System V 信号量 key _t 键 System V IPC 标识符 System V 共享内存 key _t 键 System V IPC 标识符 打开 IPC 名字空间 无名 IPC 管道、POSIX 互斥锁、POSIX 条件变量、POSIX 读写锁、POSIX 基于内存的信号量；\n无名 IPC 也可为进程所共享 互斥锁、条件变量、读写锁、POSIX 无名信号量都是无名的，也就是说他们是基于内存的。他们很容易为单个进程 内的不同线程所共享；当他们存放在不同进程间所共享的内存区中时，同时设置其进程共享属性，也可以为这些进 程所共享。\n打开路径名 (path) 来打开 IPC FIFO、fcntl、Unix 域套接字、门；\n打开 POSIX IPC 名字来打开 IPC POSIX 消息队列、POSIX 命令信号量、POSIX 共享内存；\n基于 IP 地址和端口号来打开 IPC TCP 套接字、UDP 套接字；\n基于 key _t 键打开 IPC System V 消息队列、System V 信号量、System V 共享内存；\n打开 IPC 后的标识 描述符 管道、FIFO、fcntl、POSIX 共享内存、TCP 套接字、UDP 套接字、Unix 虞域套接字、门\n相应形式的指针 POSIX 互斥锁 POSIX 条件变量 POSIX 读写锁 POSIX 命名信号量 POSIX 基于内存的信号量 值 POSIX 消息队列 System V IPC 标识符 System V 消息队列 System V 信号量 System V 共享内存 RPC 句柄 Sun RPC\n需要定义结构体变量–指针 除了 Posix 信号量需要定义成指针，其他的都需要定义成变量。\n结构体 互斥锁、条件变量、读写锁、Posix 无名信号量、Posix 消息队列、 描述符、Posix 共享内存、\n指针 Posix 命名信号量、mmap、\nfork、exec、exit 对 IPC 的影响 无名同步变量（互斥锁、条件变量、读写锁、基于内存的信号量），从一个具有多线程的进程中调用 fork 将变得 混乱不堪；如果这些变量驻留在共享内存区中，而且创建时设置了进程共享属性，那么对于能访问该共享内存区的 任意进程来说，其任意线程能继续访问这些变量。 System V IPC 的三种形式没有打开或关闭的说法，只需知道其标识符即可访问。 IPC 类型 fork exec _exit 管道、FIFO 子进程取得父进程的所有打开着的文件描述符的副本 所有打开着的文件描述符继续打开，除非设置了 FD _CLOEXEC 位 关闭所有打开着的描述符，最后一个关闭时删除管道或 FIFO 中残留的数据 POSIX 消息队列 子进程取得父进程的所有打开着的消息队列描述符的副本 关闭所有打开着消息队列描述符 关闭所有打开着的消息队列描述符 System V 消息队列 – – – POSIX 互斥锁和条件变量 若驻留在共享内存区中而且具有进程间共享属性，则共享 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失 POSIX 读写锁 若驻留在共享内存区中而且具有进程间共享属性，则共享 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失 POSIX 基于内存的信号量 若驻留在共享内存区中而且具有进程间共享属性，则共享 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失 除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失 POSIX 命名信号量 父进程中所有打开着的命名信号量在子进程中继续打开着 关闭所有打开着的命名信号量 关闭所有打开着的命名信号量 fcntl 记录锁 子进程不继承父进程持有的锁 只要描述符继续打开着，锁就不变 解开由进程持有的所有未处理的锁 System V 信号量 子进程中所有 semadj 值都置位 0 所有 semadj 值都携入新进程 所有 semadj 值都加到相应的信号量值上 mmap 内存映射 父进程的内存映射存留到子进程中 去除内存映射 去除内存映射 POSIX 共享内存区 父进程中内存映射存留到子进程中 去除内存映射 去除内存映射 System V 共享内存区 附接着的共享内存区在子进程中继续附接着 断开所有附接着的共享内存区 断开所有附接着的共享内存区 门 子进程取得父进程的所有打开着的描述符，但是客户在门描述符上激活其过程时，只有父进程是服务器 所有门描述符都应关闭，因为它们创建时设置了 FD _CLOEXEC 位 关闭所有打开着的描述符 锁释放 内核自动释放 持有某个锁的进程没有释放就终止，内核自动释放该锁； fcntl 记录锁、System V 信号量（可选项）\n无法释放锁 互斥锁、条件变量、读写锁、POSIX 信号量\n进程、线程与共享信息 没有任何东西限制任何 IPC 技术只适用于两个进程。\n两个进程共享存留于文件系统中某个文件上的某些信息。为了访问这些信息，每个进程都得穿越内核（例如 read、write、lssk 等）；需要某种形式的同步，如记录锁。 两个进程共享驻留于内核的某些信息，访问共享信息的每次操作都涉及对内核的一次系统调用。管道、 System V 消息队列、System V 信号量均是； 两个进程有一个双方都能访问的共享存储区，需要某种形式的同步（信号量等）。每个进程一旦设置好该共享 内存区，就能根本不涉及内核而访问其中的数据。 进程 – 线程 设计线程的原因： fork 的开销很大。内存映射要从父进程复制到子进程，所有描述符要在子进程复制一份。尽管存在写时复制 (copy-on-write) 的技术，fork 的开销仍然很大。 fork 子进程后，需要使用 IPC 在父子进程之间传递信息。 线程共享全局内存空间 一个进程内的所有线程共享同一个全局内存空间。使得线程间很容易共享信息，但这种易用性也带来了同步 (synchronization) 问题。\n线程共享的资源 全局内存空间 进程指令 打开的文件 信号处理程序和信号处置 当前工作目录 用户 ID 和 组 ID 线程私有资源 线程 ID 寄存器集合，包括程序计数器和栈指针 栈，存放局部变量和返回地址 errno 信号掩码 优先级 系统开销 执行一般命令 1ns = 1/1,000,000,000s 从 L1 级缓存读 0.5ns 分支误预测 5ns L2 级缓存读 7ns 加锁、解锁 25ns 主存中读 100ns 1Gbps 网络中发 2k 数据 20,000ns 主存中读 1MB 序列 250,000ns 查找从硬盘中读 8,000,000ns 硬盘读 1MB 序列 20,000,000ns 报文从美国发到欧洲并返回 150ms = 150,000,000ns 练习代码 基本函数 #include #include #include #include #include #include #include #include #include #include #include #include #include #include #include int globalNum = 522; void echoAllID(char *processName); void forkTest(); void vforkTest(); void exitTest(); void echoExitStatus(int status); void noZombie(); void accountingRecored(); static unsigned long compt2ulong(comp_t comptime); void showAcctTime(); void testExecl(); void testSystem(); void testUserloginname(); void checkTime(char *processName, struct timeval *endtv, unsigned long long int *count); void testNice(); void showProcessTime(clock_t realtime, struct tms *tms_start, struct tms *tms_end); void testCmdTime(); void testZombie(); void printfRevSignal(int signo); void testSignal(); void testPipe(); void test_mq(); void cleanBuf(void); void releaseResource(void); int main(int argc, char **argv) { atexit(releaseResource); atexit(cleanBuf); setbuf(stdout, NULL); printf(\"stdin's fileno \\t %d\\n\", fileno(stdin)); printf(\"stdout's fileno \\t %d\\n\", fileno(stdout)); printf(\"stderr's fileno \\t %d\\n\", fileno(stderr)); //echoAllID(argv[0]); //forkTest(); //vforkTest(); //exitTest(); //noZombie(); //accountingRecored(); //showAcctTime(); //testExecl(); //testSystem(); //testUserloginname(); //testNice(); //testCmdTime(); //testZombie(); //testSignal(); test_mq(); testPipe(); exit(0); } void echoAllID(char *processName) { pid_t pid; pid_t ppid; uid_t uid; uid_t euid; gid_t gid; gid_t egid; //Note that none of these functions has an error return. pid = getpid(); ppid = getppid(); uid = getuid(); euid = geteuid(); gid = getgid(); egid = getegid(); printf(\"The %s process\\n\" \"pid = %d, ppid = %d\\n\" \"uid = %d, euid = %d\\n\" \"gid = %d, egid = %d\\n\", processName, pid, ppid, uid, euid, gid, egid); } void forkTest() { int num = 99; char buf[] = \"Hello Kyle!\\n\"; pid_t pid; //The write function is not buffered, its data is written once to //standard output before fork. if((sizeof(buf) - 1) != write(STDOUT_FILENO, buf, sizeof(buf) - 1)) { exit(1); } //The standard I/O library is buffered. Standard output is line //buffered if it's connected to a terminal device; otherwise, //it's fully buffered. printf(\"Before fork\\n\"); //The printf before the fork is called once, but the line remains //in buffer when fork is called. This is then copied into the child //when the patent's data space is copied to child. Both parent and //the child now have a standard I/O buffer with this line in it. //The second printf, right before the exit, just appends its data //to the existing buffer. When each process terminates, its copy //of the buffer is funally flushed. if((pid = fork()) \u003c 0) { exit(1); } else if(0 == pid) { //changes to variables in a child process do not affect the value //of the variables in the parent process. //sleep(2); num = 1314; globalNum = 520; } else { //Let the child process execute, but there is no guarantee. sleep(2); //exit(0); } printf(\"pid = %d, ppid = %d: num = %d, globalNum = %d\\n\", getpid(), getppid(), num, globalNum); //exit(0); } void vforkTest() { int num = 99; char buf[] = \"Hello Kyle!\\n\"; pid_t pid; //child will not copy the memory of parent after vfork, just use it printf(\"Before vfork\\n\"); if((pid = vfork()) \u003c 0) { exit(1); } else if(0 == pid) { //modify parent's varables num = 1314; globalNum = 520; _exit(0);//parent will not execute before child call exec or exit //_exit will not flush the buffer, but exit will } printf(\"pid = %d, ppid = %d: num = %d, globalNum = %d\\n\", getpid(), getppid(), num, globalNum); exit(0); } void echoExitStatus(int status) { if(WIFEXITED(status)) { printf(\"normal termination, exit status = %d\\n\", WEXITSTATUS(status)); } if(WIFSIGNALED(status)) { printf(\"abnormal termination, exit status %d.%s\\n\", WTERMSIG(status), #ifdef WCOREDUMP (WCOREDUMP(status)) ? \"(a core file was generated)\" : \"(no core)\"); #else \"\"); #endif } if(WIFSTOPPED(status)) { printf(\"process stopped by signal %d\\n\", WSTOPSIG(status)); } if(WIFCONTINUED(status)) { printf(\"process continued\\n\"); } } void exitTest() { pid_t pid; int status; if((pid = fork()) \u003c 0) exit(1); else if(0 == pid) exit(7); if(wait(\u0026status) != pid)//child exit, variable pid in here is parent's pid variable exit(1); else echoExitStatus(status); if((pid = fork()) \u003c 0) exit(1); else if(0 == pid) abort(); if(wait(\u0026status) != pid) exit(1); else echoExitStatus(status); if((pid = fork()) \u003c 0) { exit(1); } else if(0 == pid) { //status /= 0; } if(wait(\u0026status) != pid) exit(1); else echoExitStatus(status); } void noZombie() { pid_t pid; int status; if((pid = fork()) \u003c 0) exit(1); else if(0 == pid) { if((pid = fork()) \u003c 0) exit(1); else if(pid \u003e 0) { exit(0);//first child do nothing and exit } //it's parent is the first child //exec the process sleep(2); printf(\"I am the second child. pid=%d,ppid=%d.\\n\", getpid(), getppid()); exit(0); } //I am not the parent of the second child printf(\"I am the parent! And I don't need to see the child.\\n\"); //if(waitpid(pid, \u0026status, WNOHANG) != pid)//nonblocking if(waitpid(pid, \u0026status, 0) != pid) { exit(1); } else { echoExitStatus(status); } exit(0); } //进程统计信息 //进程的各类信息在进程创建时初始化（由內核保存在进程表中），进程终止时写 //一个会计记录。 //a、永不终止的进程没有会计记录； //b、只知道进程的起始时间，以日历时间来记，精确到秒，在 1s 内可能同时创建 //了很多进程）和运行时间（以 clock ticks 来记，每秒中有 60～128 ticks） //但仅知道终止顺序（在会计文件中以进程的终止顺序来记录）无法得知进程精确的 //起始时间 //accounting recored 对应着进程而不是程序；一个进程多次调用 exec ，最后只 //会记录最后一个进程的命令名但运行时间是所有 exec 进程之和。fork 多次会记录 //多个 accounting recored void accountingRecored() { pid_t pid; if((pid = fork()) \u003c 0) { exit(1); } else if(pid \u003e 0) { //parent sleep(25); exit(2); } if((pid = fork()) \u003c 0) { exit(1); } else if(pid \u003e 0) { //first child sleep(4); abort(); } if((pid = fork()) \u003c 0) { exit(1); } else if(pid \u003e 0) { //second child execl(\"/bin/dd\", \"dd\", \"if=/etc/passwd\", \"of=/dev/null\", \"count=1000\", NULL); } if((pid = fork()) \u003c 0) { exit(1); } else if(pid \u003e 0) { //third child sleep(8); exit(0); } sleep(6); //forth child kill(getpid(), SIGKILL); exit(6); } static unsigned long compt2ulong(comp_t comptime) { unsigned long val = 0; int exp = 0; val = comptime \u0026 0x7fff; //13 位小数部分 exp = (comptime \u003e\u003e 13) \u0026 7; //指数部分 while(exp-- \u003e 0) { val *= 8; } return val; } void showAcctTime() { struct acct acdata; FILE *fp; //需要安装 acct 程序。且需要 root 权限才能 accton on/off 以及读取记录文件 if((fp = fopen(\"/var/log/account/pacct\", \"r\")) == NULL) { printf(\"can't open the file\\n\"); //fflush(STDOUT_FILENO); //write(STDOUT_FILENO, \"can't open the file\\n\", sizeof(\"can't open the file\\n\") -1); exit(1); } while(1 == fread(\u0026acdata, sizeof(acct), 1, fp)) { printf(\"%s etime=%ld io=%ld %c %c %c %c\\n\", acdata.ac_comm, compt2ulong(acdata.ac_etime), compt2ulong(acdata.ac_io), acdata.ac_flag \u0026 AFORK ? 'F' : ' ', acdata.ac_flag \u0026 ASU ? 'S' : ' ', acdata.ac_flag \u0026 ACORE ? 'C' : ' ', acdata.ac_flag \u0026 AXSIG ? 'X' : ' '); } } void testExecl() { pid_t pid = 0; int status = -1; if((pid = fork()) \u003c 0) { exit(1); } else if(0 == pid) { //exec 函数第一个参数只想可执行文件 execute file //argv 是可执行文件的参数列表，列表的第一个参数约定写成可执行文件的 //文件名。但测试发现随意写好像并没有什么影响，如下所示 execl(\"/bin/ls\", \"qwe\", \"-l\", (char *)NULL); } waitpid(pid, \u0026status, 0); printf(\"status=%d\\n\", status); } void testSystem() { //system() 函数用于执行 shell command //system 会调用fork、exec、waitpid 函数，且进行了必要的错误处理和信号处理 int status = 0; if((status = system(\"date\")) \u003c 0) { exit(1); } printf(\"status = %d\\n\", status); if((status = system(\"nosuchcommand\")) \u003c 0) { exit(1); } printf(\"status = %d\\n\", status); if((status = system(\"who; exit 44\")) \u003c 0) { exit(1); } printf(\"status = %d\\n\", status); } void testUserloginname() { char *name = NULL; char *envname = NULL; struct passwd *ppasswd; if(-1 != setenv(\"LOGNAME\", \"yym\", 1)) { printf(\"set the logname to yym\\n\"); } //getlogin 得到用户的登录名。且一个 user ID 可能对应多个登录名， //因为他们使用不同的 shell 等原因。 //环境变量中的 LOGNAME 由 login(1) 从登录名获取， //但是用户可以更改，所以不可取。 if(NULL != (name = getlogin())) { printf(\"login name = %s\\n\", name); envname = getenv(\"LOGNAME\"); if(NULL != envname) { printf(\"envname = %s\\n\", envname); } //从文件 passwd 中获取用户的信息 ppasswd = getpwnam(name); if(NULL != ppasswd) { printf(\"name=%s\\n\", ppasswd-\u003epw_name); printf(\"passwd=%s\\n\", ppasswd-\u003epw_passwd); printf(\"user information=%s\\n\", ppasswd-\u003epw_gecos); printf(\"dir=%s\\n\", ppasswd-\u003epw_dir); printf(\"shell=%s\\n\", ppasswd-\u003epw_shell); } } else { printf(\"execute getlogin failed\\n\"); } //测试读取其他用户的信息 //可以获取到，但是由于密码并不保存在 passwd 文件中 //所以好像没有安全隐患 ppasswd = getpwnam(\"boy\"); if(NULL != ppasswd) { printf(\"name=%s\\n\", ppasswd-\u003epw_name); printf(\"passwd=%s\\n\", ppasswd-\u003epw_passwd); printf(\"user information=%s\\n\", ppasswd-\u003epw_gecos); printf(\"dir=%s\\n\", ppasswd-\u003epw_dir); printf(\"shell=%s\\n\", ppasswd-\u003epw_shell); } } void checkTime(char *processName, struct timeval *endtv, unsigned long long int *count) { struct timeval tv; //获取时间。结构体 timeval 中有两个成员变量 tv_sec、tv_usec gettimeofday(\u0026tv, NULL); if(tv.tv_sec \u003e= endtv-\u003etv_sec \u0026\u0026 tv.tv_usec \u003e= endtv-\u003etv_usec) { printf(\"%10s count %lld\\n\", processName, *count); exit(0); } } void testNice() { pid_t pid = -1; char *processname; struct timeval endtv; unsigned long long int count = 0; int priority = 0; int niceval = 0; setbuf(stdout, NULL); gettimeofday(\u0026endtv, NULL); endtv.tv_sec += 10; //让进程运行 10s if((pid = fork()) \u003c 0) { exit(1); } else if(0 == pid) { processname = \"child\"; //获取进程的调度优先级 priority = getpriority(PRIO_PROCESS, 0); printf(\"child process priority = %d\\n\", priority); //进程默认的 nice 值 niceval = sysconf(_SC_NZERO); printf(\"process default nice value = %d,\" \"child nice value = %d\\n\", niceval, nice(0)); //nice 值的范围 -20～19，nice 参数为增加的值。且返回值为新的 nice 值。 //由于有可能为 -1，所以需要先将 errno 清零，然后当 nice 返回 -1 且 //errno 不为 0 时才表示调整失败。 errno = 0; if(-1 == nice(20) \u0026\u0026 0 != errno) { printf(\"child faild to change the nice value\\n\"); } else { printf(\"child new nice val is %d\\n\", nice(0)); } } else { processname = \"parent\"; priority = getpriority(PRIO_PROCESS, 0); printf(\"parent process priority = %d\\n\", priority); niceval = sysconf(_SC_NZERO); printf(\"parent process default nice value = %d,\", nice(0)); } while(1) { ++count; if(0 == count) { printf(\"%10.10s count warp\\n\", processname); } checkTime(processname, \u0026endtv, \u0026count); } } void showProcessTime(clock_t realtime, struct tms *tms_start, struct tms *tms_end) { static long clktck = 0; if(0 == clktck) { clktck = sysconf(_SC_CLK_TCK); if(clktck \u003c= 0) { printf(\"get the clock tick failed\\n\"); exit(1); } else { printf(\"the clock tick is %d\\n\", clktck); } } printf(\" real: %7.2f\\n\", realtime / (double)clktck); printf(\" user: %7.2f\\n\", (tms_end-\u003etms_utime - tms_start-\u003etms_utime) / (double)clktck); printf(\" sys: %7.2f\\n\", (tms_end-\u003etms_stime - tms_start-\u003etms_stime) / (double)clktck); printf(\" cuser: %7.2f\\n\", (tms_end-\u003etms_cutime - tms_start-\u003etms_cutime) / (double)clktck); printf(\" csys: %7.2f\\n\", (tms_end-\u003etms_cstime - tms_start-\u003etms_cstime) / (double)clktck); printf(\" csysstart: %7.2f\\n\", (tms_start-\u003etms_cstime) / (double)clktck); printf(\" csysend: %7.2f\\n\", (tms_end-\u003etms_cstime) / (double)clktck); } void testCmdTime() { clock_t walltimestart; clock_t walltimeend; struct tms tms_start; struct tms tms_end; if(-1 == (walltimestart = time(\u0026tms_start))) { exit(1); } printf(\" wallstart: %7.2f\\n\", (walltimestart) / (double)100); if(system(\"dd if=/etc/passwd of=/dev/null count=10000\") \u003c 0) { exit(1); } if(-1 == (walltimeend = time(\u0026tms_end))) { exit(1); } printf(\" wallend: %7.2f\\n\", (walltimeend) / (double)100); showProcessTime(walltimeend - walltimestart, \u0026tms_start, \u0026tms_end); } void testZombie() { pid_t pid = -1; if((pid = fork()) \u003c 0) { exit(1); } else if(0 == pid) { exit(0); } sleep(4); system(\"ps -o pid,ppid,state,tty,command\"); } //解释器文件--将参数重新解释成了新的 shell 语句 void printfRevSignal(int signo) { if(SIGRTMIN == signo) { printf(\"Received SIGUSER1\\n\"); } else if(SIGRTMIN+1 == signo) { printf(\"Received SIGUSER2\\n\"); } else { printf(\"Received signal %d\\n\", signo); } } void testSignal() { void (*pSig)(int); //signal 函数返回要设置的信号原来的信号处理函数 if(SIG_ERR == (pSig = signal(SIGRTMIN, printfRevSignal))) { exit(1); } else { printf(\"previous signal pointer1 = %p\\n\", pSig); } if(SIG_ERR == (pSig = signal(SIGRTMIN+1, printfRevSignal))) { exit(1); } else { printf(\"previous signal pointer = %p\\n\", pSig); } //Linux 上也定义了信号 SIGCLD 信号；其有可能在其他系统上导致进行反复调用 //信号处理函数而导致堆栈溢出，进程终止。 //if(SIG_ERR == (pSig = signal(SIGCLD, printfRevSignal))); //可以利用 sigaction 函数设置 SA_NOCLDWAIT 来避免产生僵死进程 while(1) { pause(); } } //不可靠信号：（最主要的特点：信号可能在任何时候产生） //1. 信号可能会丢失；信号产生后进程却无法得到通知 //2. 不具备阻塞信号的能力；进程只能捕捉或者忽略 //3. 信号处理只生效一次，然后恢复系统默认 //4. 系统执行慢速的系统调用，若接收到中断信号，则终止系统调用，并返回出错。 // UNIX 系统后来支持自动重启系统调用：ioctl,read,readv,write,writev,wait // 否则用户就必须每次进行出错处理，如果是中断则重启系统调用 //5. 信号处理函数中调用的函数要是可重入的，即异步信号安全的 // 不可重入的函数： // a) 使用静态数据结构； // b) 调用 malloc,free ；会使用静态变量（链表）来维护内存信息 // c) 调用标准 I/O 函数。标准 I/O 函数大都使用了全局数据结构 //6. 每个线程只有一个 errno ，而中断处理函数可能更改 errno ； // 所以应当在中断处理函数前保存 errno，处理完成后返回 errno。 //7. 更新全局数据结构时，阻塞可能导致异常的信号 //8. alarm 设置一个定时器，在定时时间到后产生一个 SIGALRM 信号。 // 每个进程只能有一个闹钟时间。新设置的闹钟时间会覆盖原来的。 // 在 SIGALRM 的信号处理函数要检查之前的时间，且要保存返回之前的信号处理函数 //9. 设置 SIGALRM 信号处理函数要在设置定时器之前，否则有可能定时器时间到，然后 // 就会执行默认处理，终止进程。 //10. 设置定时器后接系统调用，可能存在竞争条件（假如想要利用该定时器来结束之后 // 的系统调用）。当系统的负载很重时，可能定时间到后，处理完中断处理函数后， // 仍然没有运行之后的系统调用。 race condition // 使用 setjmp,longjmp 来解决时，如果 SIGALRM 中断了其他的中断处理函数，那么 // longjmp 会提早结束其他的中断处理函数，而导致异常。 //11. 在信号产生(generation)和递送(delivery)之间的时间间隔内，称信号是未决的(pending)； //当进程对信号采取某种动作时，我们称向进程递送了一个信号。 //调用 sigprocmask 阻塞某一个信号，之后产生该信号，那么该信号是阻塞不能传递的， //因而也一定是未决的，可以通过函数 sigpending 来获取所有未决的信号。 //12. 使用 sigaction 来检查、修改指定信号的处理动作。取代 signal 函数。 // 更改一个信号的处理动作后会一直生效，直到下一次显示调用该函数更改。 // 一个信号引发了其处理动作，然后该信号会被阻塞直到处理完成返回。除非设置了 // saflag 的 SA_NODEFER 标志 // sa_handler 和 sa_sigaction 可能使用同一存储区，用户只能使用其中一个 // 默认不重新启动被中断的系统调用，除非设置了 SA_RESTART 标志 //13. 调用 sigprocmask 恢复之前的进程屏蔽信号集，如果有任何未决的、不再阻塞的信号， // 则在 sigprocmask 返回前，至少将其中之一递送给进程。 // 在线程中使用函数 pthread_sigmask 来设置。 // 每个线程都有一个信号屏蔽字(signal mask)，规定了当前要阻塞送到进程的信号集。 // 内核在递送一个原来被阻塞的信号给进程时，而不是在产生信号时，才决定信号的处理方式， // 于是，进程在信号递送给他之前仍可以改变对该信号的动作。 //14. 原子操作：先恢复信号屏蔽字，然后使进程休眠 -- sigsuspend； // 函数返回时信号屏蔽字设置成调用之前的值 // 避免信号在恢复屏蔽字和使进程休眠之间丢失。 // a) 保护代码临界区，使其不被特定的信号中断 // b) 等待一个信号处理程序设置一个全局变量 void testPipe() { pid_t pid; int fd[2] = {0}; size_t n = 0; char line[4096]; char *pline = NULL; FILE *fp; setbuf(stdin, NULL); if(NULL == (fp = fopen(\"/etc/passwd\", \"r\"))) { printf(\"%s:%d\\n\", __func__, __LINE__); exit(1); } if(pipe(fd) \u003c 0) { printf(\"%s:%d\\n\", __func__, __LINE__); exit(1); } if((pid = fork()) \u003c 0) { printf(\"%s:%d\\n\", __func__, __LINE__); exit(1); } else if(pid \u003e 0) { close(fd[0]); while(fgets(line, 4094, fp) != NULL) { pline = line; n = strlen(pline); printf(\"n=%d\\n\", n); if(write(fd[1], line, n) != n) { printf(\"%s:%d\\n\", __func__, __LINE__); exit(1); } } if(ferror(fp)) { printf(\"%s:%d\\n\", __func__, __LINE__); exit(1); } close(fd[1]); if(waitpid(pid, NULL, 0) \u003c 0) { printf(\"%s:%d\\n\", __func__, __LINE__); exit(1); } exit(0); } else { close(fd[1]); if(fd[0] != STDIN_FILENO) { //let STDIN_FILENO be the read side of the pipe if(dup2(fd[0], STDIN_FILENO) != STDIN_FILENO) { printf(\"%s:%d\\n\", __func__, __LINE__); exit(1); } close(fd[0]); } if(execl(\"/bin/more\", \"more\", (char *)NULL) \u003c 0) { printf(\"%s:%d\\n\", __func__, __LINE__); exit(1); } exit(0); } } //popen() //pclose() //mkfifo() //mkfifoat() //创建 fifo 之后要使用 open 函数打开，且只读打开会阻塞到某个进程为写而打开该 fifo , //反之亦然。一个给定的 fifo 有多个写进程是很常见的，因此应该确保每次写都是原子操作， //当写的数据大小不大于 PIPE_BUF 时可以确保是原子操作。 //msgget() //msgctl() //msgsnd() //msgrev() //mq_open void test_mq() { mqd_t mqID; struct mq_attr attr; int rc = 0; mqID = mq_open(\"/msg_default\", O_CREAT | O_EXCL, S_IRUSR | S_IWUSR, NULL); if(-1 == mqID) { printf(\"%d %d %d %d %d %d\\n\", EACCES, EEXIST, EINVAL, EMFILE, ENAMETOOLONG, ENFILE); printf(\"create msg queue failed. errno = %d\\n\", errno); if(EINVAL == errno) { printf(\"wrong\\n\"); } exit(1); } rc = mq_getattr(mqID, \u0026attr); if(-1 == rc) { printf(\"get attr failed\\n\"); exit(1); } printf(\"Maxmum message on queue: %ld\\n\", attr.mq_maxmsg); printf(\"Maxmum message size: %ld\\n\", attr.mq_msgsize); rc = mq_unlink(\"/msg_default\"); if(-1 == rc) { exit(1); } exit(0); } //sem_init 匿名信号量 //sem_destory 销毁匿名信号量 //sem_open 命名信号量 //sem_close 关闭命令信号量 //sem_unlink 销毁命名信号量 //shm_open //mmap //shm_unlink void cleanBuf(void) { printf(\"pid:%d,clean all buf. Invoke by atexit\\n\", getpid()); } void releaseResource(void) { printf(\"pid:%d,release all resource. Invoke by atexit\\n\", getpid()); } IPC #include #include #include #include #include #include #include #include #include #include #include #include #define FIFOPATH \"/home/kyle/APUE/test/fifo\" void fifotest(); void opentest(); void writetest(); void mqtest(); void shmtest(); void pthreadtest(); void unlockInAtexit(); void mmaptest(); void fcntltest(); struct { pthread_mutex_t mutex; pthread_cond_t cond; int num; } var = {PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER}; int main() { //writetest(); //fifotest(); //opentest(); //mqtest(); //shmtest(); //pthreadtest(); //unlockInAtexit(); //mmaptest(); fcntltest(); //sleep(10); return 0; } //打开只读的 fifo 时阻塞等待到某个进程为写而打开这个 fifo ； //只写打开 fifo 会阻塞等待到某个进程为读而打开这个 fifo ； void fifotest() { pid_t pid; int rc = 0; umask(0); //unlink(FIFOPATH); //rc = mkfifo(FIFOPATH, 0777); unlink(FIFOPATH); //rc = mkfifo(FIFOPATH, O_CREAT | O_EXCL | O_RDWR);//写法错误 if(rc \u003c 0) { perror(\"mkfifo\"); exit(1); } pid = fork(); if(pid \u003c 0) { perror(\"fork\"); exit(1); } else if(0 == pid) { pid = fork(); if(pid \u003c 0) { perror(\"second fork\"); exit(1); } else if(pid \u003e 0) { int fd = -1; fd = open(FIFOPATH, O_RDWR); //fd = open(FIFOPATH, O_WRONLY | O_APPEND); //fd = open(FIFOPATH, O_WRONLY); if(fd \u003c 0) { perror(\"open fifo\"); exit(1); } int num = 0; num = write(fd, \"Hello \", sizeof \"Hello \"); if(num != sizeof \"Hello \" ) { perror(\"write fifo\"); exit(1); } num = write(fd, \"I'm kyle\", sizeof \"I'm kyle\"); exit(0); } else { int fd = -1; fd = open(FIFOPATH, O_RDWR); //fd = open(FIFOPATH, O_WRONLY | O_APPEND); //fd = open(FIFOPATH, O_WRONLY); if(fd \u003c 0) { perror(\"open fifo\"); exit(1); } int num = 0; num = write(fd, \"World\", sizeof \"World\"); if(num != sizeof \"World\") { perror(\"write fifo\"); exit(1); } exit(0); } exit(0); } else { //pid = waitpid(pid, NULL, 0); //if(pid != wait(NULL)) { // perror(\"wait error\"); // exit(1); //} if(-1 == pid) { perror(\"firest parent\"); exit(1); } int fd = -1; fd = open(FIFOPATH, O_RDWR); //fd = open(FIFOPATH, O_RDONLY); if(fd \u003c 0) { perror(\"child open fifo\"); exit(1); } char s[4096] = {'\\0'}; int num = 0; int len = 0; while((num = read(fd, s, 4096)) != 0) { len += num; printf(\"read num = %d\\n\", num); //puts(s); write(1, s, num); if(len == 22) break; } exit(0); } } #define OPENFILE \"/home/kyle/APUE/test/opentest.c\" void opentest() { int rc = 0; umask(0); rc = open(OPENFILE, O_RDWR | O_CREAT, 07777); rc = open(OPENFILE, O_RDWR | O_CREAT); if(rc \u003c 0) { perror(\"2 arg\"); } } void writetest() { int a = 69;//对应 'E' 的 ASCII 值，结果会在终端上打印出 E ；如果改成 999 那么会打印出一个汉字 write(STDOUT_FILENO, \u0026a, sizeof(int)); } //MQ_OPEN_MAX 一个进程能够同时打开的消息队列的最大数目 //MQ_PRIO_MAX 消息的最大优先级 +1 void mqtest() { pid_t pid; pid = fork(); if(pid \u003c 0) { perror(\"fork\"); exit(1); } else if(pid \u003e 0) { sleep(5); char buf[8192] = {'\\0'}; ssize_t recvlen = 0; mqd_t mqd = mq_open(\"/kylemq\", O_RDONLY); if(-1 == mqd) { perror(\"parent open mq\"); exit(1); } struct mq_attr mqattr; if(-1 == mq_getattr(mqd, \u0026mqattr)) { perror(\"get mq attr\"); } printf(\"maxmsg = %ld, mq len = %ld, current msg = %ld\\n\", mqattr.mq_maxmsg, mqattr.mq_msgsize, mqattr.mq_curmsgs); unsigned int rcvpri = 0; //接收消息的 buf 必须大于消息队列的大小，否则无法接收消息 //Posix 消息队列读取时总是返回最高优先级的最早消息，且消息的优先级一起返回 //每次只接收一条消息，消息有边界 //读消息队列，只在消息队列为空的时候，阻塞等待；写消息队列，在队列满的时候，阻塞等待； //写不用等待读，读也不用等待写；可以让一个进程创建消息队列然后终止、第二个进程写消息队列然后终止、第三个进程读消息队列； //即进程结束后消息队列仍然存在 //mq_notify 可以异步通知进程，有消息放入了空队列 recvlen = mq_receive(mqd, buf, 8192, \u0026rcvpri); if(-1 == recvlen) { perror(\"parent receive mq\"); exit(1); } printf(\"recvpriv=%d\\n\", rcvpri); if(recvlen != write(STDOUT_FILENO, buf, recvlen)) { perror(\"write to stdin\"); exit(1); } if(-1 == mq_getattr(mqd, \u0026mqattr)) { perror(\"get mq attr\"); } printf(\"maxmsg = %ld, mq len = %ld, current msg = %ld\\n\", mqattr.mq_maxmsg, mqattr.mq_msgsize, mqattr.mq_curmsgs); recvlen = mq_receive(mqd, buf, 8192, \u0026rcvpri); if(-1 == recvlen) { perror(\"parent receive mq\"); exit(1); } printf(\"recvpriv=%d\\n\", rcvpri); if(recvlen != write(STDOUT_FILENO, buf, recvlen)) { perror(\"write to stdin\"); exit(1); } mq_close(mqd); if(-1 == mq_unlink(\"/kylemq\")) { perror(\"unlink after use\"); } exit(0); } else { pid = fork(); if(pid \u003c 0) { perror(\"child fork\"); exit(1); } else if(pid \u003e 0) { sleep(2); char buf[100] = {'\\0'}; mqd_t mqd = mq_open(\"/kylemq\", O_WRONLY); if(-1 == mqd) { perror(\"child creat mq\"); exit(1); } int i = 0; for(i = 0; i \u003c 100; ++i) { buf[i] = 'A'; } if(-1 == mq_send(mqd, buf, 100, 30)) { perror(\"child send buf\"); exit(1); } mq_close(mqd); //if(-1 == mq_unlink(\"/kylemq\")) { // perror(\"unlink after use\"); //} exit(0); } else { char buf[100] = {'\\0'}; if(-1 == mq_unlink(\"/kylemq\")) { perror(\"unlink before creat\"); } mqd_t mqd = mq_open(\"/kylemq\", O_WRONLY | O_CREAT | O_EXCL, 0777, NULL); if(-1 == mqd) { perror(\"child creat mq\"); exit(1); } int i = 0; for(i = 0; i \u003c 100; ++i) { buf[i] = 'C'; } if(-1 == mq_send(mqd, buf, 100, 10)) { perror(\"child send buf\"); exit(1); } mq_close(mqd); exit(0); } } } struct shm_mutx { sem_t mutex; int count; }; void shmtest() { //shm_open 的权限位总是必须指定 //shm_open 新创建的共享内存区对象的大小为零，必须使用 ftruncate 修改大小 int shmd = shm_open(\"/kyleshm\", O_RDWR | O_CREAT, 0777); if(-1 == shmd) { perror(\"creat shm\"); exit(1); } //普通文件扩展，扩展部分填充为零； //共享内存扩展部分不一定为零。 if(-1 == ftruncate(shmd, sizeof(int))) { perror(\"change shm size\"); exit(1); } struct stat shmstat; if(-1 == fstat(shmd, \u0026shmstat)) { perror(\"get shm stat\"); } printf(\"shm size = %ld\\n\", shmstat.st_size); int *pshm = NULL; pshm = mmap(NULL, sizeof(int), PROT_READ | PROT_WRITE, MAP_SHARED, shmd, 0); if(MAP_FAILED == pshm) { perror(\"mmap shm\"); exit(1); } sem_t *mutex; if(SEM_FAILED == (mutex = sem_open(\"/kylemutex\", O_CREAT | O_EXCL, 0777, 1))) { perror(\"creat mutex\"); exit(1); } sem_unlink(\"kylemutex\"); pid_t pid = fork(); if(pid \u003c 0) { perror(\"fork\"); exit(1); } else if(0 == pid) { *pshm = 6543210; sem_wait(mutex); printf(\"child read shm value = %d\\n\", *pshm); *pshm = 6543210; sem_post(mutex); exit(0); } else { //sleep(1); sem_wait(mutex); printf(\"parent read shm value = %d\\n\", *pshm); *pshm = 123456; sem_post(mutex); shm_unlink(\"kyleshm\"); exit(0); } } //mmap 测试 //mmap 映射到内存的大小小于文件的大小，仍然可以使用指针设置未映射到内存的空间但还在文件长度范围内的值 // void mmaptest() { //int fd = open(\"foo\", O_RDWR | O_CREAT | O_TRUNC, 0777); int fd = shm_open(\"kyleshm\", O_RDWR | O_CREAT, 0777); if(-1 == fd ) { perror(\"open foo\"); } ftruncate(fd, 10); char *string = \"YYYYYYYYYY\"; write(fd, string, 10); char *pshmd = mmap(NULL, 8, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if(MAP_FAILED == pshmd) { perror(\"mmap\"); } int pagesize = sysconf(_SC_PAGESIZE); printf(\"pagesize=%d\\n\", pagesize); *pshmd = 'b'; *(pshmd + 7) = 'e'; *(pshmd + 8) = 'n'; *(pshmd + 9) = 'e'; //ftruncate(fd, 12288); *(pshmd + 4095) = 'e'; *(pshmd + 4096) = 'e'; *(pshmd + 9192) = 'e'; *(pshmd + 12288) = 'e'; } //测试在进程的清理函数中释放锁 struct data { pthread_mutex_t mutex; int value; }; struct data *something; void cleanprocess() { printf(\"excute the unlock clean\\n\"); pthread_mutex_unlock(\u0026(something-\u003emutex)); } void unlockInAtexit() { pid_t pid; int shmd = shm_open(\"/kyleshm\", O_RDWR | O_CREAT, 0777); if(-1 == shmd) { perror(\"creat shm\"); } if(-1 == ftruncate(shmd, sizeof(struct data))) { perror(\"change the shm size\"); } struct data *pdata = mmap(NULL, sizeof(struct data), PROT_READ | PROT_WRITE, MAP_SHARED, shmd, 0); if(MAP_FAILED == pdata) { perror(\"create mmap\"); } pthread_mutex_init(\u0026(pdata-\u003emutex), NULL); something = pdata; pid = fork(); if(pid \u003c 0) { perror(\"fork\"); } else if(0 == pid) { atexit(cleanprocess); printf(\"child process\\n\"); pthread_mutex_lock(\u0026(pdata-\u003emutex)); printf(\"value = %d\\n\", pdata-\u003evalue); pdata-\u003evalue = 123456; exit(0); } else { sleep(3); printf(\"parent process\\n\"); pthread_mutex_lock(\u0026(pdata-\u003emutex)); printf(\"value = %d\\n\", pdata-\u003evalue); pdata-\u003evalue = 98765; pthread_mutex_unlock(\u0026(pdata-\u003emutex)); exit(0); } } pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; int meimei = 0; void *fun1() { pthread_mutex_lock(\u0026mutex); meimei = 12345; meimei = 12346; meimei = 12347; meimei = 12348; printf(\"meimei = %d\\n\", meimei); pthread_mutex_unlock(\u0026mutex); if(1234 != pthread_mutex_unlock(\u0026mutex)) { perror(\"unlock mutex\"); } if(1234 != pthread_mutex_unlock(\u0026mutex)) { perror(\"unlock mutex\"); } pthread_mutex_unlock(\u0026mutex); pthread_mutex_unlock(\u0026mutex); //pthread_exit(0); return NULL; } void *fun2() { pthread_mutex_lock(\u0026mutex); meimei = 9876; meimei = 9874; meimei = 9873; meimei = 9872; printf(\"meimei = %d\\n\", meimei); pthread_mutex_unlock(\u0026mutex); //pthread_exit(0); return NULL; } void pthreadtest() { int producenum = 5; pthread_t produceID[producenum]; if(0 != pthread_create(\u0026produceID[0], NULL, fun1, NULL)) { perror(\"create pthread\"); } if(0 != pthread_create(\u0026produceID[1], NULL, fun2, NULL)) { perror(\"create pthread\"); } pthread_join(produceID[0], NULL); pthread_join(produceID[1], NULL); exit(0); } //一个文件给定字节，同一个调用进程后来设置的值会覆盖掉之前设置的值。 //没有记录锁的类型是读写锁，只有读锁、写锁、没有锁三种 //而且同一个进程利用 f_GETLK 查看，始终会得到 F_UNLCK 。无论该字节是否已经设置上锁。（前提是没有其他进程对其进行上锁） //只有被其他进程锁定才会获取到锁的类型 //Posix 记录锁是劝告性上锁（advisory locking）； //书上写，一个进程可以无视一个劝告性锁而写一个读锁定文件，或者读一个写锁定文件；(进程有对该文件相应操作的权限) //自己测试发现及时一个进程使用劝告性写锁锁住一个文件，另一个进程任然可以写该文件。 //记录锁不应该同标准 I/O 库一起使用，因为该函数库会执行内部缓冲。当某个文件需要使用记录锁时，为避免问题，应对其使用 read 、write 函数。 //如果系统支持强制性锁，一个进程对某些字节上锁，其他进程在调用 read/write 时会阻塞，直到锁被打开； //但是任然无法保证程序不出现混乱，例如一个进程首先读取了受保护变量的值，然后内核切换进程， //另一个进程锁住文件，修改变量，释放锁； //此时前一个进程被内核调度回来，依据刚才读取的值做操作（由于该值已被另一个进程修改，所以是错误的值），导致错误的行为。 //多个进程同时操作某个文件时，必须都得上锁，否则违规就可能发生。 void fcntltest() { pid_t pid; struct flock flock; int fd = open(\"foo\", O_RDWR); if(-1 == fd) { perror(\"open foo\"); exit(1); } printf(\"F_RDLCK=%d\\n\", F_RDLCK); printf(\"F_WRLCK=%d\\n\", F_WRLCK); printf(\"F_UNLCK=%d\\n\", F_UNLCK); pid = fork(); if(pid \u003c 0) { perror(\"fork\"); exit(1); } else if(0 == pid) { flock.l_type = F_WRLCK; flock.l_whence = SEEK_SET; flock.l_start = 0; flock.l_len = 0; int rc = fcntl(fd, F_GETLK, \u0026flock); if(-1 == rc) { perror(\"child get flock\"); } printf(\"child flock type : %d; lock pid = %d\\n\", flock.l_type, flock.l_pid); flock.l_type = F_WRLCK; flock.l_whence = SEEK_SET; flock.l_start = 0; flock.l_len = 0; rc = fcntl(fd, F_SETLK, \u0026flock); if(-1 == rc) { perror(\"child set write flock\"); } flock.l_type = F_RDLCK; flock.l_whence = SEEK_SET; flock.l_start = 0; flock.l_len = 0; rc = fcntl(fd, F_SETLK, \u0026flock); if(-1 == rc) { perror(\"child set read flock\"); } char str[1024]; lseek(fd, 0, SEEK_SET); int rdlen = read(fd, str, 1024); write(STDOUT_FILENO, str, rdlen); write(STDOUT_FILENO, \"\\n\", 1); lseek(fd, 0, SEEK_SET); rc = write(fd, \"zxcvbn\", 6); if(6 != rc) { perror(\"write file when flock by parent\"); } lseek(fd, 0, SEEK_SET); rdlen = read(fd, str, 1024); write(STDOUT_FILENO, str, rdlen); exit(0); } else { flock.l_type = F_WRLCK; flock.l_whence = SEEK_SET; flock.l_start = 0; flock.l_len = 0; int rc = fcntl(fd, F_SETLK, \u0026flock); if(-1 == rc) { perror(\"set flock\"); } rc = fcntl(fd, F_GETLK, \u0026flock); if(-1 == rc) { perror(\"get flock 1\"); } printf(\"flock type : %d; lock pid = %d\\n\", flock.l_type, flock.l_pid); flock.l_type = F_RDLCK; flock.l_whence = SEEK_SET; flock.l_start = 0; flock.l_len = 0; rc = fcntl(fd, F_SETLK, \u0026flock); if(-1 == rc) { perror(\"set flock\"); } rc = fcntl(fd, F_GETLK, \u0026flock); if(-1 == rc) { perror(\"get flock 2\"); } printf(\"flock type : %d; lock pid = %d\\n\", flock.l_type, flock.l_pid); flock.l_type = F_WRLCK; flock.l_whence = SEEK_SET; flock.l_start = 0; flock.l_len = 0; rc = fcntl(fd, F_SETLK, \u0026flock); if(-1 == rc) { perror(\"parent set write flock\"); } sleep(5); exit(0); } } pthread #include #include #include #include void *thr_fn(void *arg); void *thr_fn2(void *arg); int globalnum = 0; char c = 's'; int main() { pthread_t ntid; pthread_t ntid2; void *tret; int rc = 0; pthread_mutex_t mutexlock; pthread_mutex_init(\u0026mutexlock, NULL); if(0 != (rc = pthread_create(\u0026ntid, NULL, thr_fn, \u0026mutexlock))) { exit(0); } if(0 != (rc = pthread_create(\u0026ntid2, NULL, thr_fn2, \u0026mutexlock))) { exit(0); } printf(\"main thread: pid = %lu, ppid = %lu, tid = %lu (0x%lx)\\n\", getpid(), getppid(), pthread_self(), pthread_self()); pthread_mutex_lock(\u0026mutexlock); globalnum += 10; c = 'k'; pthread_mutex_unlock(\u0026mutexlock); printf(\"num = %d, c = %c\\n\", globalnum, c); pthread_join(ntid, \u0026tret); pthread_join(ntid2, \u0026tret); pthread_mutex_destroy(\u0026mutexlock); exit(0); } void *thr_fn(void *arg) { printf(\"new thread: pid = %lu, ppid = %lu, tid = %lu (0x%lx)\\n\", getpid(), getppid(), pthread_self(), pthread_self()); pthread_mutex_lock(arg); globalnum += 100; c = 'y'; pthread_mutex_unlock(arg); printf(\"num = %d, c = %c\\n\", globalnum, c); pthread_exit(NULL); } void *thr_fn2(void *arg) { printf(\"new thread: pid = %lu, ppid = %lu, tid = %lu (0x%lx)\\n\", getpid(), getppid(), pthread_self(), pthread_self()); pthread_mutex_lock(arg); globalnum += 1000; c = 'l'; pthread_mutex_unlock(arg); printf(\"num = %d, c = %c\\n\", globalnum, c); pthread_exit(NULL); } #include #include #include #include #define PIPETOAYC static volatile sig_atomic_t sigflag; static sigset_t newmask, oldmask, zeromask; static int child2parentfd[2]; static int parent2childfd[2]; static void charatatime(char *str); static void sig_usr(int signo); void TELL_WAIT(); void WAIT_CHILD(); void TELL_CHILD(pid_t pid); void WAIT_PARENT(); void TELL_PARENT(pid_t pid); int main() { pid_t pid; TELL_WAIT(); if((pid = fork()) \u003c 0) { exit(1); } else if(pid \u003e 0) { WAIT_CHILD(); charatatime(\"Parent do whatever is necessary ...\\n\"); TELL_CHILD(pid); //charatatime(\"GO on to do something in parent\\n\"); exit(0); } else { charatatime(\"Child do whatever is necessary ...\\n\"); TELL_PARENT(getppid()); WAIT_PARENT(); //charatatime(\"GO on to do something in parent\\n\"); exit(0); } } #ifdef SIGTOSYC static void sig_usr(int signo) { sigflag = 1; } void TELL_WAIT() { if(SIG_ERR == signal(SIGUSR1, sig_usr)) { exit(1); } if(SIG_ERR == signal(SIGUSR2, sig_usr)) { exit(1); } sigemptyset(\u0026newmask); sigemptyset(\u0026zeromask); sigaddset(\u0026newmask, SIGUSR1); sigaddset(\u0026newmask, SIGUSR2); if(sigprocmask(SIG_BLOCK, \u0026newmask, \u0026oldmask) \u003c 0) { exit(1); } } void TELL_CHILD(pid_t pid) { kill(pid, SIGUSR1); } void WAIT_CHILD() { while(0 == sigflag) { //可能有其他信号唤醒进程 sigsuspend(\u0026zeromask); } sigflag = 0; if(sigprocmask(SIG_SETMASK, \u0026oldmask, NULL) \u003c 0) { exit(1); } } void TELL_PARENT(pid_t pid) { kill(pid, SIGUSR2); } void WAIT_PARENT() { while(0 == sigflag) { sigsuspend(\u0026zeromask); } sigflag = 0; if(sigprocmask(SIG_SETMASK, \u0026oldmask, NULL) \u003c 0) { exit(1); } } #endif #ifdef PIPETOAYC void TELL_WAIT() { if(pipe(child2parentfd) \u003c 0 || pipe(parent2childfd) \u003c 0) { exit(0); } } void TELL_PARENT(pid_t pid) { if(write(child2parentfd[1], \"c\", 1) != 1) { exit(1); } } void WAIT_PARENT() { char c; if(read(parent2childfd[0], \u0026c, 1) != 1) { exit(1); } if(c != 'p') { exit(1); } } void TELL_CHILD(pid_t pid) { if(write(parent2childfd[1], \"p\", 1) != 1) { exit(1); } } void WAIT_CHILD() { char c; if(read(child2parentfd[0], \u0026c, 1) != 1) { exit(1); } if(c != 'c') { exit(1); } } #endif static void charatatime(char *str) { char *ptr = NULL; int c = 0; setbuf(stdout, NULL); for(ptr = str; (c = *ptr++) != 0; ) { putc(c, stdout); } } ","wordCount":"4782","inLanguage":"en","datePublished":"2017-12-07T00:00:00Z","dateModified":"2017-12-07T00:00:00Z","author":{"@type":"Person","name":"Kyle Three Stones"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kylestones.github.io/blog/apue/apue/"},"publisher":{"@type":"Organization","name":"Org Mode","logo":{"@type":"ImageObject","url":"https://kylestones.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kylestones.github.io accesskey=h title="Home (Alt + H)"><img src=https://kylestones.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kylestones.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://kylestones.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kylestones.github.io>Home</a>&nbsp;»&nbsp;<a href=https://kylestones.github.io/blog/>Blogs</a></div><h1 class=post-title>Advanced Programming in the UNIX Environment</h1><div class=post-meta><span title='2017-12-07 00:00:00 +0000 UTC'>December 7, 2017</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;4782 words&nbsp;·&nbsp;Kyle Three Stones&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/blog/apue/apue.org rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>I/O</h2><div id=outline-text-headline-1 class=outline-text-2><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>文件 I/O</h3><div id=outline-text-headline-2 class=outline-text-3><p>通过文件描述符标识。对于内核而言，所有打开文件都通过文件描述符引用。
其也是有缓冲的，只是其缓冲区在内核空间，不再用户空间。体现在延迟写，只在适当的时候才调用写文件操作，
减少不必要的写操作，增加性能。
函数 open() 打开文件时，指定模式必须有且仅有 O _RDONLY / O _WRONLY / O _RDWR 三者中的一个。
选项 O _APPEND 指定为追加。原来的 UNIX 系统不支持追加，只能先使用 lseek() 先设置文件的偏移量到文件的
结尾，然后再写。但是这在多个进程同时写的时候会出问题，因为调用了两个函数来追加，所以不是一个原子操作。
而追加选项确保设置偏移和写操作为原子操作。</p><div id=outline-container-headline-3 class=outline-4><h4 id=headline-3>管道读写</h4><div id=outline-text-headline-3 class=outline-text-4><p>写管道的时候不用使用追加选项，内核会自动按写的顺序写入管道。读取后自动将相应的内容从管道清除。
读取一个写端关闭的管道，在读取完全部数据后，read 函数返回 0 ；
写一个读端关闭的管道，产生 SIGPIPE 信号，设置该信号处理函数或者忽略该信号，write 返回 -1，且 errno
设置为 EPIPE。
读管道，如果管道为空，调用线程阻塞，同进程内的其他线程不受影响。</p></div></div><div id=outline-container-headline-4 class=outline-4><h4 id=headline-4>套接字描述符</h4><div id=outline-text-headline-4 class=outline-text-4><p>虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。
套接字不支持文件偏移量概念，不能使用 lseek 函数，也不可以使用 mmap 函数，不可调用 fchdir 函数。</p><p>shutdown 函数可以直接关闭一个套接字的读端或者写端，不管该套接字描述符复制了多少分；
close 函数只有在关闭最后一个套接字的时候才会释放该套接字。</p></div></div><div id=outline-container-headline-5 class=outline-4><h4 id=headline-5>改变文件偏移量</h4><div id=outline-text-headline-5 class=outline-text-4><p>lseek</p></div></div></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>标准库 I/O</h3><div id=outline-text-headline-6 class=outline-text-3><p>标准 I/O 库的操作围绕流(stream)进行。利用指向 FILE 对象维护，该结构体包含了标准 I/O 库为了维护该流所
需要的信息：文件描述符，指向缓冲区的指针，缓冲区的长度，缓冲区中当前的字符数，出错标志等。不需要关心
FILE 结构的具体形式。
相对于文件 I/O，标准库的 I/O 都是带缓冲的，标准库维护了一个缓冲区，在适当的时候才调用 read、write 函
数，从而减少系统调用的开销。</p><div id=outline-container-headline-7 class=outline-4><h4 id=headline-7>定位流</h4><div id=outline-text-headline-7 class=outline-text-4><p>ftell、fseek、ftello、fseek、fgetpos、fsetpos</p></div></div></div></div></div></div><div id=outline-container-headline-8 class=outline-2><h2 id=headline-8>IPC</h2><div id=outline-text-headline-8 class=outline-text-2><p>IPC 传统上是 UNIX 中一个杂乱不堪的领域，虽然有了各种各样的解决办法，但没有一个是完美的。可分为四个主
要领域：</p><ol><li>消息传递 : 管道、FIFO、消息队列</li><li>同步 : 互斥锁、条件变量、读写锁、信号量</li><li>共享内存区 : 匿名共享内存区、命令共享内存区</li><li>过程调用 : Solaris 门、Sun RPC</li></ol><p>包括单个进程内多个线程的 IPC 和多个进程间的 IPC 。</p><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>消息边界</h3><div id=outline-text-headline-9 class=outline-text-3><div id=outline-container-headline-10 class=outline-4><h4 id=headline-10>无边界</h4><div id=outline-text-headline-10 class=outline-text-4><p>管道和 FIFO 是字节流，没有消息边界；
TCP 没有记录边界的字节流；</p></div></div><div id=outline-container-headline-11 class=outline-4><h4 id=headline-11>有边界</h4><div id=outline-text-headline-11 class=outline-text-4><p>POSIX 消息和 System V 消息有从发送者向接收者维护的边界；
UDP 提供具有边界记录的消息；</p></div></div></div></div><div id=outline-container-headline-12 class=outline-3><h3 id=headline-12>窥探能力</h3><div id=outline-text-headline-12 class=outline-text-3><div id=outline-container-headline-13 class=outline-4><h4 id=headline-13>可以窥探</h4><div id=outline-text-headline-13 class=outline-text-4><p>socket
recv、recvfrom 函数可以使用标志 MSG _PEEK 从接收队列读取数据，且系统不在读取之后丢弃这些数据；</p></div></div><div id=outline-container-headline-14 class=outline-4><h4 id=headline-14>不可窥探</h4><div id=outline-text-headline-14 class=outline-text-4><p>管道、FIFO、POSIX 消息、System V 消息
只有一个副本递交到一个线程，且消息不能广播或多播到多个接收者（UDP 广播、多播）</p></div></div></div></div><div id=outline-container-headline-15 class=outline-3><h3 id=headline-15>读取顺序</h3><div id=outline-text-headline-15 class=outline-text-3><div id=outline-container-headline-16 class=outline-4><h4 id=headline-16>先进先出</h4><div id=outline-text-headline-16 class=outline-text-4><p>管道、FIFO</p></div></div><div id=outline-container-headline-17 class=outline-4><h4 id=headline-17>优先级最高的最早消息</h4><div id=outline-text-headline-17 class=outline-text-4><p>POSIX 消息</p></div></div><div id=outline-container-headline-18 class=outline-4><h4 id=headline-18>指定优先级的消息</h4><div id=outline-text-headline-18 class=outline-text-4><p>System V 消息</p></div></div></div></div><div id=outline-container-headline-19 class=outline-3><h3 id=headline-19>对象持续性</h3><div id=outline-text-headline-19 class=outline-text-3><div id=outline-container-headline-20 class=outline-4><h4 id=headline-20>随进程持续 process-persistent</h4><div id=outline-text-headline-20 class=outline-text-4><p>IPC 对象一直存在到打开着该对象的最后一个进程关闭该对象为止。没有 unlink 函数。
管道、FIFO、POSIX 互斥锁、POSIX 条件变量、POSIX 读写锁、POSIX 基于内存的信号量、fcntl 记录锁、TCP 套
接字、UDP 套接字、Unix 域套接字</p></div></div><div id=outline-container-headline-21 class=outline-4><h4 id=headline-21>随内核持续 kernel-persistent</h4><div id=outline-text-headline-21 class=outline-text-4><p>一直存在到内核重新自举或显示删除该 IPC 对象。存在对应的 unlink 函数。
POSIX 消息队列、POSIX 有名信号量、POSIX 共享内存区、System V 消息队列、System V 信号量、System V 共
享内存</p></div></div><div id=outline-container-headline-22 class=outline-4><h4 id=headline-22>随文件系统持续 filesystem-persistent</h4><div id=outline-text-headline-22 class=outline-text-4><p>一直存在到显示删除该 IPC 对象为止。
IPC 的一个基本设计目标是高性能，而具备随文件系统的持续性可能会使其性能降级，而且进程不可能跨越自举继
续存活。</p></div></div></div></div><div id=outline-container-headline-23 class=outline-3><h3 id=headline-23>名字空间 – name space</h3><div id=outline-text-headline-23 class=outline-text-3><p>一种给定的 IPC 类型，其可能名字的集合称为名字空间。名字空间非常重要，因为名字是客户与服务器彼此连接
以交换消息的手段。</p><table><thead><tr><th>IPC 类型</th><th>打开或创建 IPC 的名字空间</th><th>IPC 打开后的标识</th></tr></thead><tbody><tr><td>管道</td><td>NA</td><td>描述符</td></tr><tr><td>FIFO</td><td>路径名</td><td>描述符</td></tr></tbody><tbody><tr><td>POSIX 互斥锁</td><td>NA</td><td>pthread _mutex _t 指针</td></tr><tr><td>POSIX 条件变量</td><td>NA</td><td>pthread _cond _t 指针</td></tr><tr><td>POSIX 读写锁</td><td>NA</td><td>pthread _rwlock _t 指针</td></tr><tr><td>fcntl 记录上锁</td><td>路径名</td><td>描述符</td></tr></tbody><tbody><tr><td>POSIX 消息队列</td><td>POSIX IPC 名字</td><td>mqd _t 值</td></tr><tr><td>POSIX 命名信号量</td><td>POSIX IPC 名字</td><td>sem _t 指针</td></tr><tr><td>POSIX 共享内存</td><td>POSIX IPC 名字</td><td>描述符</td></tr><tr><td>POSIX 基于内存的信号量</td><td>NA</td><td>sem _t 指针</td></tr></tbody><tbody><tr><td>TCP 套接字</td><td>IP 地址与 TCP 端口</td><td>描述符</td></tr><tr><td>UDP 套接字</td><td>IP 地址与 UDP 端口</td><td>描述符</td></tr><tr><td>Unix 域套接字</td><td>路径名</td><td>描述符</td></tr></tbody><tbody><tr><td>Sun RPC</td><td>程序/版本</td><td>RPC 句柄</td></tr><tr><td>门</td><td>路径名</td><td>描述符</td></tr></tbody><tbody><tr><td>System V 消息队列</td><td>key _t 键</td><td>System V IPC 标识符</td></tr><tr><td>System V 信号量</td><td>key _t 键</td><td>System V IPC 标识符</td></tr><tr><td>System V 共享内存</td><td>key _t 键</td><td>System V IPC 标识符</td></tr></tbody></table><div id=outline-container-headline-24 class=outline-4><h4 id=headline-24>打开 IPC 名字空间</h4><div id=outline-text-headline-24 class=outline-text-4><div id=outline-container-headline-25 class=outline-5><h5 id=headline-25>无名 IPC</h5><div id=outline-text-headline-25 class=outline-text-5><p>管道、POSIX 互斥锁、POSIX 条件变量、POSIX 读写锁、POSIX 基于内存的信号量；</p><div id=outline-container-headline-26 class=outline-6><h6 id=headline-26>无名 IPC 也可为进程所共享</h6><div id=outline-text-headline-26 class=outline-text-6><p>互斥锁、条件变量、读写锁、POSIX 无名信号量都是无名的，也就是说他们是基于内存的。他们很容易为单个进程
内的不同线程所共享；当他们存放在不同进程间所共享的内存区中时，同时设置其进程共享属性，也可以为这些进
程所共享。</p></div></div></div></div><div id=outline-container-headline-27 class=outline-5><h5 id=headline-27>打开路径名 (path) 来打开 IPC</h5><div id=outline-text-headline-27 class=outline-text-5><p>FIFO、fcntl、Unix 域套接字、门；</p></div></div><div id=outline-container-headline-28 class=outline-5><h5 id=headline-28>打开 POSIX IPC 名字来打开 IPC</h5><div id=outline-text-headline-28 class=outline-text-5><p>POSIX 消息队列、POSIX 命令信号量、POSIX 共享内存；</p></div></div><div id=outline-container-headline-29 class=outline-5><h5 id=headline-29>基于 IP 地址和端口号来打开 IPC</h5><div id=outline-text-headline-29 class=outline-text-5><p>TCP 套接字、UDP 套接字；</p></div></div><div id=outline-container-headline-30 class=outline-5><h5 id=headline-30>基于 key _t 键打开 IPC</h5><div id=outline-text-headline-30 class=outline-text-5><p>System V 消息队列、System V 信号量、System V 共享内存；</p></div></div></div></div><div id=outline-container-headline-31 class=outline-4><h4 id=headline-31>打开 IPC 后的标识</h4><div id=outline-text-headline-31 class=outline-text-4><div id=outline-container-headline-32 class=outline-5><h5 id=headline-32>描述符</h5><div id=outline-text-headline-32 class=outline-text-5><p>管道、FIFO、fcntl、POSIX 共享内存、TCP 套接字、UDP 套接字、Unix 虞域套接字、门</p></div></div><div id=outline-container-headline-33 class=outline-5><h5 id=headline-33>相应形式的指针</h5><div id=outline-text-headline-33 class=outline-text-5><ul><li>POSIX 互斥锁</li><li>POSIX 条件变量</li><li>POSIX 读写锁</li><li>POSIX 命名信号量</li><li>POSIX 基于内存的信号量</li></ul></div></div><div id=outline-container-headline-34 class=outline-5><h5 id=headline-34>值</h5><div id=outline-text-headline-34 class=outline-text-5><ul><li>POSIX 消息队列</li></ul></div></div><div id=outline-container-headline-35 class=outline-5><h5 id=headline-35>System V IPC 标识符</h5><div id=outline-text-headline-35 class=outline-text-5><ul><li>System V 消息队列</li><li>System V 信号量</li><li>System V 共享内存</li></ul></div></div><div id=outline-container-headline-36 class=outline-5><h5 id=headline-36>RPC 句柄</h5><div id=outline-text-headline-36 class=outline-text-5><p>Sun RPC</p></div></div></div></div><div id=outline-container-headline-37 class=outline-4><h4 id=headline-37>需要定义结构体变量–指针</h4><div id=outline-text-headline-37 class=outline-text-4><p>除了 Posix 信号量需要定义成指针，其他的都需要定义成变量。</p><div id=outline-container-headline-38 class=outline-5><h5 id=headline-38>结构体</h5><div id=outline-text-headline-38 class=outline-text-5><p>互斥锁、条件变量、读写锁、Posix 无名信号量、Posix 消息队列、
描述符、Posix 共享内存、</p></div></div><div id=outline-container-headline-39 class=outline-5><h5 id=headline-39>指针</h5><div id=outline-text-headline-39 class=outline-text-5><p>Posix 命名信号量、mmap、</p></div></div></div></div></div></div><div id=outline-container-headline-40 class=outline-3><h3 id=headline-40>fork、exec、exit 对 IPC 的影响</h3><div id=outline-text-headline-40 class=outline-text-3><ul><li>无名同步变量（互斥锁、条件变量、读写锁、基于内存的信号量），从一个具有多线程的进程中调用 fork 将变得
混乱不堪；如果这些变量驻留在共享内存区中，而且创建时设置了进程共享属性，那么对于能访问该共享内存区的
任意进程来说，其任意线程能继续访问这些变量。</li><li>System V IPC 的三种形式没有打开或关闭的说法，只需知道其标识符即可访问。</li></ul><table><thead><tr><th>IPC 类型</th><th>fork</th><th>exec</th><th>_exit</th></tr></thead><tbody><tr><td>管道、FIFO</td><td>子进程取得父进程的所有打开着的文件描述符的副本</td><td>所有打开着的文件描述符继续打开，除非设置了 FD _CLOEXEC 位</td><td>关闭所有打开着的描述符，最后一个关闭时删除管道或 FIFO 中残留的数据</td></tr><tr><td>POSIX 消息队列</td><td>子进程取得父进程的所有打开着的消息队列描述符的副本</td><td>关闭所有打开着消息队列描述符</td><td>关闭所有打开着的消息队列描述符</td></tr><tr><td>System V 消息队列</td><td>–</td><td>–</td><td>–</td></tr></tbody><tbody><tr><td>POSIX 互斥锁和条件变量</td><td>若驻留在共享内存区中而且具有进程间共享属性，则共享</td><td>除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失</td><td>除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失</td></tr><tr><td>POSIX 读写锁</td><td>若驻留在共享内存区中而且具有进程间共享属性，则共享</td><td>除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失</td><td>除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失</td></tr><tr><td>POSIX 基于内存的信号量</td><td>若驻留在共享内存区中而且具有进程间共享属性，则共享</td><td>除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失</td><td>除非在继续打开着的共享内存区中而且具有进程间共享属性，否则消失</td></tr><tr><td>POSIX 命名信号量</td><td>父进程中所有打开着的命名信号量在子进程中继续打开着</td><td>关闭所有打开着的命名信号量</td><td>关闭所有打开着的命名信号量</td></tr><tr><td>fcntl 记录锁</td><td>子进程不继承父进程持有的锁</td><td>只要描述符继续打开着，锁就不变</td><td>解开由进程持有的所有未处理的锁</td></tr><tr><td>System V 信号量</td><td>子进程中所有 semadj 值都置位 0</td><td>所有 semadj 值都携入新进程</td><td>所有 semadj 值都加到相应的信号量值上</td></tr></tbody><tbody><tr><td>mmap 内存映射</td><td>父进程的内存映射存留到子进程中</td><td>去除内存映射</td><td>去除内存映射</td></tr><tr><td>POSIX 共享内存区</td><td>父进程中内存映射存留到子进程中</td><td>去除内存映射</td><td>去除内存映射</td></tr><tr><td>System V 共享内存区</td><td>附接着的共享内存区在子进程中继续附接着</td><td>断开所有附接着的共享内存区</td><td>断开所有附接着的共享内存区</td></tr></tbody><tbody><tr><td>门</td><td>子进程取得父进程的所有打开着的描述符，但是客户在门描述符上激活其过程时，只有父进程是服务器</td><td>所有门描述符都应关闭，因为它们创建时设置了 FD _CLOEXEC 位</td><td>关闭所有打开着的描述符</td></tr></tbody></table></div></div><div id=outline-container-headline-41 class=outline-3><h3 id=headline-41>锁释放</h3><div id=outline-text-headline-41 class=outline-text-3><div id=outline-container-headline-42 class=outline-4><h4 id=headline-42>内核自动释放</h4><div id=outline-text-headline-42 class=outline-text-4><p>持有某个锁的进程没有释放就终止，内核自动释放该锁；
fcntl 记录锁、System V 信号量（可选项）</p></div></div><div id=outline-container-headline-43 class=outline-4><h4 id=headline-43>无法释放锁</h4><div id=outline-text-headline-43 class=outline-text-4><p>互斥锁、条件变量、读写锁、POSIX 信号量</p></div></div></div></div><div id=outline-container-headline-44 class=outline-3><h3 id=headline-44>进程、线程与共享信息</h3><div id=outline-text-headline-44 class=outline-text-3><p>没有任何东西限制任何 IPC 技术只适用于两个进程。</p><ol><li>两个进程共享存留于文件系统中某个文件上的某些信息。为了访问这些信息，每个进程都得穿越内核（例如
read、write、lssk 等）；需要某种形式的同步，如记录锁。</li><li>两个进程共享驻留于内核的某些信息，访问共享信息的每次操作都涉及对内核的一次系统调用。管道、
System V 消息队列、System V 信号量均是；</li><li>两个进程有一个双方都能访问的共享存储区，需要某种形式的同步（信号量等）。每个进程一旦设置好该共享
内存区，就能根本不涉及内核而访问其中的数据。</li></ol></div></div></div></div><div id=outline-container-headline-45 class=outline-2><h2 id=headline-45>进程 – 线程</h2><div id=outline-text-headline-45 class=outline-text-2><div id=outline-container-headline-46 class=outline-3><h3 id=headline-46>设计线程的原因：</h3><div id=outline-text-headline-46 class=outline-text-3><ol><li>fork 的开销很大。内存映射要从父进程复制到子进程，所有描述符要在子进程复制一份。尽管存在写时复制
(copy-on-write) 的技术，fork 的开销仍然很大。</li><li>fork 子进程后，需要使用 IPC 在父子进程之间传递信息。</li></ol></div></div><div id=outline-container-headline-47 class=outline-3><h3 id=headline-47>线程共享全局内存空间</h3><div id=outline-text-headline-47 class=outline-text-3><p>一个进程内的所有线程共享同一个全局内存空间。使得线程间很容易共享信息，但这种易用性也带来了同步
(synchronization) 问题。</p></div></div><div id=outline-container-headline-48 class=outline-3><h3 id=headline-48>线程共享的资源</h3><div id=outline-text-headline-48 class=outline-text-3><ul><li>全局内存空间</li><li>进程指令</li><li>打开的文件</li><li>信号处理程序和信号处置</li><li>当前工作目录</li><li>用户 ID 和 组 ID</li></ul></div></div><div id=outline-container-headline-49 class=outline-3><h3 id=headline-49>线程私有资源</h3><div id=outline-text-headline-49 class=outline-text-3><ul><li>线程 ID</li><li>寄存器集合，包括程序计数器和栈指针</li><li>栈，存放局部变量和返回地址</li><li>errno</li><li>信号掩码</li><li>优先级</li></ul></div></div></div></div><div id=outline-container-headline-50 class=outline-2><h2 id=headline-50>系统开销</h2><div id=outline-text-headline-50 class=outline-text-2><table><tbody><tr><td>执行一般命令</td><td>1ns = 1/1,000,000,000s</td></tr><tr><td>从 L1 级缓存读</td><td>0.5ns</td></tr><tr><td>分支误预测</td><td>5ns</td></tr><tr><td>L2 级缓存读</td><td>7ns</td></tr><tr><td>加锁、解锁</td><td>25ns</td></tr><tr><td>主存中读</td><td>100ns</td></tr><tr><td>1Gbps 网络中发 2k 数据</td><td>20,000ns</td></tr><tr><td>主存中读 1MB 序列</td><td>250,000ns</td></tr><tr><td>查找从硬盘中读</td><td>8,000,000ns</td></tr><tr><td>硬盘读 1MB 序列</td><td>20,000,000ns</td></tr><tr><td>报文从美国发到欧洲并返回</td><td>150ms = 150,000,000ns</td></tr></tbody></table></div></div><div id=outline-container-headline-51 class=outline-2><h2 id=headline-51>练习代码</h2><div id=outline-text-headline-51 class=outline-text-2><div id=outline-container-headline-52 class=outline-3><h3 id=headline-52>基本函数</h3><div id=outline-text-headline-52 class=outline-text-3><div class="src src-c"><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/acct.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/time.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pwd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/resource.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/times.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;mqueue.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>globalNum</span> <span class=o>=</span> <span class=mi>522</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>echoAllID</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>processName</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>forkTest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>vforkTest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>exitTest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>echoExitStatus</span><span class=p>(</span><span class=kt>int</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>noZombie</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>accountingRecored</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>compt2ulong</span><span class=p>(</span><span class=n>comp_t</span> <span class=n>comptime</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>showAcctTime</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testExecl</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testSystem</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testUserloginname</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>checkTime</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>processName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>endtv</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testNice</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>showProcessTime</span><span class=p>(</span><span class=n>clock_t</span> <span class=n>realtime</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>struct</span> <span class=n>tms</span> <span class=o>*</span><span class=n>tms_start</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>struct</span> <span class=n>tms</span> <span class=o>*</span><span class=n>tms_end</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testCmdTime</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testZombie</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printfRevSignal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testSignal</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testPipe</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>test_mq</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanBuf</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>releaseResource</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>atexit</span><span class=p>(</span><span class=n>releaseResource</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>atexit</span><span class=p>(</span><span class=n>cleanBuf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;stdin&#39;s fileno </span><span class=se>\t</span><span class=s> %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fileno</span><span class=p>(</span><span class=n>stdin</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;stdout&#39;s fileno </span><span class=se>\t</span><span class=s> %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fileno</span><span class=p>(</span><span class=n>stdout</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;stderr&#39;s fileno </span><span class=se>\t</span><span class=s> %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>fileno</span><span class=p>(</span><span class=n>stderr</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>//echoAllID(argv[0]);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//forkTest();
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//vforkTest();
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//exitTest();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//noZombie();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//accountingRecored();
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//showAcctTime();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//testExecl();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//testSystem();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//testUserloginname();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//testNice();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//testCmdTime();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//testZombie();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//testSignal();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>test_mq</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>testPipe</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>echoAllID</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>processName</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>ppid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uid_t</span> <span class=n>uid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>uid_t</span> <span class=n>euid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>gid_t</span> <span class=n>gid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>gid_t</span> <span class=n>egid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//Note that none of these functions has an error return.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pid</span> <span class=o>=</span> <span class=n>getpid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ppid</span> <span class=o>=</span> <span class=n>getppid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>uid</span> <span class=o>=</span> <span class=n>getuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>euid</span> <span class=o>=</span> <span class=n>geteuid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>gid</span> <span class=o>=</span> <span class=n>getgid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>egid</span> <span class=o>=</span> <span class=n>getegid</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;The %s process</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;pid = %d, ppid = %d</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;uid = %d, euid = %d</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;gid = %d, egid = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>processName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>pid</span><span class=p>,</span> <span class=n>ppid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>uid</span><span class=p>,</span> <span class=n>euid</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>gid</span><span class=p>,</span> <span class=n>egid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>forkTest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>99</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello Kyle!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//The write function is not buffered, its data is written once to 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//standard output before fork.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>((</span><span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>!=</span>
</span></span><span class=line><span class=cl>            <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//The standard I/O library is buffered. Standard output is line 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//buffered if it&#39;s connected to a terminal device; otherwise,
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//it&#39;s fully buffered.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Before fork</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//The printf before the fork is called once, but the line remains
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//in buffer when fork is called. This is then copied into the child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//when the patent&#39;s data space is copied to child. Both parent and
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//the child now have a standard I/O buffer with this line in it. 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//The second printf, right before the exit, just appends its data 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//to the existing buffer. When each process terminates, its copy 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//of the buffer is funally flushed.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//changes to variables in a child process do not affect the value
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//of the variables in the parent process.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//sleep(2);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>num</span> <span class=o>=</span> <span class=mi>1314</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>globalNum</span> <span class=o>=</span> <span class=mi>520</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//Let the child process execute, but there is no guarantee.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//exit(0);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;pid = %d, ppid = %d: num = %d, globalNum = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>getpid</span><span class=p>(),</span> <span class=n>getppid</span><span class=p>(),</span> <span class=n>num</span><span class=p>,</span> <span class=n>globalNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//exit(0);
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>vforkTest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>99</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello Kyle!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//child will not copy the memory of parent after vfork, just use it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Before vfork</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>vfork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//modify parent&#39;s varables
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>num</span> <span class=o>=</span> <span class=mi>1314</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>globalNum</span> <span class=o>=</span> <span class=mi>520</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span><span class=c1>//parent will not execute before child call exec or exit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//_exit will not flush the buffer, but exit will
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;pid = %d, ppid = %d: num = %d, globalNum = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>getpid</span><span class=p>(),</span> <span class=n>getppid</span><span class=p>(),</span> <span class=n>num</span><span class=p>,</span> <span class=n>globalNum</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>echoExitStatus</span><span class=p>(</span><span class=kt>int</span> <span class=n>status</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>WIFEXITED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;normal termination, exit status = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>WEXITSTATUS</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>WIFSIGNALED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;abnormal termination, exit status %d.%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>WTERMSIG</span><span class=p>(</span><span class=n>status</span><span class=p>),</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef WCOREDUMP
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>(</span><span class=n>WCOREDUMP</span><span class=p>(</span><span class=n>status</span><span class=p>))</span> <span class=o>?</span> <span class=s>&#34;(a core file was generated)&#34;</span> <span class=o>:</span> <span class=s>&#34;(no core)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=s>&#34;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>WIFSTOPPED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;process stopped by signal %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>WSTOPSIG</span><span class=p>(</span><span class=n>status</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>WIFCONTINUED</span><span class=p>(</span><span class=n>status</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;process continued</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>exitTest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>status</span><span class=p>)</span> <span class=o>!=</span> <span class=n>pid</span><span class=p>)</span><span class=c1>//child exit, variable pid in here is parent&#39;s pid variable
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>echoExitStatus</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>abort</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>status</span><span class=p>)</span> <span class=o>!=</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>echoExitStatus</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//status /= 0;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>status</span><span class=p>)</span> <span class=o>!=</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>echoExitStatus</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>noZombie</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span><span class=c1>//first child do nothing and exit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//it&#39;s parent is the first child
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//exec the process
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;I am the second child. pid=%d,ppid=%d.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>getpid</span><span class=p>(),</span> <span class=n>getppid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//I am not the parent of the second child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;I am the parent! And I don&#39;t need to see the child.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//if(waitpid(pid, &amp;status, WNOHANG) != pid)//nonblocking
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>!=</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>echoExitStatus</span><span class=p>(</span><span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//进程统计信息
</span></span></span><span class=line><span class=cl><span class=c1>//进程的各类信息在进程创建时初始化（由內核保存在进程表中），进程终止时写
</span></span></span><span class=line><span class=cl><span class=c1>//一个会计记录。
</span></span></span><span class=line><span class=cl><span class=c1>//a、永不终止的进程没有会计记录；
</span></span></span><span class=line><span class=cl><span class=c1>//b、只知道进程的起始时间，以日历时间来记，精确到秒，在 1s 内可能同时创建
</span></span></span><span class=line><span class=cl><span class=c1>//了很多进程）和运行时间（以 clock ticks 来记，每秒中有 60～128 ticks）
</span></span></span><span class=line><span class=cl><span class=c1>//但仅知道终止顺序（在会计文件中以进程的终止顺序来记录）无法得知进程精确的
</span></span></span><span class=line><span class=cl><span class=c1>//起始时间
</span></span></span><span class=line><span class=cl><span class=c1>//accounting recored 对应着进程而不是程序；一个进程多次调用 exec ，最后只
</span></span></span><span class=line><span class=cl><span class=c1>//会记录最后一个进程的命令名但运行时间是所有 exec 进程之和。fork 多次会记录
</span></span></span><span class=line><span class=cl><span class=c1>//多个 accounting recored
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>accountingRecored</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//parent
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=mi>25</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//first child
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>abort</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//second child
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>execl</span><span class=p>(</span><span class=s>&#34;/bin/dd&#34;</span><span class=p>,</span> <span class=s>&#34;dd&#34;</span><span class=p>,</span> <span class=s>&#34;if=/etc/passwd&#34;</span><span class=p>,</span> <span class=s>&#34;of=/dev/null&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s>&#34;count=1000&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//third child
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sleep</span><span class=p>(</span><span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sleep</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span> <span class=c1>//forth child
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>kill</span><span class=p>(</span><span class=n>getpid</span><span class=p>(),</span> <span class=n>SIGKILL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=nf>compt2ulong</span><span class=p>(</span><span class=n>comp_t</span> <span class=n>comptime</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>val</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>           <span class=n>exp</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=n>comptime</span> <span class=o>&amp;</span> <span class=mh>0x7fff</span><span class=p>;</span> <span class=c1>//13 位小数部分
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>exp</span> <span class=o>=</span> <span class=p>(</span><span class=n>comptime</span> <span class=o>&gt;&gt;</span> <span class=mi>13</span><span class=p>)</span> <span class=o>&amp;</span> <span class=mi>7</span><span class=p>;</span> <span class=c1>//指数部分
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>exp</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span> <span class=o>*=</span> <span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>showAcctTime</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>acct</span> <span class=n>acdata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILE</span>        <span class=o>*</span><span class=n>fp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//需要安装 acct 程序。且需要 root 权限才能 accton on/off 以及读取记录文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>((</span><span class=n>fp</span> <span class=o>=</span> <span class=n>fopen</span><span class=p>(</span><span class=s>&#34;/var/log/account/pacct&#34;</span><span class=p>,</span> <span class=s>&#34;r&#34;</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;can&#39;t open the file</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//fflush(STDOUT_FILENO);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//write(STDOUT_FILENO, &#34;can&#39;t open the file\n&#34;, sizeof(&#34;can&#39;t open the file\n&#34;) -1);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span> <span class=o>==</span> <span class=n>fread</span><span class=p>(</span><span class=o>&amp;</span><span class=n>acdata</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>acct</span><span class=p>),</span> <span class=mi>1</span><span class=p>,</span> <span class=n>fp</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s etime=%ld io=%ld %c %c %c %c</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>acdata</span><span class=p>.</span><span class=n>ac_comm</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>compt2ulong</span><span class=p>(</span><span class=n>acdata</span><span class=p>.</span><span class=n>ac_etime</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                <span class=n>compt2ulong</span><span class=p>(</span><span class=n>acdata</span><span class=p>.</span><span class=n>ac_io</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                <span class=n>acdata</span><span class=p>.</span><span class=n>ac_flag</span> <span class=o>&amp;</span> <span class=n>AFORK</span> <span class=o>?</span> <span class=sc>&#39;F&#39;</span> <span class=o>:</span> <span class=sc>&#39; &#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>acdata</span><span class=p>.</span><span class=n>ac_flag</span> <span class=o>&amp;</span> <span class=n>ASU</span>   <span class=o>?</span> <span class=sc>&#39;S&#39;</span> <span class=o>:</span> <span class=sc>&#39; &#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>acdata</span><span class=p>.</span><span class=n>ac_flag</span> <span class=o>&amp;</span> <span class=n>ACORE</span> <span class=o>?</span> <span class=sc>&#39;C&#39;</span> <span class=o>:</span> <span class=sc>&#39; &#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>acdata</span><span class=p>.</span><span class=n>ac_flag</span> <span class=o>&amp;</span> <span class=n>AXSIG</span> <span class=o>?</span> <span class=sc>&#39;X&#39;</span> <span class=o>:</span> <span class=sc>&#39; &#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testExecl</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//exec 函数第一个参数只想可执行文件 execute file
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//argv 是可执行文件的参数列表，列表的第一个参数约定写成可执行文件的
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//文件名。但测试发现随意写好像并没有什么影响，如下所示
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>execl</span><span class=p>(</span><span class=s>&#34;/bin/ls&#34;</span><span class=p>,</span> <span class=s>&#34;qwe&#34;</span><span class=p>,</span> <span class=s>&#34;-l&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>status</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;status=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testSystem</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>//system() 函数用于执行 shell command
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//system 会调用fork、exec、waitpid 函数，且进行了必要的错误处理和信号处理
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>status</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>status</span> <span class=o>=</span> <span class=n>system</span><span class=p>(</span><span class=s>&#34;date&#34;</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;status = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>status</span> <span class=o>=</span> <span class=n>system</span><span class=p>(</span><span class=s>&#34;nosuchcommand&#34;</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;status = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>status</span> <span class=o>=</span> <span class=n>system</span><span class=p>(</span><span class=s>&#34;who; exit 44&#34;</span><span class=p>))</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34;status = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>status</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testUserloginname</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>name</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>envname</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>passwd</span> <span class=o>*</span><span class=n>ppasswd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>!=</span> <span class=n>setenv</span><span class=p>(</span><span class=s>&#34;LOGNAME&#34;</span><span class=p>,</span> <span class=s>&#34;yym&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;set the logname to yym</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>//getlogin 得到用户的登录名。且一个 user ID 可能对应多个登录名，
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//因为他们使用不同的 shell 等原因。
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//环境变量中的 LOGNAME 由 login(1) 从登录名获取，
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//但是用户可以更改，所以不可取。
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=nb>NULL</span> <span class=o>!=</span> <span class=p>(</span><span class=n>name</span> <span class=o>=</span> <span class=n>getlogin</span><span class=p>()))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;login name = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>envname</span> <span class=o>=</span> <span class=n>getenv</span><span class=p>(</span><span class=s>&#34;LOGNAME&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nb>NULL</span> <span class=o>!=</span> <span class=n>envname</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;envname = %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>envname</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//从文件 passwd 中获取用户的信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ppasswd</span> <span class=o>=</span> <span class=n>getpwnam</span><span class=p>(</span><span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nb>NULL</span> <span class=o>!=</span> <span class=n>ppasswd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;name=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;passwd=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_passwd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;user information=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_gecos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;dir=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_dir</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;shell=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_shell</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;execute getlogin failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>//测试读取其他用户的信息
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//可以获取到，但是由于密码并不保存在 passwd 文件中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//所以好像没有安全隐患
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>ppasswd</span> <span class=o>=</span> <span class=n>getpwnam</span><span class=p>(</span><span class=s>&#34;boy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=nb>NULL</span> <span class=o>!=</span> <span class=n>ppasswd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;name=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;passwd=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_passwd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;user information=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_gecos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;dir=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_dir</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;shell=%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ppasswd</span><span class=o>-&gt;</span><span class=n>pw_shell</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>checkTime</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>processName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>endtv</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=o>*</span><span class=n>count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>timeval</span> <span class=n>tv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>//获取时间。结构体 timeval 中有两个成员变量 tv_sec、tv_usec
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>gettimeofday</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tv</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>tv</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>&gt;=</span> <span class=n>endtv</span><span class=o>-&gt;</span><span class=n>tv_sec</span> <span class=o>&amp;&amp;</span> <span class=n>tv</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>&gt;=</span> <span class=n>endtv</span><span class=o>-&gt;</span><span class=n>tv_usec</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%10s count %lld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>processName</span><span class=p>,</span> <span class=o>*</span><span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testNice</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>char</span> <span class=o>*</span><span class=n>processname</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>timeval</span> <span class=n>endtv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>priority</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>niceval</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>gettimeofday</span><span class=p>(</span><span class=o>&amp;</span><span class=n>endtv</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>endtv</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>+=</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>//让进程运行 10s
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>processname</span> <span class=o>=</span> <span class=s>&#34;child&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//获取进程的调度优先级
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>priority</span> <span class=o>=</span> <span class=n>getpriority</span><span class=p>(</span><span class=n>PRIO_PROCESS</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;child process priority = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>priority</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//进程默认的 nice 值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>niceval</span> <span class=o>=</span> <span class=n>sysconf</span><span class=p>(</span><span class=n>_SC_NZERO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;process default nice value = %d,&#34;</span>
</span></span><span class=line><span class=cl>           <span class=s>&#34;child nice value = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=n>niceval</span><span class=p>,</span> <span class=n>nice</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//nice 值的范围 -20～19，nice 参数为增加的值。且返回值为新的 nice 值。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//由于有可能为 -1，所以需要先将 errno 清零，然后当 nice 返回 -1 且
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//errno 不为 0 时才表示调整失败。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>errno</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>nice</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=mi>0</span> <span class=o>!=</span> <span class=n>errno</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;child faild to change the nice value</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;child new nice val is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>nice</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>processname</span> <span class=o>=</span> <span class=s>&#34;parent&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>priority</span> <span class=o>=</span> <span class=n>getpriority</span><span class=p>(</span><span class=n>PRIO_PROCESS</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;parent process priority = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>priority</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>niceval</span> <span class=o>=</span> <span class=n>sysconf</span><span class=p>(</span><span class=n>_SC_NZERO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;parent process default nice value = %d,&#34;</span><span class=p>,</span> <span class=n>nice</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%10.10s count warp</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>processname</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>checkTime</span><span class=p>(</span><span class=n>processname</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>endtv</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>showProcessTime</span><span class=p>(</span><span class=n>clock_t</span> <span class=n>realtime</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>struct</span> <span class=n>tms</span> <span class=o>*</span><span class=n>tms_start</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>struct</span> <span class=n>tms</span> <span class=o>*</span><span class=n>tms_end</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=kt>long</span> <span class=n>clktck</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>clktck</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>clktck</span> <span class=o>=</span> <span class=n>sysconf</span><span class=p>(</span><span class=n>_SC_CLK_TCK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>clktck</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;get the clock tick failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>printf</span><span class=p>(</span><span class=s>&#34;the clock tick is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34; real:  %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>realtime</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34; user:  %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tms_end</span><span class=o>-&gt;</span><span class=n>tms_utime</span> <span class=o>-</span> <span class=n>tms_start</span><span class=o>-&gt;</span><span class=n>tms_utime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34; sys:  %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tms_end</span><span class=o>-&gt;</span><span class=n>tms_stime</span> <span class=o>-</span> <span class=n>tms_start</span><span class=o>-&gt;</span><span class=n>tms_stime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34; cuser:  %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tms_end</span><span class=o>-&gt;</span><span class=n>tms_cutime</span> <span class=o>-</span> <span class=n>tms_start</span><span class=o>-&gt;</span><span class=n>tms_cutime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34; csys:  %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tms_end</span><span class=o>-&gt;</span><span class=n>tms_cstime</span> <span class=o>-</span> <span class=n>tms_start</span><span class=o>-&gt;</span><span class=n>tms_cstime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34; csysstart:  %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tms_start</span><span class=o>-&gt;</span><span class=n>tms_cstime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34; csysend:  %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>tms_end</span><span class=o>-&gt;</span><span class=n>tms_cstime</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=n>clktck</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testCmdTime</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>clock_t</span> <span class=n>walltimestart</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>clock_t</span> <span class=n>walltimeend</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>tms</span> <span class=n>tms_start</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>tms</span> <span class=n>tms_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=p>(</span><span class=n>walltimestart</span> <span class=o>=</span> <span class=n>time</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tms_start</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34; wallstart:  %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>walltimestart</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>system</span><span class=p>(</span><span class=s>&#34;dd if=/etc/passwd of=/dev/null count=10000&#34;</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=p>(</span><span class=n>walltimeend</span> <span class=o>=</span> <span class=n>time</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tms_end</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s>&#34; wallend:  %7.2f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>walltimeend</span><span class=p>)</span> <span class=o>/</span> <span class=p>(</span><span class=kt>double</span><span class=p>)</span><span class=mi>100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>showProcessTime</span><span class=p>(</span><span class=n>walltimeend</span> <span class=o>-</span> <span class=n>walltimestart</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tms_start</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tms_end</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testZombie</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>sleep</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>system</span><span class=p>(</span><span class=s>&#34;ps -o pid,ppid,state,tty,command&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//解释器文件--将参数重新解释成了新的 shell 语句
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>printfRevSignal</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>SIGRTMIN</span> <span class=o>==</span> <span class=n>signo</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Received SIGUSER1</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>SIGRTMIN</span><span class=o>+</span><span class=mi>1</span> <span class=o>==</span> <span class=n>signo</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Received SIGUSER2</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Received signal %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testSignal</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>pSig</span><span class=p>)(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>//signal 函数返回要设置的信号原来的信号处理函数
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span><span class=p>(</span><span class=n>SIG_ERR</span> <span class=o>==</span> <span class=p>(</span><span class=n>pSig</span> <span class=o>=</span> <span class=n>signal</span><span class=p>(</span><span class=n>SIGRTMIN</span><span class=p>,</span> <span class=n>printfRevSignal</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;previous signal pointer1 = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pSig</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>SIG_ERR</span> <span class=o>==</span> <span class=p>(</span><span class=n>pSig</span> <span class=o>=</span> <span class=n>signal</span><span class=p>(</span><span class=n>SIGRTMIN</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>printfRevSignal</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;previous signal pointer = %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pSig</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>//Linux 上也定义了信号 SIGCLD 信号；其有可能在其他系统上导致进行反复调用
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//信号处理函数而导致堆栈溢出，进程终止。
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//if(SIG_ERR == (pSig = signal(SIGCLD, printfRevSignal)));
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//可以利用 sigaction 函数设置 SA_NOCLDWAIT 来避免产生僵死进程
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pause</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//不可靠信号：（最主要的特点：信号可能在任何时候产生）
</span></span></span><span class=line><span class=cl><span class=c1>//1. 信号可能会丢失；信号产生后进程却无法得到通知
</span></span></span><span class=line><span class=cl><span class=c1>//2. 不具备阻塞信号的能力；进程只能捕捉或者忽略
</span></span></span><span class=line><span class=cl><span class=c1>//3. 信号处理只生效一次，然后恢复系统默认
</span></span></span><span class=line><span class=cl><span class=c1>//4. 系统执行慢速的系统调用，若接收到中断信号，则终止系统调用，并返回出错。
</span></span></span><span class=line><span class=cl><span class=c1>//   UNIX 系统后来支持自动重启系统调用：ioctl,read,readv,write,writev,wait
</span></span></span><span class=line><span class=cl><span class=c1>//   否则用户就必须每次进行出错处理，如果是中断则重启系统调用
</span></span></span><span class=line><span class=cl><span class=c1>//5. 信号处理函数中调用的函数要是可重入的，即异步信号安全的
</span></span></span><span class=line><span class=cl><span class=c1>//   不可重入的函数：
</span></span></span><span class=line><span class=cl><span class=c1>//                   a) 使用静态数据结构；
</span></span></span><span class=line><span class=cl><span class=c1>//                   b) 调用 malloc,free ；会使用静态变量（链表）来维护内存信息
</span></span></span><span class=line><span class=cl><span class=c1>//                   c) 调用标准 I/O 函数。标准 I/O 函数大都使用了全局数据结构
</span></span></span><span class=line><span class=cl><span class=c1>//6. 每个线程只有一个 errno ，而中断处理函数可能更改 errno ；
</span></span></span><span class=line><span class=cl><span class=c1>//   所以应当在中断处理函数前保存 errno，处理完成后返回 errno。
</span></span></span><span class=line><span class=cl><span class=c1>//7. 更新全局数据结构时，阻塞可能导致异常的信号
</span></span></span><span class=line><span class=cl><span class=c1>//8. alarm 设置一个定时器，在定时时间到后产生一个 SIGALRM 信号。
</span></span></span><span class=line><span class=cl><span class=c1>//   每个进程只能有一个闹钟时间。新设置的闹钟时间会覆盖原来的。
</span></span></span><span class=line><span class=cl><span class=c1>//   在 SIGALRM 的信号处理函数要检查之前的时间，且要保存返回之前的信号处理函数
</span></span></span><span class=line><span class=cl><span class=c1>//9. 设置 SIGALRM 信号处理函数要在设置定时器之前，否则有可能定时器时间到，然后
</span></span></span><span class=line><span class=cl><span class=c1>//   就会执行默认处理，终止进程。
</span></span></span><span class=line><span class=cl><span class=c1>//10. 设置定时器后接系统调用，可能存在竞争条件（假如想要利用该定时器来结束之后
</span></span></span><span class=line><span class=cl><span class=c1>//    的系统调用）。当系统的负载很重时，可能定时间到后，处理完中断处理函数后，
</span></span></span><span class=line><span class=cl><span class=c1>//    仍然没有运行之后的系统调用。 race condition
</span></span></span><span class=line><span class=cl><span class=c1>//    使用 setjmp,longjmp 来解决时，如果 SIGALRM 中断了其他的中断处理函数，那么
</span></span></span><span class=line><span class=cl><span class=c1>//    longjmp 会提早结束其他的中断处理函数，而导致异常。
</span></span></span><span class=line><span class=cl><span class=c1>//11. 在信号产生(generation)和递送(delivery)之间的时间间隔内，称信号是未决的(pending)；
</span></span></span><span class=line><span class=cl><span class=c1>//当进程对信号采取某种动作时，我们称向进程递送了一个信号。
</span></span></span><span class=line><span class=cl><span class=c1>//调用 sigprocmask 阻塞某一个信号，之后产生该信号，那么该信号是阻塞不能传递的，
</span></span></span><span class=line><span class=cl><span class=c1>//因而也一定是未决的，可以通过函数 sigpending 来获取所有未决的信号。
</span></span></span><span class=line><span class=cl><span class=c1>//12. 使用 sigaction 来检查、修改指定信号的处理动作。取代 signal 函数。
</span></span></span><span class=line><span class=cl><span class=c1>//    更改一个信号的处理动作后会一直生效，直到下一次显示调用该函数更改。
</span></span></span><span class=line><span class=cl><span class=c1>//    一个信号引发了其处理动作，然后该信号会被阻塞直到处理完成返回。除非设置了
</span></span></span><span class=line><span class=cl><span class=c1>//    saflag 的 SA_NODEFER 标志
</span></span></span><span class=line><span class=cl><span class=c1>//    sa_handler 和 sa_sigaction 可能使用同一存储区，用户只能使用其中一个
</span></span></span><span class=line><span class=cl><span class=c1>//    默认不重新启动被中断的系统调用，除非设置了 SA_RESTART 标志
</span></span></span><span class=line><span class=cl><span class=c1>//13. 调用 sigprocmask 恢复之前的进程屏蔽信号集，如果有任何未决的、不再阻塞的信号，
</span></span></span><span class=line><span class=cl><span class=c1>//    则在 sigprocmask 返回前，至少将其中之一递送给进程。
</span></span></span><span class=line><span class=cl><span class=c1>//    在线程中使用函数 pthread_sigmask 来设置。
</span></span></span><span class=line><span class=cl><span class=c1>//    每个线程都有一个信号屏蔽字(signal mask)，规定了当前要阻塞送到进程的信号集。
</span></span></span><span class=line><span class=cl><span class=c1>//    内核在递送一个原来被阻塞的信号给进程时，而不是在产生信号时，才决定信号的处理方式，
</span></span></span><span class=line><span class=cl><span class=c1>//    于是，进程在信号递送给他之前仍可以改变对该信号的动作。
</span></span></span><span class=line><span class=cl><span class=c1>//14. 原子操作：先恢复信号屏蔽字，然后使进程休眠 -- sigsuspend；
</span></span></span><span class=line><span class=cl><span class=c1>//    函数返回时信号屏蔽字设置成调用之前的值
</span></span></span><span class=line><span class=cl><span class=c1>//    避免信号在恢复屏蔽字和使进程休眠之间丢失。
</span></span></span><span class=line><span class=cl><span class=c1>//    a) 保护代码临界区，使其不被特定的信号中断
</span></span></span><span class=line><span class=cl><span class=c1>//    b) 等待一个信号处理程序设置一个全局变量
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>testPipe</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>line</span><span class=p>[</span><span class=mi>4096</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>pline</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FILE</span> <span class=o>*</span><span class=n>fp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>setbuf</span><span class=p>(</span><span class=n>stdin</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=nb>NULL</span> <span class=o>==</span> <span class=p>(</span><span class=n>fp</span> <span class=o>=</span> <span class=n>fopen</span><span class=p>(</span><span class=s>&#34;/etc/passwd&#34;</span><span class=p>,</span> <span class=s>&#34;r&#34;</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>,</span> <span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pipe</span><span class=p>(</span><span class=n>fd</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>,</span> <span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>,</span> <span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>fgets</span><span class=p>(</span><span class=n>line</span><span class=p>,</span> <span class=mi>4094</span><span class=p>,</span> <span class=n>fp</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pline</span> <span class=o>=</span> <span class=n>line</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>n</span> <span class=o>=</span> <span class=n>strlen</span><span class=p>(</span><span class=n>pline</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;n=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=n>line</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span> <span class=o>!=</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>,</span> <span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>ferror</span><span class=p>(</span><span class=n>fp</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>,</span> <span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>waitpid</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>,</span> <span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>!=</span> <span class=n>STDIN_FILENO</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>//let STDIN_FILENO be the read side of the pipe
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=n>dup2</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>STDIN_FILENO</span><span class=p>)</span> <span class=o>!=</span> <span class=n>STDIN_FILENO</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>,</span> <span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>close</span><span class=p>(</span><span class=n>fd</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>execl</span><span class=p>(</span><span class=s>&#34;/bin/more&#34;</span><span class=p>,</span> <span class=s>&#34;more&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%s:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>__func__</span><span class=p>,</span> <span class=n>__LINE__</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//popen()
</span></span></span><span class=line><span class=cl><span class=c1>//pclose()
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//mkfifo()
</span></span></span><span class=line><span class=cl><span class=c1>//mkfifoat()
</span></span></span><span class=line><span class=cl><span class=c1>//创建 fifo 之后要使用 open 函数打开，且只读打开会阻塞到某个进程为写而打开该 fifo ,
</span></span></span><span class=line><span class=cl><span class=c1>//反之亦然。一个给定的 fifo 有多个写进程是很常见的，因此应该确保每次写都是原子操作，
</span></span></span><span class=line><span class=cl><span class=c1>//当写的数据大小不大于 PIPE_BUF 时可以确保是原子操作。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//msgget()
</span></span></span><span class=line><span class=cl><span class=c1>//msgctl()
</span></span></span><span class=line><span class=cl><span class=c1>//msgsnd()
</span></span></span><span class=line><span class=cl><span class=c1>//msgrev()
</span></span></span><span class=line><span class=cl><span class=c1>//mq_open
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>test_mq</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mqd_t</span> <span class=n>mqID</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>mq_attr</span> <span class=n>attr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mqID</span> <span class=o>=</span> <span class=n>mq_open</span><span class=p>(</span><span class=s>&#34;/msg_default&#34;</span><span class=p>,</span>  <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_EXCL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>S_IRUSR</span> <span class=o>|</span> <span class=n>S_IWUSR</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mqID</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d %d %d %d %d %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>EACCES</span><span class=p>,</span> <span class=n>EEXIST</span><span class=p>,</span> <span class=n>EINVAL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>EMFILE</span><span class=p>,</span> <span class=n>ENAMETOOLONG</span><span class=p>,</span> <span class=n>ENFILE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;create msg queue failed. errno = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>errno</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>EINVAL</span> <span class=o>==</span> <span class=n>errno</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;wrong</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rc</span> <span class=o>=</span> <span class=n>mq_getattr</span><span class=p>(</span><span class=n>mqID</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>attr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;get attr failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Maxmum message on queue: %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>attr</span><span class=p>.</span><span class=n>mq_maxmsg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;Maxmum message size: %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>attr</span><span class=p>.</span><span class=n>mq_msgsize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rc</span> <span class=o>=</span> <span class=n>mq_unlink</span><span class=p>(</span><span class=s>&#34;/msg_default&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//sem_init 匿名信号量
</span></span></span><span class=line><span class=cl><span class=c1>//sem_destory 销毁匿名信号量
</span></span></span><span class=line><span class=cl><span class=c1>//sem_open 命名信号量
</span></span></span><span class=line><span class=cl><span class=c1>//sem_close 关闭命令信号量
</span></span></span><span class=line><span class=cl><span class=c1>//sem_unlink 销毁命名信号量
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//shm_open
</span></span></span><span class=line><span class=cl><span class=c1>//mmap
</span></span></span><span class=line><span class=cl><span class=c1>//shm_unlink
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanBuf</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;pid:%d,clean all buf. Invoke by atexit</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>releaseResource</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;pid:%d,release all resource. Invoke by atexit</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div></div></div><div id=outline-container-headline-53 class=outline-3><h3 id=headline-53>IPC</h3><div id=outline-text-headline-53 class=outline-text-3><div class="src src-c"><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;errno.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/wait.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;mqueue.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/mman.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;semaphore.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define FIFOPATH &#34;/home/kyle/APUE/test/fifo&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fifotest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>opentest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>writetest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>mqtest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>shmtest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pthreadtest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>unlockInAtexit</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>mmaptest</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fcntltest</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_t</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_cond_t</span> <span class=n>cond</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>var</span> <span class=o>=</span> <span class=p>{</span><span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>,</span> <span class=n>PTHREAD_COND_INITIALIZER</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span>  <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//writetest();
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//fifotest();
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//opentest();
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//mqtest();
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//shmtest();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>//pthreadtest();
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//unlockInAtexit();
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//mmaptest();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>fcntltest</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>//sleep(10);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//打开只读的 fifo 时阻塞等待到某个进程为写而打开这个 fifo ；
</span></span></span><span class=line><span class=cl><span class=c1>//只写打开 fifo 会阻塞等待到某个进程为读而打开这个 fifo ；
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>fifotest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>umask</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//unlink(FIFOPATH);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//rc = mkfifo(FIFOPATH, 0777);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>unlink</span><span class=p>(</span><span class=n>FIFOPATH</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//rc = mkfifo(FIFOPATH, O_CREAT | O_EXCL | O_RDWR);//写法错误
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;mkfifo&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;second fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>FIFOPATH</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>//fd = open(FIFOPATH, O_WRONLY | O_APPEND);
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//fd = open(FIFOPATH, O_WRONLY);
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s>&#34;open fifo&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>num</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=s>&#34;Hello &#34;</span><span class=p>,</span> <span class=k>sizeof</span> <span class=s>&#34;Hello &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>num</span> <span class=o>!=</span> <span class=k>sizeof</span> <span class=s>&#34;Hello &#34;</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s>&#34;write fifo&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>num</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=s>&#34;I&#39;m kyle&#34;</span><span class=p>,</span> <span class=k>sizeof</span> <span class=s>&#34;I&#39;m kyle&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>FIFOPATH</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>//fd = open(FIFOPATH, O_WRONLY | O_APPEND);
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//fd = open(FIFOPATH, O_WRONLY);
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s>&#34;open fifo&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>num</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=s>&#34;World&#34;</span><span class=p>,</span> <span class=k>sizeof</span> <span class=s>&#34;World&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>num</span> <span class=o>!=</span> <span class=k>sizeof</span> <span class=s>&#34;World&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s>&#34;write fifo&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//pid = waitpid(pid, NULL, 0);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//if(pid != wait(NULL)) {
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//    perror(&#34;wait error&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//    exit(1);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//}
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;firest parent&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>FIFOPATH</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//fd = open(FIFOPATH, O_RDONLY);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span><span class=p>(</span><span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;child open fifo&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>s</span><span class=p>[</span><span class=mi>4096</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=sc>&#39;\0&#39;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>((</span><span class=n>num</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=mi>4096</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>len</span> <span class=o>+=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>printf</span><span class=p>(</span><span class=s>&#34;read num = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>//puts(s);
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>write</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>s</span><span class=p>,</span> <span class=n>num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>len</span> <span class=o>==</span> <span class=mi>22</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define OPENFILE &#34;/home/kyle/APUE/test/opentest.c&#34;
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>opentest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>umask</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>rc</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>OPENFILE</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>07777</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>rc</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=n>OPENFILE</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_CREAT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>rc</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;2 arg&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>writetest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>69</span><span class=p>;</span><span class=c1>//对应 &#39;E&#39; 的 ASCII 值，结果会在终端上打印出 E ；如果改成 999 那么会打印出一个汉字
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//MQ_OPEN_MAX 一个进程能够同时打开的消息队列的最大数目
</span></span></span><span class=line><span class=cl><span class=c1>//MQ_PRIO_MAX 消息的最大优先级 +1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>mqtest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>8192</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=sc>&#39;\0&#39;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=n>ssize_t</span> <span class=n>recvlen</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>mqd_t</span> <span class=n>mqd</span> <span class=o>=</span> <span class=n>mq_open</span><span class=p>(</span><span class=s>&#34;/kylemq&#34;</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mqd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;parent open mq&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>mq_attr</span> <span class=n>mqattr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mq_getattr</span><span class=p>(</span><span class=n>mqd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mqattr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;get mq attr&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;maxmsg = %ld, mq len = %ld, current msg = %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>mqattr</span><span class=p>.</span><span class=n>mq_maxmsg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>mqattr</span><span class=p>.</span><span class=n>mq_msgsize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>mqattr</span><span class=p>.</span><span class=n>mq_curmsgs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>rcvpri</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//接收消息的 buf 必须大于消息队列的大小，否则无法接收消息
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//Posix 消息队列读取时总是返回最高优先级的最早消息，且消息的优先级一起返回
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//每次只接收一条消息，消息有边界
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//读消息队列，只在消息队列为空的时候，阻塞等待；写消息队列，在队列满的时候，阻塞等待；
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//写不用等待读，读也不用等待写；可以让一个进程创建消息队列然后终止、第二个进程写消息队列然后终止、第三个进程读消息队列；
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//即进程结束后消息队列仍然存在
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//mq_notify 可以异步通知进程，有消息放入了空队列
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>recvlen</span> <span class=o>=</span> <span class=n>mq_receive</span><span class=p>(</span><span class=n>mqd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>8192</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rcvpri</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>recvlen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;parent receive mq&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;recvpriv=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>rcvpri</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>recvlen</span> <span class=o>!=</span> <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>recvlen</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;write to stdin&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mq_getattr</span><span class=p>(</span><span class=n>mqd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mqattr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;get mq attr&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;maxmsg = %ld, mq len = %ld, current msg = %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>mqattr</span><span class=p>.</span><span class=n>mq_maxmsg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>mqattr</span><span class=p>.</span><span class=n>mq_msgsize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>mqattr</span><span class=p>.</span><span class=n>mq_curmsgs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>recvlen</span> <span class=o>=</span> <span class=n>mq_receive</span><span class=p>(</span><span class=n>mqd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>8192</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>rcvpri</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>recvlen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;parent receive mq&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;recvpriv=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>rcvpri</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>recvlen</span> <span class=o>!=</span> <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>recvlen</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;write to stdin&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>mq_close</span><span class=p>(</span><span class=n>mqd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mq_unlink</span><span class=p>(</span><span class=s>&#34;/kylemq&#34;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;unlink after use&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;child fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>100</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=sc>&#39;\0&#39;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>mqd_t</span> <span class=n>mqd</span> <span class=o>=</span> <span class=n>mq_open</span><span class=p>(</span><span class=s>&#34;/kylemq&#34;</span><span class=p>,</span> <span class=n>O_WRONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mqd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s>&#34;child creat mq&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;A&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mq_send</span><span class=p>(</span><span class=n>mqd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>30</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s>&#34;child send buf&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>mq_close</span><span class=p>(</span><span class=n>mqd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>//if(-1 == mq_unlink(&#34;/kylemq&#34;)) {
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//    perror(&#34;unlink after use&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>//}
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>char</span> <span class=n>buf</span><span class=p>[</span><span class=mi>100</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=sc>&#39;\0&#39;</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mq_unlink</span><span class=p>(</span><span class=s>&#34;/kylemq&#34;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s>&#34;unlink before creat&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>mqd_t</span> <span class=n>mqd</span> <span class=o>=</span> <span class=n>mq_open</span><span class=p>(</span><span class=s>&#34;/kylemq&#34;</span><span class=p>,</span> <span class=n>O_WRONLY</span> <span class=o>|</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_EXCL</span><span class=p>,</span> <span class=mo>0777</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mqd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s>&#34;child creat mq&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>buf</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=sc>&#39;C&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>mq_send</span><span class=p>(</span><span class=n>mqd</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=mi>100</span><span class=p>,</span> <span class=mi>10</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>perror</span><span class=p>(</span><span class=s>&#34;child send buf&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>mq_close</span><span class=p>(</span><span class=n>mqd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>shm_mutx</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sem_t</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>shmtest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//shm_open 的权限位总是必须指定
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//shm_open 新创建的共享内存区对象的大小为零，必须使用 ftruncate 修改大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>shmd</span> <span class=o>=</span> <span class=n>shm_open</span><span class=p>(</span><span class=s>&#34;/kyleshm&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0777</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>shmd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;creat shm&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>//普通文件扩展，扩展部分填充为零；
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//共享内存扩展部分不一定为零。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>ftruncate</span><span class=p>(</span><span class=n>shmd</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;change shm size&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>stat</span> <span class=n>shmstat</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>fstat</span><span class=p>(</span><span class=n>shmd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>shmstat</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;get shm stat&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;shm size = %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>shmstat</span><span class=p>.</span><span class=n>st_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>pshm</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pshm</span> <span class=o>=</span> <span class=n>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>),</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>shmd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>MAP_FAILED</span> <span class=o>==</span> <span class=n>pshm</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;mmap shm&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sem_t</span> <span class=o>*</span><span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>SEM_FAILED</span> <span class=o>==</span> <span class=p>(</span><span class=n>mutex</span> <span class=o>=</span> <span class=n>sem_open</span><span class=p>(</span><span class=s>&#34;/kylemutex&#34;</span><span class=p>,</span> <span class=n>O_CREAT</span> <span class=o>|</span> <span class=n>O_EXCL</span><span class=p>,</span> <span class=mo>0777</span><span class=p>,</span> <span class=mi>1</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;creat mutex&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>sem_unlink</span><span class=p>(</span><span class=s>&#34;kylemutex&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pshm</span> <span class=o>=</span> <span class=mi>6543210</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>sem_wait</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;child read shm value = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>pshm</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pshm</span> <span class=o>=</span> <span class=mi>6543210</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>sem_post</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//sleep(1);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=n>sem_wait</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;parent read shm value = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>pshm</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>pshm</span> <span class=o>=</span> <span class=mi>123456</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>sem_post</span><span class=p>(</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>shm_unlink</span><span class=p>(</span><span class=s>&#34;kyleshm&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//mmap 测试
</span></span></span><span class=line><span class=cl><span class=c1>//mmap 映射到内存的大小小于文件的大小，仍然可以使用指针设置未映射到内存的空间但还在文件长度范围内的值
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>mmaptest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//int fd = open(&#34;foo&#34;, O_RDWR | O_CREAT | O_TRUNC, 0777);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>shm_open</span><span class=p>(</span><span class=s>&#34;kyleshm&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0777</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>fd</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;open foo&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ftruncate</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>string</span> <span class=o>=</span> <span class=s>&#34;YYYYYYYYYY&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>string</span><span class=p>,</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>pshmd</span> <span class=o>=</span> <span class=n>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>MAP_FAILED</span> <span class=o>==</span> <span class=n>pshmd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;mmap&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>pagesize</span> <span class=o>=</span> <span class=n>sysconf</span><span class=p>(</span><span class=n>_SC_PAGESIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;pagesize=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pagesize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>pshmd</span> <span class=o>=</span> <span class=sc>&#39;b&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>pshmd</span> <span class=o>+</span> <span class=mi>7</span><span class=p>)</span> <span class=o>=</span> <span class=sc>&#39;e&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>pshmd</span> <span class=o>+</span> <span class=mi>8</span><span class=p>)</span> <span class=o>=</span> <span class=sc>&#39;n&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>pshmd</span> <span class=o>+</span> <span class=mi>9</span><span class=p>)</span> <span class=o>=</span> <span class=sc>&#39;e&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//ftruncate(fd, 12288);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=p>(</span><span class=n>pshmd</span> <span class=o>+</span> <span class=mi>4095</span><span class=p>)</span> <span class=o>=</span> <span class=sc>&#39;e&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>pshmd</span> <span class=o>+</span> <span class=mi>4096</span><span class=p>)</span> <span class=o>=</span> <span class=sc>&#39;e&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>pshmd</span> <span class=o>+</span> <span class=mi>9192</span><span class=p>)</span> <span class=o>=</span> <span class=sc>&#39;e&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=n>pshmd</span> <span class=o>+</span> <span class=mi>12288</span><span class=p>)</span> <span class=o>=</span> <span class=sc>&#39;e&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//测试在进程的清理函数中释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>data</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_t</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>data</span> <span class=o>*</span><span class=n>something</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cleanprocess</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;excute the unlock clean</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=p>(</span><span class=n>something</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>unlockInAtexit</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>shmd</span> <span class=o>=</span> <span class=n>shm_open</span><span class=p>(</span><span class=s>&#34;/kyleshm&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0777</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>shmd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;creat shm&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>ftruncate</span><span class=p>(</span><span class=n>shmd</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>data</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;change the shm size&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>data</span> <span class=o>*</span><span class=n>pdata</span> <span class=o>=</span> <span class=n>mmap</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>data</span><span class=p>),</span> <span class=n>PROT_READ</span> <span class=o>|</span> <span class=n>PROT_WRITE</span><span class=p>,</span> <span class=n>MAP_SHARED</span><span class=p>,</span> <span class=n>shmd</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>MAP_FAILED</span> <span class=o>==</span> <span class=n>pdata</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;create mmap&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=p>(</span><span class=n>pdata</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>),</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>something</span> <span class=o>=</span> <span class=n>pdata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>atexit</span><span class=p>(</span><span class=n>cleanprocess</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;child process</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=p>(</span><span class=n>pdata</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;value = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pdata</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pdata</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>=</span> <span class=mi>123456</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;parent process</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=p>(</span><span class=n>pdata</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;value = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pdata</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pdata</span><span class=o>-&gt;</span><span class=n>value</span> <span class=o>=</span> <span class=mi>98765</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=p>(</span><span class=n>pdata</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>pthread_mutex_t</span> <span class=n>mutex</span> <span class=o>=</span> <span class=n>PTHREAD_MUTEX_INITIALIZER</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>meimei</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>fun1</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>meimei</span> <span class=o>=</span> <span class=mi>12345</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>meimei</span> <span class=o>=</span> <span class=mi>12346</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>meimei</span> <span class=o>=</span> <span class=mi>12347</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>meimei</span> <span class=o>=</span> <span class=mi>12348</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;meimei = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>meimei</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=mi>1234</span> <span class=o>!=</span> <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;unlock mutex&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=mi>1234</span> <span class=o>!=</span> <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;unlock mutex&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//pthread_exit(0);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>fun2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>meimei</span> <span class=o>=</span> <span class=mi>9876</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>meimei</span> <span class=o>=</span> <span class=mi>9874</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>meimei</span> <span class=o>=</span> <span class=mi>9873</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>meimei</span> <span class=o>=</span> <span class=mi>9872</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;meimei = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>meimei</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//pthread_exit(0);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>pthreadtest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>producenum</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_t</span> <span class=n>produceID</span><span class=p>[</span><span class=n>producenum</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>!=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>produceID</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>fun1</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;create pthread&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>!=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>produceID</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>fun2</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;create pthread&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_join</span><span class=p>(</span><span class=n>produceID</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_join</span><span class=p>(</span><span class=n>produceID</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//一个文件给定字节，同一个调用进程后来设置的值会覆盖掉之前设置的值。
</span></span></span><span class=line><span class=cl><span class=c1>//没有记录锁的类型是读写锁，只有读锁、写锁、没有锁三种
</span></span></span><span class=line><span class=cl><span class=c1>//而且同一个进程利用 f_GETLK 查看，始终会得到 F_UNLCK 。无论该字节是否已经设置上锁。（前提是没有其他进程对其进行上锁）
</span></span></span><span class=line><span class=cl><span class=c1>//只有被其他进程锁定才会获取到锁的类型
</span></span></span><span class=line><span class=cl><span class=c1>//Posix 记录锁是劝告性上锁（advisory locking）；
</span></span></span><span class=line><span class=cl><span class=c1>//书上写，一个进程可以无视一个劝告性锁而写一个读锁定文件，或者读一个写锁定文件；(进程有对该文件相应操作的权限)
</span></span></span><span class=line><span class=cl><span class=c1>//自己测试发现及时一个进程使用劝告性写锁锁住一个文件，另一个进程任然可以写该文件。
</span></span></span><span class=line><span class=cl><span class=c1>//记录锁不应该同标准 I/O 库一起使用，因为该函数库会执行内部缓冲。当某个文件需要使用记录锁时，为避免问题，应对其使用 read 、write 函数。
</span></span></span><span class=line><span class=cl><span class=c1>//如果系统支持强制性锁，一个进程对某些字节上锁，其他进程在调用 read/write 时会阻塞，直到锁被打开；
</span></span></span><span class=line><span class=cl><span class=c1>//但是任然无法保证程序不出现混乱，例如一个进程首先读取了受保护变量的值，然后内核切换进程，
</span></span></span><span class=line><span class=cl><span class=c1>//另一个进程锁住文件，修改变量，释放锁；
</span></span></span><span class=line><span class=cl><span class=c1>//此时前一个进程被内核调度回来，依据刚才读取的值做操作（由于该值已被另一个进程修改，所以是错误的值），导致错误的行为。
</span></span></span><span class=line><span class=cl><span class=c1>//多个进程同时操作某个文件时，必须都得上锁，否则违规就可能发生。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>fcntltest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>flock</span> <span class=n>flock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;foo&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>fd</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;open foo&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;F_RDLCK=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>F_RDLCK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;F_WRLCK=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>F_WRLCK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;F_UNLCK=%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>F_UNLCK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>perror</span><span class=p>(</span><span class=s>&#34;fork&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>pid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_type</span> <span class=o>=</span> <span class=n>F_WRLCK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_whence</span> <span class=o>=</span> <span class=n>SEEK_SET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_GETLK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;child get flock&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;child flock type : %d; lock pid = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>flock</span><span class=p>.</span><span class=n>l_type</span><span class=p>,</span> <span class=n>flock</span><span class=p>.</span><span class=n>l_pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_type</span> <span class=o>=</span> <span class=n>F_WRLCK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_whence</span> <span class=o>=</span> <span class=n>SEEK_SET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETLK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;child set write flock&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_type</span> <span class=o>=</span> <span class=n>F_RDLCK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_whence</span> <span class=o>=</span> <span class=n>SEEK_SET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETLK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;child set read flock&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>char</span> <span class=n>str</span><span class=p>[</span><span class=mi>1024</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>rdlen</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=mi>1024</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=n>rdlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=s>&#34;zxcvbn&#34;</span><span class=p>,</span> <span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=mi>6</span> <span class=o>!=</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;write file when flock by parent&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SEEK_SET</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>rdlen</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=mi>1024</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>write</span><span class=p>(</span><span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>str</span><span class=p>,</span> <span class=n>rdlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_type</span> <span class=o>=</span> <span class=n>F_WRLCK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_whence</span> <span class=o>=</span> <span class=n>SEEK_SET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETLK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;set flock&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_GETLK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;get flock 1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;flock type : %d; lock pid = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>flock</span><span class=p>.</span><span class=n>l_type</span><span class=p>,</span> <span class=n>flock</span><span class=p>.</span><span class=n>l_pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_type</span> <span class=o>=</span> <span class=n>F_RDLCK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_whence</span> <span class=o>=</span> <span class=n>SEEK_SET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETLK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;set flock&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_GETLK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;get flock 2&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;flock type : %d; lock pid = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>flock</span><span class=p>.</span><span class=n>l_type</span><span class=p>,</span> <span class=n>flock</span><span class=p>.</span><span class=n>l_pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_type</span> <span class=o>=</span> <span class=n>F_WRLCK</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_whence</span> <span class=o>=</span> <span class=n>SEEK_SET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>flock</span><span class=p>.</span><span class=n>l_len</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>rc</span> <span class=o>=</span> <span class=n>fcntl</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>F_SETLK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>flock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span> <span class=o>==</span> <span class=n>rc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>perror</span><span class=p>(</span><span class=s>&#34;parent set write flock&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div></div></div><div id=outline-container-headline-54 class=outline-3><h3 id=headline-54>pthread</h3><div id=outline-text-headline-54 class=outline-text-3><div class="src src-c"><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;pthread.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thr_fn</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thr_fn2</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>globalnum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>c</span> <span class=o>=</span> <span class=sc>&#39;s&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_t</span> <span class=n>ntid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_t</span> <span class=n>ntid2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>tret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_t</span> <span class=n>mutexlock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutexlock</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>!=</span> <span class=p>(</span><span class=n>rc</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ntid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>thr_fn</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutexlock</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=mi>0</span> <span class=o>!=</span> <span class=p>(</span><span class=n>rc</span> <span class=o>=</span> <span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ntid2</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>thr_fn2</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>mutexlock</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;main thread: pid = %lu, ppid = %lu, tid = %lu (0x%lx)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>getpid</span><span class=p>(),</span> <span class=n>getppid</span><span class=p>(),</span> <span class=n>pthread_self</span><span class=p>(),</span> <span class=n>pthread_self</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutexlock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>globalnum</span> <span class=o>+=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=sc>&#39;k&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutexlock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;num = %d, c = %c</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>globalnum</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_join</span><span class=p>(</span><span class=n>ntid</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_join</span><span class=p>(</span><span class=n>ntid2</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_destroy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>mutexlock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thr_fn</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;new thread: pid = %lu, ppid = %lu, tid = %lu (0x%lx)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>getpid</span><span class=p>(),</span> <span class=n>getppid</span><span class=p>(),</span> <span class=n>pthread_self</span><span class=p>(),</span> <span class=n>pthread_self</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>globalnum</span> <span class=o>+=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=sc>&#39;y&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;num = %d, c = %c</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>globalnum</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>thr_fn2</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;new thread: pid = %lu, ppid = %lu, tid = %lu (0x%lx)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>getpid</span><span class=p>(),</span> <span class=n>getppid</span><span class=p>(),</span> <span class=n>pthread_self</span><span class=p>(),</span> <span class=n>pthread_self</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>globalnum</span> <span class=o>+=</span> <span class=mi>1000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span> <span class=o>=</span> <span class=sc>&#39;l&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;num = %d, c = %c</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>globalnum</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_exit</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><div class="src src-c"><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;signal.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define PIPETOAYC
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>volatile</span> <span class=n>sig_atomic_t</span> <span class=n>sigflag</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>sigset_t</span> <span class=n>newmask</span><span class=p>,</span> <span class=n>oldmask</span><span class=p>,</span> <span class=n>zeromask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>child2parentfd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>parent2childfd</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>charatatime</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_usr</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>TELL_WAIT</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>WAIT_CHILD</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>TELL_CHILD</span><span class=p>(</span><span class=n>pid_t</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>WAIT_PARENT</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>TELL_PARENT</span><span class=p>(</span><span class=n>pid_t</span> <span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TELL_WAIT</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>((</span><span class=n>pid</span> <span class=o>=</span> <span class=n>fork</span><span class=p>())</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>pid</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>WAIT_CHILD</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>charatatime</span><span class=p>(</span><span class=s>&#34;Parent do whatever is necessary ...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>TELL_CHILD</span><span class=p>(</span><span class=n>pid</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>//charatatime(&#34;GO on to do something in parent\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>charatatime</span><span class=p>(</span><span class=s>&#34;Child do whatever is necessary ...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>TELL_PARENT</span><span class=p>(</span><span class=n>getppid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>WAIT_PARENT</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=c1>//charatatime(&#34;GO on to do something in parent\n&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef SIGTOSYC
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>static</span> <span class=kt>void</span> <span class=nf>sig_usr</span><span class=p>(</span><span class=kt>int</span> <span class=n>signo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sigflag</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>TELL_WAIT</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>SIG_ERR</span> <span class=o>==</span> <span class=n>signal</span><span class=p>(</span><span class=n>SIGUSR1</span><span class=p>,</span> <span class=n>sig_usr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>SIG_ERR</span> <span class=o>==</span> <span class=n>signal</span><span class=p>(</span><span class=n>SIGUSR2</span><span class=p>,</span> <span class=n>sig_usr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>zeromask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sigaddset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=n>SIGUSR1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sigaddset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=n>SIGUSR2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>sigprocmask</span><span class=p>(</span><span class=n>SIG_BLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>newmask</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>TELL_CHILD</span><span class=p>(</span><span class=n>pid_t</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>kill</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=n>SIGUSR1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>WAIT_CHILD</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>sigflag</span><span class=p>)</span> <span class=p>{</span> <span class=c1>//可能有其他信号唤醒进程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sigsuspend</span><span class=p>(</span><span class=o>&amp;</span><span class=n>zeromask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>sigflag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>sigprocmask</span><span class=p>(</span><span class=n>SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>TELL_PARENT</span><span class=p>(</span><span class=n>pid_t</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>kill</span><span class=p>(</span><span class=n>pid</span><span class=p>,</span> <span class=n>SIGUSR2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>WAIT_PARENT</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=n>sigflag</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sigsuspend</span><span class=p>(</span><span class=o>&amp;</span><span class=n>zeromask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>sigflag</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>sigprocmask</span><span class=p>(</span><span class=n>SIG_SETMASK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>oldmask</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef PIPETOAYC
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>TELL_WAIT</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>pipe</span><span class=p>(</span><span class=n>child2parentfd</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>pipe</span><span class=p>(</span><span class=n>parent2childfd</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>TELL_PARENT</span><span class=p>(</span><span class=n>pid_t</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>write</span><span class=p>(</span><span class=n>child2parentfd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=s>&#34;c&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>WAIT_PARENT</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>read</span><span class=p>(</span><span class=n>parent2childfd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>c</span> <span class=o>!=</span> <span class=sc>&#39;p&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>TELL_CHILD</span><span class=p>(</span><span class=n>pid_t</span> <span class=n>pid</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>write</span><span class=p>(</span><span class=n>parent2childfd</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=s>&#34;p&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>WAIT_CHILD</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>read</span><span class=p>(</span><span class=n>child2parentfd</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>c</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>c</span> <span class=o>!=</span> <span class=sc>&#39;c&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>charatatime</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>setbuf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>ptr</span> <span class=o>=</span> <span class=n>str</span><span class=p>;</span> <span class=p>(</span><span class=n>c</span> <span class=o>=</span> <span class=o>*</span><span class=n>ptr</span><span class=o>++</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>putc</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>stdout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div></div></div></div></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://kylestones.github.io/tags/linux/>Linux,</a></li><li><a href=https://kylestones.github.io/tags/c/>C</a></li></ul><nav class=paginav><a class=prev href=https://kylestones.github.io/blog/apue/unp/><span class=title>« Prev</span><br><span>Unix Network Programming</span></a>
<a class=next href=https://kylestones.github.io/blog/book/how-to-read-a-book/><span class=title>Next »</span><br><span>How to read a book</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Advanced Programming in the UNIX Environment on twitter" href="https://twitter.com/intent/tweet/?text=Advanced%20Programming%20in%20the%20UNIX%20Environment&url=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fapue%2f&hashtags=Linux%2c%2cC"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advanced Programming in the UNIX Environment on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fapue%2f&title=Advanced%20Programming%20in%20the%20UNIX%20Environment&summary=Advanced%20Programming%20in%20the%20UNIX%20Environment&source=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fapue%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advanced Programming in the UNIX Environment on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fapue%2f&title=Advanced%20Programming%20in%20the%20UNIX%20Environment"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advanced Programming in the UNIX Environment on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fapue%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advanced Programming in the UNIX Environment on whatsapp" href="https://api.whatsapp.com/send?text=Advanced%20Programming%20in%20the%20UNIX%20Environment%20-%20https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fapue%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Advanced Programming in the UNIX Environment on telegram" href="https://telegram.me/share/url?text=Advanced%20Programming%20in%20the%20UNIX%20Environment&url=https%3a%2f%2fkylestones.github.io%2fblog%2fapue%2fapue%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://kylestones.github.io>Org Mode</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>